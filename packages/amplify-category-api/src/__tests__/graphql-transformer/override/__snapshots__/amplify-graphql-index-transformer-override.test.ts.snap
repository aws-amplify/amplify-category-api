// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`it overrides expected resources 1`] = `
Object {
  "Mutation.createSong.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.createSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.createSong.req.vtl": "## [Start] Create Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Song\\"))
#set( $nullIndexFields = [] )
#set( $indexFields = [\\"genre\\"] )
#foreach( $entry in $util.map.copyAndRetainAllKeys($mergedValues, $indexFields).entrySet() )
  #if( $util.isNull($entry.value) )
    $util.qr($nullIndexFields.add($entry.key))
  #end
#end
#set( $mergedValues = $util.map.copyAndRemoveAllKeys($mergedValues, $nullIndexFields) )
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": false
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - key condition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObjectKey )
  $util.qr($PutObject.put(\\"key\\", $ctx.stash.metadata.modelObjectKey))
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.createSong.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.deleteSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.deleteSong.req.vtl": "## [Start] Delete Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.qr($DeleteRequest.put(\\"_version\\", $util.defaultIfNull($args.input[\\"_version\\"], 0)))
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.deleteSong.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.updateSong.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.updateSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.updateSong.req.vtl": "## [Start] Mutation Update resolver. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyFields = [\\"_version\\", \\"_deleted\\", \\"_lastChangedAt\\"] )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\", \\"_version\\", \\"_deleted\\", \\"_lastChangedAt\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( !$util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) && $ctx.stash.metadata.dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $ctx.stash.metadata.dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update,
  \\"_version\\": $util.defaultIfNull($args.input[\\"_version\\"], 0)
} )
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.updateSong.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.getSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.getSong.req.vtl": "## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $expression = \\"\\" )
  #set( $expressionNames = {} )
  #set( $expressionValues = {} )
  #foreach( $item in $ctx.stash.metadata.modelObjectKey.entrySet() )
    #set( $expression = \\"$expression#keyCount$velocityCount = :valueCount$velocityCount AND \\" )
    $util.qr($expressionNames.put(\\"#keyCount$velocityCount\\", $item.key))
    $util.qr($expressionValues.put(\\":valueCount$velocityCount\\", $item.value))
  #end
  #set( $expression = $expression.replaceAll(\\"AND $\\", \\"\\") )
  #set( $query = {
  \\"expression\\": $expression,
  \\"expressionNames\\": $expressionNames,
  \\"expressionValues\\": $expressionValues
} )
#else
  #set( $query = {
  \\"expression\\": \\"id = :id\\",
  \\"expressionValues\\": {
      \\":id\\":     $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.id))
  }
} )
#end
$util.qr($GetRequest.put(\\"query\\", $query))
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  $util.qr($GetRequest.put(\\"filter\\", $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.authFilter))))
#end
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.getSong.res.vtl": "## [Start] Get Response template. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#end
#if( !$ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
  $util.toJson($ctx.result.items[0])
#else
  #if( $ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
$util.unauthorized()
  #end
  $util.toJson(null)
#end
## [End] Get Response template. **",
  "Query.listSongs.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.listSongs.req.vtl": "## [Start] List Request. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $limit = $util.defaultIfNull($args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $args.nextToken )
  #set( $ListRequest.nextToken = $args.nextToken )
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQueryExpression) && !$util.isNullOrEmpty($ctx.stash.modelQueryExpression.expression) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $ctx.stash.modelQueryExpression))
  #if( !$util.isNull($args.sortDirection) && $args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.listSongs.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.songInfoByGenre.postAuth.1.res.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.songInfoByGenre.req.vtl": "## [Start] Set query expression for key **
#if( !$util.isNull($ctx.args.sortDirection) )
  $util.error(\\"sortDirection is not supported for List operations without a Sort key defined.\\", \\"InvalidArgumentsError\\")
#end
#set( $modelQueryExpression = {} )
#if( !$util.isNull($ctx.args.genre) )
  #set( $modelQueryExpression.expression = \\"#genre = :genre\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#genre\\": \\"genre\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":genre\\": {
      \\"S\\": \\"$ctx.args.genre\\"
  }
} )
#end
## [End] Set query expression for key **
#set( $limit = $util.defaultIfNull($context.args.limit, 100) )
#set( $QueryRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\",
  \\"limit\\": $limit,
  \\"query\\": $modelQueryExpression,
  \\"index\\": \\"byGenre\\"
} )
#if( !$util.isNull($ctx.args.sortDirection)
                      && $ctx.args.sortDirection == \\"DESC\\" )
  #set( $QueryRequest.scanIndexForward = false )
#else
  #set( $QueryRequest.scanIndexForward = true )
#end
#if( $context.args.nextToken ) #set( $QueryRequest.nextToken = $context.args.nextToken ) #end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $ctx.args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = $ctx.args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $QueryRequest.filter = $filterExpression )
  #end
#end
$util.toJson($QueryRequest)",
  "Query.songInfoByGenre.res.vtl": "#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#end
$util.toJson($ctx.result)",
  "Query.syncSongs.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.syncSongs.preAuth.1.req.vtl": "## [Start] Set map initialization for @key **
#set( $index = \\"\\" )
#set( $scan = true )
#set( $filterMap = {} )
#set( $QueryMap = {} )
#set( $PkMap = {} )
#set( $filterArgsMap = {} )
## [End] Set map initialization for @key **
## [Start] Set query expression for @key **
$util.qr($QueryMap.put('genre' , 'byGenre'))
$util.qr($PkMap.put('genre' , 'byGenre'))
## [End] Set query expression for @key **
## [Start] Set query expression for @key **
#set( $filterArgsMap = $ctx.args.filter.get(\\"and\\") )
#set( $isLastSyncInDeltaTTLWindow = false )
#set( $minLastSync = $util.time.nowEpochMilliSeconds() - NaN )
#if( !$util.isNull($ctx.args.lastSync) && $ctx.args.lastSync != 0 && $minLastSync <= $ctx.args.lastSync )
  #set( $isLastSyncInDeltaTTLWindow = true )
#end
#if( !$util.isNullOrEmpty($filterArgsMap) && !$isLastSyncInDeltaTTLWindow )
  #set( $json = $filterArgsMap )
  #foreach( $item in $json )
    #set( $ind = $foreach.index )
    #foreach( $entry in $item.entrySet() )
      #if( $ind == 0 && !$util.isNullOrEmpty($entry.value.eq) && !$util.isNullOrEmpty($PkMap.get($entry.key)) )
        #set( $pk = $entry.key )
        #set( $scan = false )
        $util.qr($ctx.args.put($pk,$entry.value.eq))
        #set( $index = $PkMap.get($pk) )
      #end
      #if( $ind == 1 && !$util.isNullOrEmpty($pk) && !$util.isNullOrEmpty($QueryMap.get(\\"\${pk}+$entry.key\\")) )
        #set( $sk = $entry.key )
        $util.qr($ctx.args.put($sk,$entry.value))
        #set( $index = $QueryMap.get(\\"\${pk}+$sk\\") )
      #else
        #if( $ind > 0 )
          $util.qr($filterMap.put($entry.key,$entry.value))
        #end
      #end
    #end
  #end
#else
  #set( $filterMap = $ctx.args.filter )
#end
## [End] Set query expression for @key **
## [Start] Set Primary Key initialization @key **
#set( $modelQueryExpression = {} )
#if( !$util.isNull($pk) )
  #set( $modelQueryExpression.expression = \\"#pk = :pk\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#pk\\": \\"$pk\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":pk\\": $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($pk)))
} )
#end
## [End] Set Primary Key initialization @key **
## [Start] Applying Key Condition **
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).beginsWith) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).beginsWith))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).between) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).between[0]))))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).between[1]))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).eq) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).eq))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).lt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).lt))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).le) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).le))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).gt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).gt))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).ge) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).ge))))
#end
## [End] Applying Key Condition **
## [Start]  Set query expression for @key **
#if( !$scan )
  #set( $limit = $util.defaultIfNull($context.args.limit, 100) )
  #set( $QueryRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Sync\\",
  \\"limit\\": $limit,
  \\"lastSync\\": $util.defaultIfNull($ctx.args.lastSync, null),
  \\"query\\": $modelQueryExpression
} )
  #if( !$util.isNull($ctx.args.sortDirection)
                    && $ctx.args.sortDirection == \\"DESC\\" )
    #set( $QueryRequest.scanIndexForward = false )
  #else
    #set( $QueryRequest.scanIndexForward = true )
  #end
#if( $context.args.nextToken ) #set( $QueryRequest.nextToken = $context.args.nextToken ) #end
  #if( !$util.isNullOrEmpty($filterMap) )
    #set( $QueryRequest.filter = $util.parseJson($util.transform.toDynamoDBFilterExpression($filterMap)) )
  #end
  #if( $index != \\"dbTable\\" )
    #set( $QueryRequest.index = $index )
  #end
  $util.toJson($QueryRequest)
#else
{
      \\"version\\": \\"2018-05-29\\",
      \\"operation\\": \\"Sync\\",
      \\"limit\\": $util.defaultIfNull($ctx.args.limit, 100),
      \\"nextToken\\": $util.toJson($util.defaultIfNull($ctx.args.nextToken, null)),
      \\"lastSync\\": $util.toJson($util.defaultIfNull($ctx.args.lastSync, null)),
      \\"filter\\":     #if( !$util.isNullOrEmpty($ctx.args.filter) )
$util.transform.toDynamoDBFilterExpression($ctx.args.filter)
    #else
null
    #end
  }
#end
## [End]  Set query expression for @key **
",
  "Query.syncSongs.req.vtl": "## [Start] Sync Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $queryFilterContainsAuthField = false )
#set( $authFilterContainsSortKey = false )
#set( $useScan = true )
#if( $util.isNullOrEmpty($ctx.stash.authFilter) && $ctx.stash.QueryRequest )
  #set( $useScan = false )
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( $ctx.stash.QueryRequestVariables.partitionKey )
    #foreach( $filterItem in $ctx.stash.authFilter.or )
      #if( $filterItem.get($ctx.stash.QueryRequestVariables.partitionKey) )
        #set( $queryFilterContainsAuthField = true )
      #end
    #end
    #if( !$queryFilterContainsAuthField )
      #foreach( $filterItem in $ctx.stash.authFilter.or )
        #foreach( $sortKey in $ctx.stash.QueryRequestVariables.sortKeys )
          #if( $filterItem.get($sortKey) )
            #set( $authFilterContainsSortKey = true )
          #end
        #end
      #end
      #if( !$authFilterContainsSortKey )
        #if( !$util.isNullOrEmpty($ctx.stash.QueryRequest.filter) )
          #set( $ctx.stash.QueryRequest.filter = {
  \\"and\\":   [$ctx.stash.QueryRequest.filter, $ctx.stash.authFilter]
} )
        #else
          #set( $ctx.stash.QueryRequest.filter = $ctx.stash.authFilter )
        #end
        #set( $useScan = false )
      #end
    #else
      #foreach( $filterItem in $ctx.stash.authFilter.or )
        #if( $util.toJson($filterItem) == $util.toJson($ctx.stash.QueryRequestVariables.partitionKeyFilter) )
          #set( $useScan = false )
        #end
      #end
    #end
  #end
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $filter = $filterExpression )
  #end
#end
#if( !$useScan )
  #if( $ctx.stash.QueryRequest.filter )
    #set( $ctx.stash.QueryRequest.filter = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.QueryRequest.filter)) )
  #end
  $util.toJson($ctx.stash.QueryRequest)
#else
{
      \\"version\\": \\"2018-05-29\\",
      \\"operation\\": \\"Sync\\",
      \\"filter\\":     #if( $filter )
$util.toJson($filter)
    #else
null
    #end,
      \\"limit\\": $util.defaultIfNull($args.limit, 100),
      \\"lastSync\\": $util.toJson($util.defaultIfNull($args.lastSync, null)),
      \\"nextToken\\": $util.toJson($util.defaultIfNull($args.nextToken, null))
  }
#end
## [End] Sync Request template. **",
  "Query.syncSongs.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Subscription.onCreateSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onCreateSong.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onCreateSong.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onDeleteSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onDeleteSong.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onDeleteSong.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onUpdateSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onUpdateSong.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onUpdateSong.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
}
`;
