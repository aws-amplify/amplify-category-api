## API Report File for "graphql-mapping-template"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export function and(expressions: Expression[]): AndNode;

// @public (undocumented)
export interface AndNode {
    // (undocumented)
    expressions: Expression[];
    // (undocumented)
    kind: 'And';
}

// @public (undocumented)
export function block(name: string, exprs: Expression[]): CompoundExpressionNode;

// @public (undocumented)
export function bool(value: boolean): BooleanNode;

// @public (undocumented)
export interface BooleanNode {
    // (undocumented)
    kind: 'Boolean';
    // (undocumented)
    value: boolean;
}

// @public (undocumented)
export function comment(text: string): CommentNode;

// @public (undocumented)
export interface CommentNode {
    // (undocumented)
    kind: 'Comment';
    // (undocumented)
    text: string;
}

// @public (undocumented)
export function compoundExpression(expressions: Expression[], joiner?: string, recurseIndent?: boolean): CompoundExpressionNode;

// @public (undocumented)
export interface CompoundExpressionNode {
    // (undocumented)
    expressions: Expression[];
    // (undocumented)
    joiner: string;
    // (undocumented)
    kind: 'CompoundExpression';
    // (undocumented)
    recurseIndent: boolean;
}

// @public (undocumented)
export class DynamoDBMappingTemplate {
    // (undocumented)
    static binaryAttributeValue(value: Expression): ObjectNode;
    // (undocumented)
    static deleteItem({ key, condition, isSyncEnabled, }: {
        key: ObjectNode | Expression;
        condition: ObjectNode | ReferenceNode;
        isSyncEnabled: boolean;
    }): ObjectNode;
    // (undocumented)
    static dynamoDBResponse(isSyncEnabled: boolean, returnExpression?: Expression): CompoundExpressionNode;
    // (undocumented)
    static getItem({ key, isSyncEnabled }: {
        key: ObjectNode | Expression;
        isSyncEnabled?: boolean;
    }): ObjectNode;
    // (undocumented)
    static listItem({ filter, limit, nextToken, scanIndexForward, query, index, }: {
        filter: ObjectNode | Expression;
        limit: Expression;
        nextToken?: Expression;
        scanIndexForward?: Expression;
        query?: ObjectNode | Expression;
        index?: StringNode;
    }, version?: string): ObjectNode;
    // (undocumented)
    static numericAttributeValue(value: Expression): ObjectNode;
    // (undocumented)
    static paginatedResponse(): ObjectNode;
    // (undocumented)
    static putItem({ key, attributeValues, condition, }: {
        key: ObjectNode | Expression;
        attributeValues: Expression;
        condition?: ObjectNode | ReferenceNode;
    }, version?: string): ObjectNode;
    // (undocumented)
    static query({ query, scanIndexForward, filter, limit, nextToken, index, }: {
        query: ObjectNode | Expression;
        scanIndexForward: Expression;
        filter: ObjectNode | Expression;
        limit: Expression;
        nextToken?: Expression;
        index?: StringNode;
    }): ObjectNode;
    // (undocumented)
    static stringAttributeValue(value: Expression): ObjectNode;
    // (undocumented)
    static syncItem({ filter, limit, nextToken, lastSync, }: {
        filter?: ObjectNode | Expression;
        limit?: Expression;
        nextToken?: Expression;
        lastSync?: Expression;
    }): CompoundExpressionNode;
    // (undocumented)
    static updateItem({ key, condition, objectKeyVariable, nameOverrideMap, isSyncEnabled, }: {
        key: ObjectNode | Expression;
        condition: ObjectNode | ReferenceNode;
        objectKeyVariable: string;
        nameOverrideMap?: string;
        isSyncEnabled?: boolean;
    }): CompoundExpressionNode;
}

// @public (undocumented)
export class ElasticsearchMappingTemplate extends SearchableMappingTemplate {
}

// @public (undocumented)
export function equals(leftExpr: Expression, rightExpr: Expression): EqualsNode;

// @public (undocumented)
export interface EqualsNode {
    // (undocumented)
    kind: 'Equals';
    // (undocumented)
    leftExpr: Expression;
    // (undocumented)
    rightExpr: Expression;
}

// @public (undocumented)
export type Expression = IfNode | IfElseNode | AndNode | OrNode | ParensNode | EqualsNode | NotEqualsNode | ForEachNode | StringNode | RawNode | QuotesNode | FloatNode | IntNode | BooleanNode | NullNode | ReferenceNode | QuietReferenceNode | ObjectNode | ListNode | SetNode | CommentNode | CompoundExpressionNode | ToJsonNode | IsNullOrEmptyNode | NotNode | NewLineNode | ReturnNode;

// @public (undocumented)
export function float(value: number): FloatNode;

// @public (undocumented)
export interface FloatNode {
    // (undocumented)
    kind: 'Float';
    // (undocumented)
    value: number;
}

// @public (undocumented)
export function forEach(key: ReferenceNode, collection: ReferenceNode, expressions: Expression[]): ForEachNode;

// @public (undocumented)
export interface ForEachNode {
    // (undocumented)
    collection: ReferenceNode;
    // (undocumented)
    expressions: Expression[];
    // (undocumented)
    key: ReferenceNode;
    // (undocumented)
    kind: 'ForEach';
}

// @public (undocumented)
export class HttpMappingTemplate {
    // (undocumented)
    static deleteRequest({ resourcePath, params }: {
        resourcePath: string;
        params: ObjectNode;
    }): ObjectNode;
    // (undocumented)
    static getRequest({ resourcePath, params }: {
        resourcePath: string;
        params: ObjectNode;
    }): ObjectNode;
    // (undocumented)
    static patchRequest({ resourcePath, params }: {
        resourcePath: string;
        params: ObjectNode;
    }): ObjectNode;
    // (undocumented)
    static postRequest({ resourcePath, params }: {
        resourcePath: string;
        params: ObjectNode;
    }): ObjectNode;
    // (undocumented)
    static putRequest({ resourcePath, params }: {
        resourcePath: string;
        params: ObjectNode;
    }): ObjectNode;
    // (undocumented)
    static RESOLVER_VERSION_ID: string;
}

// @public (undocumented)
export function ifElse(predicate: Expression, ifExpr: Expression, elseExpr: Expression, inline?: boolean): IfElseNode;

// @public (undocumented)
export interface IfElseNode {
    // (undocumented)
    elseExpr: Expression;
    // (undocumented)
    ifExpr: Expression;
    // (undocumented)
    inline: boolean;
    // (undocumented)
    kind: 'IfElse';
    // (undocumented)
    predicate: Expression;
}

// @public (undocumented)
export function iff(predicate: Expression, expr: Expression, inline?: boolean): IfNode;

// @public (undocumented)
export interface IfNode {
    // (undocumented)
    expr: Expression;
    // (undocumented)
    inline: boolean;
    // (undocumented)
    kind: 'If';
    // (undocumented)
    predicate: Expression;
}

// @public (undocumented)
export function int(value: number): IntNode;

// @public (undocumented)
export interface IntNode {
    // (undocumented)
    kind: 'Int';
    // (undocumented)
    value: number;
}

// @public (undocumented)
export function isNullOrEmpty(expr: Expression): IsNullOrEmptyNode;

// @public (undocumented)
export type IsNullOrEmptyNode = {
    kind: 'Util.isNullOrEmpty';
    expr: Expression;
};

// @public (undocumented)
export function list(expressions: Expression[]): ListNode;

// @public (undocumented)
export interface ListNode {
    // (undocumented)
    expressions: Expression[];
    // (undocumented)
    kind: 'List';
}

// @public (undocumented)
export function methodCall(methodName: ReferenceNode, ...params: Expression[]): CompoundExpressionNode;

// @public (undocumented)
export function newline(): NewLineNode;

// @public (undocumented)
export type NewLineNode = {
    kind: 'NewLine';
};

// @public (undocumented)
export function not(expr: Expression): NotNode;

// @public (undocumented)
export function notEquals(leftExpr: Expression, rightExpr: Expression): NotEqualsNode;

// @public (undocumented)
export interface NotEqualsNode {
    // (undocumented)
    kind: 'NotEquals';
    // (undocumented)
    leftExpr: Expression;
    // (undocumented)
    rightExpr: Expression;
}

// @public (undocumented)
export interface NotNode {
    // (undocumented)
    expr: Expression;
    // (undocumented)
    kind: 'Not';
}

// @public (undocumented)
export function nul(): NullNode;

// @public (undocumented)
export interface NullNode {
    // (undocumented)
    kind: 'Null';
}

// @public (undocumented)
export function obj(o: {
    [key: string]: Expression;
}): ObjectNode;

// @public (undocumented)
export interface ObjectNode {
    // (undocumented)
    attributes: [string, Expression][];
    // (undocumented)
    kind: 'Object';
}

// @public (undocumented)
export function or(expressions: Expression[]): OrNode;

// @public (undocumented)
export interface OrNode {
    // (undocumented)
    expressions: Expression[];
    // (undocumented)
    kind: 'Or';
}

// @public (undocumented)
export function parens(expr: Expression): ParensNode;

// @public (undocumented)
export interface ParensNode {
    // (undocumented)
    expr: Expression;
    // (undocumented)
    kind: 'Parens';
}

// @public (undocumented)
function print_2(expr: Expression): string;
export { print_2 as print }

// @public (undocumented)
export function printBlock(name: string): (expr: Expression) => string;

// @public (undocumented)
export function printObject(node: ObjectNode, indent?: string): string;

// @public (undocumented)
export function qref(value: string | Expression): QuietReferenceNode;

// @public (undocumented)
export interface QuietReferenceNode {
    // (undocumented)
    kind: 'QuietReference';
    // (undocumented)
    value: string | Expression;
}

// @public (undocumented)
export function quotes(expr: Expression): QuotesNode;

// @public (undocumented)
export interface QuotesNode {
    // (undocumented)
    expr: Expression;
    // (undocumented)
    kind: 'Quotes';
}

// @public (undocumented)
export function raw(value: string): RawNode;

// @public (undocumented)
export interface RawNode {
    // (undocumented)
    kind: 'Raw';
    // (undocumented)
    value: string;
}

// @public (undocumented)
export function ref(value: string): ReferenceNode;

// @public (undocumented)
export interface ReferenceNode {
    // (undocumented)
    kind: 'Reference';
    // (undocumented)
    value: string;
}

// @public (undocumented)
export const RESOLVER_VERSION_ID = "2018-05-29";

// @public (undocumented)
export function ret(value?: Expression): ReturnNode;

// @public (undocumented)
export interface ReturnNode {
    // (undocumented)
    kind: 'Return';
    // (undocumented)
    value: Expression;
}

// @public (undocumented)
export class SearchableMappingTemplate {
    // (undocumented)
    static genericTemplate({ operation, path, params, }: {
        operation: Expression;
        path: Expression;
        params: Expression | ObjectNode | CompoundExpressionNode;
    }): ObjectNode;
    // (undocumented)
    static searchItem({ query, size, search_after, from, path, sort, version, }: {
        path: Expression;
        sort?: Expression | ObjectNode;
        query?: ObjectNode | Expression;
        size?: Expression;
        search_after?: Expression | ListNode;
        from?: Expression;
        version?: BooleanNode;
        aggs?: Expression | ObjectNode;
    }): ObjectNode;
    // (undocumented)
    static searchTemplate({ query, size, search_after, from, path, sort, version, aggs, }: {
        path: Expression;
        sort?: Expression | ObjectNode;
        query?: ObjectNode | Expression;
        size?: Expression;
        search_after?: Expression | ListNode;
        from?: Expression;
        version?: BooleanNode;
        aggs?: Expression | ObjectNode;
    }): ObjectNode;
}

// @public (undocumented)
export function set(key: ReferenceNode, value: Expression): SetNode;

// @public (undocumented)
export interface SetNode {
    // (undocumented)
    key: ReferenceNode;
    // (undocumented)
    kind: 'Set';
    // (undocumented)
    value: Expression;
}

// @public (undocumented)
export function str(value: string): StringNode;

// @public (undocumented)
export interface StringNode {
    // (undocumented)
    kind: 'String';
    // (undocumented)
    value: string;
}

// @public (undocumented)
export function toJson(expr: Expression): ToJsonNode;

// @public (undocumented)
export type ToJsonNode = {
    kind: 'Util.ToJson';
    expr: Expression;
};

// (No @packageDocumentation comment for this package)

```
