// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`has many query 1`] = `
"type Team {
  id: ID!
  name: String!
  members(filter: ModelMemberFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelMemberConnection
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Member {
  id: ID!
  teamID: ID!
  team: Team
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelSubscriptionStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  in: [String]
  notIn: [String]
}

input ModelSubscriptionIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  in: [Int]
  notIn: [Int]
}

input ModelSubscriptionFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  in: [Float]
  notIn: [Float]
}

input ModelSubscriptionBooleanInput {
  ne: Boolean
  eq: Boolean
}

input ModelSubscriptionIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  in: [ID]
  notIn: [ID]
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelTeamConnection {
  items: [Team]!
  nextToken: String
}

input ModelTeamFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelTeamFilterInput]
  or: [ModelTeamFilterInput]
  not: ModelTeamFilterInput
}

type Query {
  getTeam(id: ID!): Team
  listTeams(filter: ModelTeamFilterInput, limit: Int, nextToken: String): ModelTeamConnection
  getMember(id: ID!): Member
  listMembers(filter: ModelMemberFilterInput, limit: Int, nextToken: String): ModelMemberConnection
}

input ModelTeamConditionInput {
  name: ModelStringInput
  and: [ModelTeamConditionInput]
  or: [ModelTeamConditionInput]
  not: ModelTeamConditionInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
}

input CreateTeamInput {
  id: ID
  name: String!
}

input UpdateTeamInput {
  id: ID!
  name: String
}

input DeleteTeamInput {
  id: ID!
}

type Mutation {
  createTeam(input: CreateTeamInput!, condition: ModelTeamConditionInput): Team
  updateTeam(input: UpdateTeamInput!, condition: ModelTeamConditionInput): Team
  deleteTeam(input: DeleteTeamInput!, condition: ModelTeamConditionInput): Team
  createMember(input: CreateMemberInput!, condition: ModelMemberConditionInput): Member
  updateMember(input: UpdateMemberInput!, condition: ModelMemberConditionInput): Member
  deleteMember(input: DeleteMemberInput!, condition: ModelMemberConditionInput): Member
}

input ModelSubscriptionTeamFilterInput {
  id: ModelSubscriptionIDInput
  name: ModelSubscriptionStringInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionTeamFilterInput]
  or: [ModelSubscriptionTeamFilterInput]
}

type Subscription {
  onCreateTeam(filter: ModelSubscriptionTeamFilterInput): Team @aws_subscribe(mutations: [\\"createTeam\\"])
  onUpdateTeam(filter: ModelSubscriptionTeamFilterInput): Team @aws_subscribe(mutations: [\\"updateTeam\\"])
  onDeleteTeam(filter: ModelSubscriptionTeamFilterInput): Team @aws_subscribe(mutations: [\\"deleteTeam\\"])
  onCreateMember(filter: ModelSubscriptionMemberFilterInput): Member @aws_subscribe(mutations: [\\"createMember\\"])
  onUpdateMember(filter: ModelSubscriptionMemberFilterInput): Member @aws_subscribe(mutations: [\\"updateMember\\"])
  onDeleteMember(filter: ModelSubscriptionMemberFilterInput): Member @aws_subscribe(mutations: [\\"deleteMember\\"])
}

type ModelMemberConnection {
  items: [Member]!
  nextToken: String
}

input ModelMemberFilterInput {
  id: ModelIDInput
  teamID: ModelIDInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelMemberFilterInput]
  or: [ModelMemberFilterInput]
  not: ModelMemberFilterInput
}

input ModelMemberConditionInput {
  teamID: ModelIDInput
  and: [ModelMemberConditionInput]
  or: [ModelMemberConditionInput]
  not: ModelMemberConditionInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
}

input CreateMemberInput {
  id: ID
  teamID: ID!
}

input UpdateMemberInput {
  id: ID!
  teamID: ID
}

input DeleteMemberInput {
  id: ID!
}

input ModelSubscriptionMemberFilterInput {
  id: ModelSubscriptionIDInput
  teamID: ModelSubscriptionIDInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionMemberFilterInput]
  or: [ModelSubscriptionMemberFilterInput]
}
"
`;

exports[`has many query 2`] = `
"#if( $ctx.stash.deniedField )
  #return($util.toJson(null))
#end
#set( $partitionKeyValue = $util.defaultIfNull($ctx.stash.connectionAttributes.get(\\"id\\"), $ctx.source.id) )
#if( $util.isNull($partitionKeyValue) )
  #set( $result = {
  \\"items\\":   []
} )
  #return($result)
#else
  #set( $limit = $util.defaultIfNull($context.args.limit, 100) )
  #set( $query = {
  \\"expression\\": \\"#partitionKey = :partitionKey\\",
  \\"expressionNames\\": {
      \\"#partitionKey\\": \\"teamID\\"
  },
  \\"expressionValues\\": {
      \\":partitionKey\\": $util.dynamodb.toDynamoDB($partitionKeyValue)
  }
} )
  #set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
  #if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
    #set( $filter = $ctx.stash.authFilter )
    #if( !$util.isNullOrEmpty($args.filter) )
      #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
    #end
  #else
    #if( !$util.isNullOrEmpty($args.filter) )
      #set( $filter = $args.filter )
    #end
  #end
  #if( !$util.isNullOrEmpty($filter) )
    #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
    #if( !$util.isNullOrBlank($filterExpression.expression) )
      #if( $filterExpression.expressionValues.size() == 0 )
        $util.qr($filterExpression.remove(\\"expressionValues\\"))
      #end
      #set( $filter = $filterExpression )
    #end
  #end
{
      \\"version\\": \\"2018-05-29\\",
      \\"operation\\": \\"Query\\",
      \\"query\\":     $util.toJson($query),
      \\"scanIndexForward\\":     #if( $context.args.sortDirection )
      #if( $context.args.sortDirection == \\"ASC\\" )
true
      #else
false
      #end
    #else
true
    #end,
      \\"filter\\":     #if( $filter )
$util.toJson($filter)
    #else
null
    #end,
      \\"limit\\": $limit,
      \\"nextToken\\":     #if( $context.args.nextToken )
$util.toJson($context.args.nextToken)
    #else
null
    #end,
      \\"index\\": \\"gsi-Team.members\\"
  }
#end"
`;

exports[`has many query 3`] = `
"#if( $ctx.stash.deniedField )
  #return($util.toJson(null))
#end
#set( $partitionKeyValue = $util.defaultIfNull($ctx.stash.connectionAttibutes.get(\\"teamID\\"), $ctx.source.teamID) )
#if( $util.isNull($partitionKeyValue) )
  #return
#else
  #set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\"
} )
  $util.qr($GetRequest.put(\\"query\\", {
  \\"expression\\": \\"#partitionKey = :partitionValue\\",
  \\"expressionNames\\": {
      \\"#partitionKey\\": \\"id\\"
  },
  \\"expressionValues\\": {
      \\":partitionValue\\": $util.parseJson($util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($partitionKeyValue, \\"___xamznone____\\")))
  }
}))
  #if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
    $util.qr($GetRequest.put(\\"filter\\", $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.authFilter))))
  #end
  $util.toJson($GetRequest)
#end"
`;

exports[`has many references with multiple sort keys 1`] = `
"## [Start] Merge default values and inputs. **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## [End] Merge default values and inputs. **
## [Start] Validate create mutation for global secondary index 'gsi-Team.members'. **
#set( $hasSeenSomeKeyArg = false )
#set( $keyFieldNames = [\\"teamMantra\\", \\"teamOrganization\\"] )
#foreach( $keyFieldName in $keyFieldNames )
#if( $mergedValues.containsKey(\\"$keyFieldName\\") ) #set( $hasSeenSomeKeyArg = true ) #end
#end
#foreach( $keyFieldName in $keyFieldNames )
  #if( $hasSeenSomeKeyArg && !$mergedValues.containsKey(\\"$keyFieldName\\") )
    $util.error(\\"When creating any part of the composite sort key for global secondary index 'gsi-Team.members', you must provide all fields for the key. Missing key: '$keyFieldName'.\\")
  #end
#end
## [End] Validate create mutation for global secondary index 'gsi-Team.members'. **
#if( $util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) )
  $util.qr($ctx.stash.metadata.put(\\"dynamodbNameOverrideMap\\", { 'teamMantra#teamOrganization': \\"teamMantraTeamOrganization\\" }))
#else
  $util.qr($ctx.stash.metadata.dynamodbNameOverrideMap.put('teamMantra#teamOrganization', \\"teamMantraTeamOrganization\\"))
#end
#if( $hasSeenSomeKeyArg )
  $util.qr($ctx.args.input.put('teamMantra#teamOrganization',\\"\${mergedValues.teamMantra}#\${mergedValues.teamOrganization}\\"))
#end
{}"
`;

exports[`has many references with multiple sort keys 2`] = `
"#if( $ctx.stash.deniedField )
  #return($util.toJson(null))
#end
#set( $partitionKeyValue = $util.defaultIfNull($ctx.stash.connectionAttributes.get(\\"id\\"), $ctx.source.id) )
#if( $util.isNull($partitionKeyValue) )
  #set( $result = {
  \\"items\\":   []
} )
  #return($result)
#else
  #set( $limit = $util.defaultIfNull($context.args.limit, 100) )
  #set( $sortKeyValue0 = $util.defaultIfNull($ctx.stash.connectionAttibutes.get(\\"mantra\\"), $ctx.source.mantra) )
  #set( $sortKeyValue1 = $util.defaultIfNull($ctx.stash.connectionAttibutes.get(\\"organization\\"), $ctx.source.organization) )
  #set( $query = {
  \\"expression\\": \\"#partitionKey = :partitionKey AND #sortKey = :sortKey\\",
  \\"expressionNames\\": {
      \\"#partitionKey\\": \\"teamId\\",
      \\"#sortKey\\": \\"teamMantra#teamOrganization\\"
  },
  \\"expressionValues\\": {
      \\":partitionKey\\": $util.dynamodb.toDynamoDB($partitionKeyValue),
      \\":sortKey\\": $util.dynamodb.toDynamoDB(\\"\${sortKeyValue0}#\${sortKeyValue1}\\")
  }
} )
  #set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
  #if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
    #set( $filter = $ctx.stash.authFilter )
    #if( !$util.isNullOrEmpty($args.filter) )
      #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
    #end
  #else
    #if( !$util.isNullOrEmpty($args.filter) )
      #set( $filter = $args.filter )
    #end
  #end
  #if( !$util.isNullOrEmpty($filter) )
    #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
    #if( !$util.isNullOrBlank($filterExpression.expression) )
      #if( $filterExpression.expressionValues.size() == 0 )
        $util.qr($filterExpression.remove(\\"expressionValues\\"))
      #end
      #set( $filter = $filterExpression )
    #end
  #end
{
      \\"version\\": \\"2018-05-29\\",
      \\"operation\\": \\"Query\\",
      \\"query\\":     $util.toJson($query),
      \\"scanIndexForward\\":     #if( $context.args.sortDirection )
      #if( $context.args.sortDirection == \\"ASC\\" )
true
      #else
false
      #end
    #else
true
    #end,
      \\"filter\\":     #if( $filter )
$util.toJson($filter)
    #else
null
    #end,
      \\"limit\\": $limit,
      \\"nextToken\\":     #if( $context.args.nextToken )
$util.toJson($context.args.nextToken)
    #else
null
    #end,
      \\"index\\": \\"gsi-Team.members\\"
  }
#end"
`;

exports[`has many references with multiple sort keys 3`] = `
"#if( $ctx.stash.deniedField )
  #return($util.toJson(null))
#end
#set( $partitionKeyValue = $util.defaultIfNull($ctx.stash.connectionAttibutes.get(\\"teamId\\"), $ctx.source.teamId) )
#if( $util.isNull($partitionKeyValue) || $util.isNull($ctx.source.teamMantra) || $util.isNull($ctx.source.teamOrganization) )
  #return
#else
  #set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\"
} )
  $util.qr($GetRequest.put(\\"query\\", {
  \\"expression\\": \\"#partitionKey = :partitionValue AND #sortKeyName = :sortKeyName\\",
  \\"expressionNames\\": {
      \\"#partitionKey\\": \\"id\\",
      \\"#sortKeyName\\": \\"mantra#organization\\"
  },
  \\"expressionValues\\": {
      \\":partitionValue\\": $util.parseJson($util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($partitionKeyValue, \\"___xamznone____\\"))),
      \\":sortKeyName\\": $util.parseJson($util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank(\\"\${ctx.source.teamMantra}#\${ctx.source.teamOrganization}\\", \\"___xamznone____\\")))
  }
}))
  #if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
    $util.qr($GetRequest.put(\\"filter\\", $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.authFilter))))
  #end
  $util.toJson($GetRequest)
#end"
`;

exports[`has many references with partition key + sort key 1`] = `
"#if( $ctx.stash.deniedField )
  #return($util.toJson(null))
#end
#set( $partitionKeyValue = $util.defaultIfNull($ctx.stash.connectionAttributes.get(\\"id\\"), $ctx.source.id) )
#if( $util.isNull($partitionKeyValue) )
  #set( $result = {
  \\"items\\":   []
} )
  #return($result)
#else
  #set( $limit = $util.defaultIfNull($context.args.limit, 100) )
  #set( $sortKeyValue0 = $util.defaultIfNull($ctx.stash.connectionAttibutes.get(\\"mantra\\"), $ctx.source.mantra) )
  #set( $query = {
  \\"expression\\": \\"#partitionKey = :partitionKey AND #sortKey = :sortKey\\",
  \\"expressionNames\\": {
      \\"#partitionKey\\": \\"teamId\\",
      \\"#sortKey\\": \\"teamMantra\\"
  },
  \\"expressionValues\\": {
      \\":partitionKey\\": $util.dynamodb.toDynamoDB($partitionKeyValue),
      \\":sortKey\\": $util.dynamodb.toDynamoDB(\\"\${sortKeyValue0}\\")
  }
} )
  #set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
  #if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
    #set( $filter = $ctx.stash.authFilter )
    #if( !$util.isNullOrEmpty($args.filter) )
      #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
    #end
  #else
    #if( !$util.isNullOrEmpty($args.filter) )
      #set( $filter = $args.filter )
    #end
  #end
  #if( !$util.isNullOrEmpty($filter) )
    #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
    #if( !$util.isNullOrBlank($filterExpression.expression) )
      #if( $filterExpression.expressionValues.size() == 0 )
        $util.qr($filterExpression.remove(\\"expressionValues\\"))
      #end
      #set( $filter = $filterExpression )
    #end
  #end
{
      \\"version\\": \\"2018-05-29\\",
      \\"operation\\": \\"Query\\",
      \\"query\\":     $util.toJson($query),
      \\"scanIndexForward\\":     #if( $context.args.sortDirection )
      #if( $context.args.sortDirection == \\"ASC\\" )
true
      #else
false
      #end
    #else
true
    #end,
      \\"filter\\":     #if( $filter )
$util.toJson($filter)
    #else
null
    #end,
      \\"limit\\": $limit,
      \\"nextToken\\":     #if( $context.args.nextToken )
$util.toJson($context.args.nextToken)
    #else
null
    #end,
      \\"index\\": \\"gsi-Team.members\\"
  }
#end"
`;

exports[`has many references with partition key + sort key 2`] = `
"#if( $ctx.stash.deniedField )
  #return($util.toJson(null))
#end
#set( $partitionKeyValue = $util.defaultIfNull($ctx.stash.connectionAttibutes.get(\\"teamId\\"), $ctx.source.teamId) )
#if( $util.isNull($partitionKeyValue) || $util.isNull($ctx.source.teamMantra) )
  #return
#else
  #set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\"
} )
  $util.qr($GetRequest.put(\\"query\\", {
  \\"expression\\": \\"#partitionKey = :partitionValue AND #sortKeyName = :sortKeyName\\",
  \\"expressionNames\\": {
      \\"#partitionKey\\": \\"id\\",
      \\"#sortKeyName\\": \\"mantra\\"
  },
  \\"expressionValues\\": {
      \\":partitionValue\\": $util.parseJson($util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($partitionKeyValue, \\"___xamznone____\\"))),
      \\":sortKeyName\\": $util.parseJson($util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.source.teamMantra, \\"___xamznone____\\")))
  }
}))
  #if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
    $util.qr($GetRequest.put(\\"filter\\", $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.authFilter))))
  #end
  $util.toJson($GetRequest)
#end"
`;

exports[`hasMany / hasOne - belongsTo across data source type boundary 1`] = `
"#if( $ctx.stash.deniedField )
  #return($util.toJson(null))
#end
#set( $partitionKeyValue = $util.defaultIfNull($ctx.stash.connectionAttibutes.get(\\"id\\"), $ctx.source.id) )
#if( $util.isNull($partitionKeyValue) )
  #return
#else
  #set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\",
  \\"index\\": \\"gsi-Team.project\\"
} )
  $util.qr($GetRequest.put(\\"query\\", {
  \\"expression\\": \\"#partitionKey = :partitionValue\\",
  \\"expressionNames\\": {
      \\"#partitionKey\\": \\"teamId\\"
  },
  \\"expressionValues\\": {
      \\":partitionValue\\": $util.parseJson($util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($partitionKeyValue, \\"___xamznone____\\")))
  }
}))
  #if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
    $util.qr($GetRequest.put(\\"filter\\", $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.authFilter))))
  #end
  $util.toJson($GetRequest)
#end"
`;

exports[`hasMany / hasOne - belongsTo across data source type boundary 2`] = `
"#if( $ctx.stash.deniedField )
  #return($util.toJson(null))
#end
#set( $partitionKeyValue = $util.defaultIfNull($ctx.stash.connectionAttributes.get(\\"id\\"), $ctx.source.id) )
#if( $util.isNull($partitionKeyValue) )
  #set( $result = {
  \\"items\\":   []
} )
  #return($result)
#else
  #set( $limit = $util.defaultIfNull($context.args.limit, 100) )
  #set( $query = {
  \\"expression\\": \\"#partitionKey = :partitionKey\\",
  \\"expressionNames\\": {
      \\"#partitionKey\\": \\"teamId\\"
  },
  \\"expressionValues\\": {
      \\":partitionKey\\": $util.dynamodb.toDynamoDB($partitionKeyValue)
  }
} )
  #set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
  #if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
    #set( $filter = $ctx.stash.authFilter )
    #if( !$util.isNullOrEmpty($args.filter) )
      #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
    #end
  #else
    #if( !$util.isNullOrEmpty($args.filter) )
      #set( $filter = $args.filter )
    #end
  #end
  #if( !$util.isNullOrEmpty($filter) )
    #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
    #if( !$util.isNullOrBlank($filterExpression.expression) )
      #if( $filterExpression.expressionValues.size() == 0 )
        $util.qr($filterExpression.remove(\\"expressionValues\\"))
      #end
      #set( $filter = $filterExpression )
    #end
  #end
{
      \\"version\\": \\"2018-05-29\\",
      \\"operation\\": \\"Query\\",
      \\"query\\":     $util.toJson($query),
      \\"scanIndexForward\\":     #if( $context.args.sortDirection )
      #if( $context.args.sortDirection == \\"ASC\\" )
true
      #else
false
      #end
    #else
true
    #end,
      \\"filter\\":     #if( $filter )
$util.toJson($filter)
    #else
null
    #end,
      \\"limit\\": $limit,
      \\"nextToken\\":     #if( $context.args.nextToken )
$util.toJson($context.args.nextToken)
    #else
null
    #end,
      \\"index\\": \\"gsi-Team.members\\"
  }
#end"
`;

exports[`hasMany / hasOne - belongsTo across data source type boundary 3`] = `
"## [Start] Invoke RDS Lambda data source. **
#if( $ctx.stash.deniedField )
  #return($util.toJson(null))
#end
#set( $lambdaInput = {} )
#set( $lambdaInput.args = {} )
#set( $lambdaInput.table = \\"Team\\" )
#set( $lambdaInput.operation = \\"GET\\" )
#set( $lambdaInput.operationName = \\"BelongsToConnectionQuery\\" )
#set( $lambdaInput.args.metadata = {} )
#set( $lambdaInput.args.metadata.keys = [\\"id\\"] )
#set( $lambdaInput.args.metadata.fieldMap = {} )
$util.qr($lambdaInput.args.metadata.fieldMap.putAll($util.defaultIfNull($context.stash.fieldMap, {})))
$util.qr($lambdaInput.args.putAll($util.defaultIfNull($context.arguments, {})))
#if( !$lambdaInput.args.input )
  #set( $lambdaInput.args.input = {} )
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $lambdaInput.args.metadata.authFilter = $ctx.stash.authFilter )
#end
$util.qr($lambdaInput.args.input.put(\\"id\\", $util.defaultIfNull($ctx.source.teamId, \\"\\")))
{
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Invoke\\",
  \\"payload\\":   $util.toJson($lambdaInput)
}
## [End] Invoke RDS Lambda data source. **"
`;

exports[`hasMany / hasOne - belongsTo across data source type boundary 4`] = `
"## [Start] Invoke RDS Lambda data source. **
#if( $ctx.stash.deniedField )
  #return($util.toJson(null))
#end
#set( $lambdaInput = {} )
#set( $lambdaInput.args = {} )
#set( $lambdaInput.table = \\"Team\\" )
#set( $lambdaInput.operation = \\"GET\\" )
#set( $lambdaInput.operationName = \\"BelongsToConnectionQuery\\" )
#set( $lambdaInput.args.metadata = {} )
#set( $lambdaInput.args.metadata.keys = [\\"id\\"] )
#set( $lambdaInput.args.metadata.fieldMap = {} )
$util.qr($lambdaInput.args.metadata.fieldMap.putAll($util.defaultIfNull($context.stash.fieldMap, {})))
$util.qr($lambdaInput.args.putAll($util.defaultIfNull($context.arguments, {})))
#if( !$lambdaInput.args.input )
  #set( $lambdaInput.args.input = {} )
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $lambdaInput.args.metadata.authFilter = $ctx.stash.authFilter )
#end
$util.qr($lambdaInput.args.input.put(\\"id\\", $util.defaultIfNull($ctx.source.teamId, \\"\\")))
{
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Invoke\\",
  \\"payload\\":   $util.toJson($lambdaInput)
}
## [End] Invoke RDS Lambda data source. **"
`;

exports[`many to many query 1`] = `
"type Post {
  id: ID!
  title: String!
  editors(filter: ModelPostEditorFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelPostEditorConnection
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
}

type PostEditor {
  id: ID!
  postID: ID!
  editorID: ID!
  post: Post!
  editor: User!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
}

type User {
  id: ID!
  username: String!
  posts(filter: ModelPostEditorFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelPostEditorConnection
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelSubscriptionStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  in: [String]
  notIn: [String]
}

input ModelSubscriptionIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  in: [Int]
  notIn: [Int]
}

input ModelSubscriptionFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  in: [Float]
  notIn: [Float]
}

input ModelSubscriptionBooleanInput {
  ne: Boolean
  eq: Boolean
}

input ModelSubscriptionIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  in: [ID]
  notIn: [ID]
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelPostConnection {
  items: [Post]!
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelPostFilterInput {
  id: ModelIDInput
  title: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelPostFilterInput]
  or: [ModelPostFilterInput]
  not: ModelPostFilterInput
  _deleted: ModelBooleanInput
}

type Query {
  getPost(id: ID!): Post
  listPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String): ModelPostConnection
  syncPosts(filter: ModelPostFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelPostConnection
  getUser(id: ID!): User
  listUsers(filter: ModelUserFilterInput, limit: Int, nextToken: String): ModelUserConnection
  syncUsers(filter: ModelUserFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelUserConnection
}

input ModelPostConditionInput {
  title: ModelStringInput
  and: [ModelPostConditionInput]
  or: [ModelPostConditionInput]
  not: ModelPostConditionInput
  _deleted: ModelBooleanInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
}

input CreatePostInput {
  id: ID
  title: String!
  _version: Int
}

input UpdatePostInput {
  id: ID!
  title: String
  _version: Int
}

input DeletePostInput {
  id: ID!
  _version: Int
}

type Mutation {
  createPost(input: CreatePostInput!, condition: ModelPostConditionInput): Post
  updatePost(input: UpdatePostInput!, condition: ModelPostConditionInput): Post
  deletePost(input: DeletePostInput!, condition: ModelPostConditionInput): Post
  createPostEditor(input: CreatePostEditorInput!, condition: ModelPostEditorConditionInput): PostEditor
  updatePostEditor(input: UpdatePostEditorInput!, condition: ModelPostEditorConditionInput): PostEditor
  deletePostEditor(input: DeletePostEditorInput!, condition: ModelPostEditorConditionInput): PostEditor
  createUser(input: CreateUserInput!, condition: ModelUserConditionInput): User
  updateUser(input: UpdateUserInput!, condition: ModelUserConditionInput): User
  deleteUser(input: DeleteUserInput!, condition: ModelUserConditionInput): User
}

input ModelSubscriptionPostFilterInput {
  id: ModelSubscriptionIDInput
  title: ModelSubscriptionStringInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionPostFilterInput]
  or: [ModelSubscriptionPostFilterInput]
  _deleted: ModelBooleanInput
}

type Subscription {
  onCreatePost(filter: ModelSubscriptionPostFilterInput): Post @aws_subscribe(mutations: [\\"createPost\\"])
  onUpdatePost(filter: ModelSubscriptionPostFilterInput): Post @aws_subscribe(mutations: [\\"updatePost\\"])
  onDeletePost(filter: ModelSubscriptionPostFilterInput): Post @aws_subscribe(mutations: [\\"deletePost\\"])
  onCreatePostEditor(filter: ModelSubscriptionPostEditorFilterInput): PostEditor @aws_subscribe(mutations: [\\"createPostEditor\\"])
  onUpdatePostEditor(filter: ModelSubscriptionPostEditorFilterInput): PostEditor @aws_subscribe(mutations: [\\"updatePostEditor\\"])
  onDeletePostEditor(filter: ModelSubscriptionPostEditorFilterInput): PostEditor @aws_subscribe(mutations: [\\"deletePostEditor\\"])
  onCreateUser(filter: ModelSubscriptionUserFilterInput): User @aws_subscribe(mutations: [\\"createUser\\"])
  onUpdateUser(filter: ModelSubscriptionUserFilterInput): User @aws_subscribe(mutations: [\\"updateUser\\"])
  onDeleteUser(filter: ModelSubscriptionUserFilterInput): User @aws_subscribe(mutations: [\\"deleteUser\\"])
}

input ModelPostEditorConditionInput {
  postID: ModelIDInput
  editorID: ModelIDInput
  and: [ModelPostEditorConditionInput]
  or: [ModelPostEditorConditionInput]
  not: ModelPostEditorConditionInput
  _deleted: ModelBooleanInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
}

input CreatePostEditorInput {
  id: ID
  postID: ID!
  editorID: ID!
  _version: Int
}

input UpdatePostEditorInput {
  id: ID!
  postID: ID
  editorID: ID
  _version: Int
}

input DeletePostEditorInput {
  id: ID!
  _version: Int
}

input ModelSubscriptionPostEditorFilterInput {
  id: ModelSubscriptionIDInput
  postID: ModelSubscriptionIDInput
  editorID: ModelSubscriptionIDInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionPostEditorFilterInput]
  or: [ModelSubscriptionPostEditorFilterInput]
  _deleted: ModelBooleanInput
}

type ModelUserConnection {
  items: [User]!
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelUserFilterInput {
  id: ModelIDInput
  username: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelUserFilterInput]
  or: [ModelUserFilterInput]
  not: ModelUserFilterInput
  _deleted: ModelBooleanInput
}

input ModelUserConditionInput {
  username: ModelStringInput
  and: [ModelUserConditionInput]
  or: [ModelUserConditionInput]
  not: ModelUserConditionInput
  _deleted: ModelBooleanInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
}

input CreateUserInput {
  id: ID
  username: String!
  _version: Int
}

input UpdateUserInput {
  id: ID!
  username: String
  _version: Int
}

input DeleteUserInput {
  id: ID!
  _version: Int
}

input ModelSubscriptionUserFilterInput {
  id: ModelSubscriptionIDInput
  username: ModelSubscriptionStringInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionUserFilterInput]
  or: [ModelSubscriptionUserFilterInput]
  _deleted: ModelBooleanInput
}

type ModelPostEditorConnection {
  items: [PostEditor]!
  nextToken: String
}

input ModelPostEditorFilterInput {
  id: ModelIDInput
  postID: ModelIDInput
  editorID: ModelIDInput
  and: [ModelPostEditorFilterInput]
  or: [ModelPostEditorFilterInput]
  not: ModelPostEditorFilterInput
  _deleted: ModelBooleanInput
}
"
`;
