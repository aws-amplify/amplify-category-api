import { CloudFormationCustomResourceEvent, CloudFormationCustomResourceResponse } from 'aws-lambda';
import {
  AppSyncClient,
  CreateFunctionCommand,
  CreateResolverCommand,
  DeleteFunctionCommand,
  DeleteFunctionCommandInput,
  DeleteFunctionCommandOutput,
  DeleteResolverCommand,
  DeleteResolverCommandInput,
  DeleteResolverCommandOutput,
  ListFunctionsCommand,
  ListFunctionsCommandInput,
  ListResolversCommand,
  ListResolversCommandInput,
  ListTypesCommand,
  ListTypesCommandInput,
  Resolver,
  UpdateFunctionCommand,
  UpdateResolverCommand,
} from '@aws-sdk/client-appsync';
import { S3Client, GetObjectCommand, NoSuchKey } from '@aws-sdk/client-s3';

/**
 * An AppSync Pipeline resolver attached to an API. Note that since this is a pipeline resolver it does not require a Data Source.
 */
interface AppSyncPipelineResolver {
  type: 'PipelineResolver';
  fieldName?: string;
  pipelineConfig: {
    functions: string[];
  };
  requestMappingTemplate: string;
  responseMappingTemplate: string;
  typeName: string;
}

/**
 * An AppSync VTL function. The function's `functionId` will be included in a Pipeline Resolver's `pipelineConfig` entry. Note that the
 * `functionId` specified in a Computed resource will not be the same as the actual `functionId` after it's created in AppSync. The handler
 * will account for that by mapping the function name to the ID generated by AppSync.
 */
interface AppSyncVtlFunction {
  type: 'AppSyncVtlFunction';

  /** This isn't likely to change, since it would change the name of the associated function itself */
  dataSource: string;

  /**
   * This will differ between computed and remote resources. The computed value is derived locally while the remote value is assigned at
   * creation time. Do not use it for equality comparisons.
   */
  functionId: string;

  /** This isn't likely to change, since it would change the name of the associated function itself */
  name: string;

  /** Present if the function is a VTL runtime */
  requestMappingTemplate?: string;

  /** Present if the function is a VTL runtime */
  responseMappingTemplate?: string;
}

/**
 * All supported AppSyncResources present in the computed resource map
 */
type AppSyncResource = AppSyncPipelineResolver | AppSyncVtlFunction;

/**
 * A map whose key is a function name and whose value is the ID generated by AppSync at the time the function was created
 */
type FunctionIdValueMap = Record<string, string>;

/**
 * A map of identifer to resource, where the key depends on the resource type:
 *   - For Functions: the function name
 *   - For Resolvers: a name composed by `{typeName}.{fieldName}`
 */
type ResourceMap = Record<string, AppSyncResource>;

/**
 * The shape of the incoming CloudFormation event's `ResourceProperties` attribute. Keep this in sync with the custom resource provisioning
 * code.
 */
interface ResourceProperties {
  ServiceToken: string;
  apiId: string;
  computedResourcesAssetBucket: string;
  computedResourcesAssetKey: string;
}

/**
 * A cached, regionalized AppSync client to perform the necessary SDK operations for managing AppSync Functions and Resolvers.
 */
const appSyncClient = new AppSyncClient({});

/**
 * The handler for this custom resource's CloudFormationCustomResourceEvent
 */
export const handler = async (event: CloudFormationCustomResourceEvent): Promise<CloudFormationCustomResourceResponse> => {
  console.log('event', JSON.stringify(event));
  const resourceProperties = event.ResourceProperties as ResourceProperties;

  console.log(`Processing ${event.RequestType}`);
  switch (event.RequestType) {
    case 'Create':
      await processCreateEvent(event);
      break;
    case 'Update':
      await processUpdateEvent(event);
      break;
    case 'Delete':
      await processDeleteEvent(event);
      break;
  }

  // 'Delete' events may be issued after an unsuccessful create, so we shouldn't rely on the overridden physical resource ID being valid yet
  const physicalResourceId = event.RequestType === 'Delete' ? event.PhysicalResourceId : `resource-manager-${resourceProperties.apiId}`;

  const response: CloudFormationCustomResourceResponse = {
    PhysicalResourceId: physicalResourceId,
    Status: 'SUCCESS',
    Data: { ...resourceProperties },
    LogicalResourceId: event.LogicalResourceId,
    RequestId: event.RequestId,
    StackId: event.StackId,
  };

  return response;
};

// #region event processing

/**
 * Create Functions, then Resolvers, for each ComputedResource
 */
const processCreateEvent = async (event: CloudFormationCustomResourceEvent): Promise<void> => {
  const resourceProperties = event.ResourceProperties as ResourceProperties;
  const computedResources = await fetchComputedResources(resourceProperties);
  const functionIdValueMap = await createAllFunctions(resourceProperties, computedResources);
  await createAllResolvers(resourceProperties, computedResources, functionIdValueMap);
};

/**
 * Delete Resolvers, then Functions for each RemoteResource
 */
const processDeleteEvent = async (event: CloudFormationCustomResourceEvent): Promise<void> => {
  const resourceProperties = event.ResourceProperties as ResourceProperties;
  await deleteAllResolvers(resourceProperties);
  await deleteAllFunctions(resourceProperties);
};

/**
 * Compare the incoming request to the current state of the API and resolve the differences using the strategy below. At a high level, we
 * need to reconcile resolvers and functions such that functions are always present when referenced by a resolver.
 *
 * ### Diff algorithm
 *
 * - Let "Computed" designate a resource computed by Amplify and uploaded into the computed-resources.json file
 *
 * - Let "Remote" designate a resource currently present in AppSync
 *
 * - Let "FunctionIdValueMap" be a map whose key is a function name and whose value is the ID generated by AppSync at the time the function
 *   was created
 *
 * - Let a ResourceMap be a Record<string, Resource>, where the key depends on the resource type:
 *     - For Functions: the function name
 *     - For Resolvers: a name composed by `{typeName}.{fieldName}`
 *
 * - Retrieve all Computed resources into ComputedResourceMap
 *
 * - Retrieve all Remote resources into RemoteResourceMap
 *
 * - Populate the FunctionIdValueMap with an entry for each Function in RemoteResourceMap
 *
 * - For each Computed Function that is NOT PRESENT in the RemoteResourceMap:
 *     - Create it in AppSync
 *     - Add an entry to the FunctionIdValueMap with the newly-created Function ID
 *
 * - For each Computed Function that is NOT EQUAL to the corresponding Remote resource:
 *     - Update it in AppSync, referencing the Function ID from FunctionIdValueMap
 *
 * - For each Computed Resolver that is NOT PRESENT in the RemoteResourceMap:
 *     - Create it in AppSync, referencing Function IDs from FunctionIdValueMap
 *
 * - For each Computed Resolver that is NOT EQUAL to the corresponding Remote resource:
 *     - Update it in AppSync, referencing Function IDs from FunctionIdValueMap
 *
 * - For each Remote Resolver that is NOT PRESENT in the ComputedResourceMap:
 *     - Delete it from AppSync
 *
 * - For each Remote Function that is NOT PRESENT in the ComputedResourceMap:
 *     - Delete it from AppSync
 */
const processUpdateEvent = async (event: CloudFormationCustomResourceEvent): Promise<void> => {
  const resourceProperties = event.ResourceProperties as ResourceProperties;

  // Retrieve all Computed resources into ComputedResourceMap
  const computedResources = await fetchComputedResources(resourceProperties);

  // Retrieve all Remote resources into RemoteResourceMap
  const remoteResources = await fetchAllRemoteResources(resourceProperties);

  // Populate the FunctionIdValueMap with an entry for each Function in RemoteResourceMap
  const functionIdValueMap: FunctionIdValueMap = {};
  Object.values(remoteResources)
    .filter(isAppSyncVtlFunction)
    .forEach((func) => (functionIdValueMap[func.name] = func.functionId));

  // - For each Computed Function that is NOT PRESENT in the RemoteResourceMap:
  //     - Create it in AppSync
  //     - Add an entry to the FunctionIdValueMap with the newly-created Function ID
  const newlyCreatedFunctionIdMap = await createComputedFunctions(resourceProperties, computedResources, remoteResources);
  Object.assign(functionIdValueMap, newlyCreatedFunctionIdMap);

  // - For each Computed Function that is NOT EQUAL to the corresponding Remote resource:
  //     - Update it in AppSync, referencing the Function ID from FunctionIdValueMap
  await updateComputedFunctions(resourceProperties, computedResources, remoteResources, functionIdValueMap);

  // - For each Computed Resolver that is NOT PRESENT in the RemoteResourceMap:
  //     - Create it in AppSync, referencing Function IDs from FunctionIdValueMap
  await createComputedResolvers(resourceProperties, computedResources, remoteResources, functionIdValueMap);

  // - For each Computed Resolver that is NOT EQUAL to the corresponding Remote resource:
  //     - Update it in AppSync, referencing Function IDs from FunctionIdValueMap
  await updateComputedResolvers(resourceProperties, computedResources, remoteResources, functionIdValueMap);

  // - For each Remote Resolver that is NOT PRESENT in the ComputedResourceMap:
  //     - Delete it from AppSync
  await deleteRemoteResolvers(resourceProperties, computedResources, remoteResources);

  // - For each Remote Function that is NOT PRESENT in the ComputedResourceMap:
  //     - Delete it from AppSync
  await deleteRemoteFunctions(resourceProperties, computedResources, remoteResources);
};

/**
 * For each Computed Function that is NOT PRESENT in the RemoteResourceMap, create it in AppSync. Returns a FunctionIdValueMap with the
 * newly-created Function IDs
 */
const createComputedFunctions = async (
  resourceProperties: ResourceProperties,
  computedResources: ResourceMap,
  remoteResources: ResourceMap,
): Promise<FunctionIdValueMap> => {
  const newlyCreatedFunctionIdMap: FunctionIdValueMap = {};
  console.log('createComputedFunctions start');
  const allFunctions = Object.values(computedResources).filter(isAppSyncVtlFunction);
  console.log(`${allFunctions.length} computed functions`);
  const functionsToCreate = allFunctions.filter((computedResource) => !remoteResources[computedResource.name]);
  console.log(`Creating ${functionsToCreate.length} functions`);

  for (const computedFunction of functionsToCreate) {
    const newIdMap = await createFunction(resourceProperties, computedFunction);
    Object.assign(newlyCreatedFunctionIdMap, newIdMap);
  }
  console.log('createComputedFunctions complete');
  return newlyCreatedFunctionIdMap;
};

/**
 * For each Computed Function that is NOT EQUAL to the corresponding Remote resource, Update it in AppSync, referencing the Function ID from
 * FunctionIdValueMap
 */
const updateComputedFunctions = async (
  resourceProperties: ResourceProperties,
  computedResources: ResourceMap,
  remoteResources: ResourceMap,
  functionIdValueMap: FunctionIdValueMap,
): Promise<void> => {
  console.log('updateComputedFunctions start');
  const allFunctions = Object.values(computedResources).filter(isAppSyncVtlFunction);
  console.log(`${allFunctions.length} computed functions`);

  const functionsToUpdate = allFunctions.filter(isAppSyncVtlFunction).filter((computedResource) => {
    const remoteResource = remoteResources[computedResource.name];
    if (!remoteResource) {
      return false;
    }
    if (!isAppSyncVtlFunction(remoteResource)) {
      return false;
    }
    return !isComputedFunctionEqualToRemoteFunction(computedResource, remoteResource, functionIdValueMap);
  });
  console.log(`Updating ${functionsToUpdate.length} functions`);

  for (const computedFunction of functionsToUpdate) {
    await updateFunction(resourceProperties, computedFunction, functionIdValueMap);
  }
  console.log('updateComputedFunctions complete');
};

/**
 * For each Computed Resolver that is NOT PRESENT in the RemoteResourceMap, create it in AppSync, referencing the Function ID from
 * FunctionIdValueMap
 */
const createComputedResolvers = async (
  resourceProperties: ResourceProperties,
  computedResources: ResourceMap,
  remoteResources: ResourceMap,
  functionIdValueMap: FunctionIdValueMap,
): Promise<void> => {
  console.log('createComputedResolvers start');

  const allResolvers = Object.values(computedResources).filter(isAppSyncPipelineResolver);
  console.log(`${allResolvers.length} computed resolvers`);
  const resolversToCreate = allResolvers.filter((computedResource) => !remoteResources[getResolverKey(computedResource)]);
  console.log(`Creating ${resolversToCreate.length} resolvers`);

  for (const computedResolver of resolversToCreate) {
    await createResolver(resourceProperties, computedResolver, functionIdValueMap);
  }

  console.log('createComputedResolvers complete');
};

/**
 * For each Computed Resolver that is NOT EQUAL to the corresponding Remote resource, update it in AppSync, referencing the Function ID from
 * FunctionIdValueMap
 */
const updateComputedResolvers = async (
  resourceProperties: ResourceProperties,
  computedResources: ResourceMap,
  remoteResources: ResourceMap,
  functionIdValueMap: FunctionIdValueMap,
): Promise<void> => {
  console.log('updateComputedResolvers start');

  const allResolvers = Object.values(computedResources).filter(isAppSyncPipelineResolver);
  console.log(`${allResolvers.length} computed resolvers`);

  const resolversToUpdate = allResolvers.filter(isAppSyncPipelineResolver).filter((computedResource) => {
    const resolverKey = getResolverKey(computedResource);
    const remoteResource = remoteResources[resolverKey];
    if (!remoteResource) {
      return false;
    }
    if (!isAppSyncPipelineResolver(remoteResource)) {
      return false;
    }
    return !isComputedResolverEqualToRemoteResolver(computedResource, remoteResource, functionIdValueMap);
  });

  console.log(`Updating ${resolversToUpdate.length} resolvers`);

  for (const computedResolver of resolversToUpdate) {
    await updateResolver(resourceProperties, computedResolver, functionIdValueMap);
  }

  // Update the computed resolver's pipeline config with AppSync function IDs before comparing
  console.log('updateComputedResolvers complete');
};

/**
 * For each Remote Resolver that is NOT PRESENT in the ComputedResourceMap, delete it from AppSync
 */
const deleteRemoteResolvers = async (
  resourceProperties: ResourceProperties,
  computedResources: ResourceMap,
  remoteResources: ResourceMap,
): Promise<void> => {
  console.log('deleteRemoteResolvers start');

  const allResolvers = Object.values(remoteResources).filter(isAppSyncPipelineResolver);
  console.log(`${allResolvers.length} remote resolvers`);

  const resolversToDelete = allResolvers.filter((remoteResource) => !computedResources[getResolverKey(remoteResource)]);
  console.log(`Deleting ${resolversToDelete.length} resolvers`);

  for (const remoteResolver of resolversToDelete) {
    await deleteResolver(resourceProperties, remoteResolver);
  }

  console.log('deleteRemoteResolvers complete');
};

/**
 * For each Remote Function that is NOT PRESENT in the ComputedResourceMap delete it from AppSync
 */
const deleteRemoteFunctions = async (
  resourceProperties: ResourceProperties,
  computedResources: ResourceMap,
  remoteResources: ResourceMap,
): Promise<void> => {
  console.log('deleteRemoteFunctions start');

  const allFunctions = Object.values(remoteResources).filter(isAppSyncVtlFunction);
  console.log(`${allFunctions.length} remote functions`);

  const functionsToDelete = allFunctions.filter((remoteResource) => !computedResources[remoteResource.name]);
  console.log(`Deleting ${functionsToDelete.length} functions`);

  for (const remoteFunction of functionsToDelete) {
    await deleteFunction(resourceProperties, remoteFunction);
  }

  console.log('deleteRemoteFunctions complete');
};

// #endregion

// #region remote resource CRUD utils

const getResolverKey = (resolver: AppSyncPipelineResolver | Resolver): string => `${resolver.typeName}.${resolver.fieldName}`;

const createAllFunctions = async (resourceProperties: ResourceProperties, computedResources: ResourceMap): Promise<FunctionIdValueMap> => {
  console.log('createAllFunctions');

  const functionIdValueMap: FunctionIdValueMap = {};

  for (const func of Object.values(computedResources).filter(isAppSyncVtlFunction)) {
    const newlyCreatedFunctionIdMap = await createFunction(resourceProperties, func);
    Object.assign(functionIdValueMap, newlyCreatedFunctionIdMap);
  }
  console.log(`createAllFunctions functionIdValueMap: ${functionIdValueMap}`);
  return functionIdValueMap;
};

/**
 * Create a single AppSync Function, and return a map of the function name (as specified in the incoming function spec) to the newly-created
 * ID.
 */
const createFunction = async (resourceProperties: ResourceProperties, spec: AppSyncVtlFunction): Promise<FunctionIdValueMap> => {
  console.log(`Creating function ${spec.name}`);

  const { apiId } = resourceProperties;

  const functionIdValueMap: FunctionIdValueMap = {};
  const createFunctionCommand = new CreateFunctionCommand({
    apiId,
    dataSourceName: spec.dataSource,
    name: spec.name,
    requestMappingTemplate: spec.requestMappingTemplate,
    responseMappingTemplate: spec.responseMappingTemplate,
    functionVersion: '2018-05-29',
  });
  const appSyncFunction = await appSyncClient.send(createFunctionCommand);
  functionIdValueMap[spec.functionId] = appSyncFunction.functionConfiguration!.functionId!;

  console.log(`Created function ${spec.name}. AppSync functionId: ${appSyncFunction.functionConfiguration!.functionId!}`);
  return functionIdValueMap;
};

const createAllResolvers = async (
  resourceProperties: ResourceProperties,
  computedResources: ResourceMap,
  functionIdValueMap: FunctionIdValueMap,
): Promise<void> => {
  console.log('createAllResolvers');
  for (const resolver of Object.values(computedResources).filter(isAppSyncPipelineResolver)) {
    await createResolver(resourceProperties, resolver, functionIdValueMap);
  }
  console.log('createAllResolvers done');
};

const createResolver = async (
  resourceProperties: ResourceProperties,
  spec: AppSyncPipelineResolver,
  functionIdValueMap: FunctionIdValueMap,
): Promise<void> => {
  console.log(`Creating resolver ${getResolverKey(spec)}`);

  const { apiId } = resourceProperties;

  const createResolverCommand = new CreateResolverCommand({
    apiId,
    fieldName: spec.fieldName,
    typeName: spec.typeName,
    kind: 'PIPELINE',
    requestMappingTemplate: spec.requestMappingTemplate,
    responseMappingTemplate: spec.responseMappingTemplate,
    pipelineConfig: {
      functions: spec.pipelineConfig.functions?.map((x: string) => functionIdValueMap[x]),
    },
  });
  await appSyncClient.send(createResolverCommand);
  console.log(`Created resolver ${getResolverKey(spec)}`);
};

// TODO: Add stabilization logic to ensure all resources are deleted before proceeding to next step.
const deleteAllFunctions = async (resourceProperties: ResourceProperties): Promise<void> => {
  console.log('deleteAllFunctions');

  const allFunctions = fetchAllRemoteFunctions(resourceProperties);

  const allPromises = [];
  for (const appSyncFunction of Object.values(allFunctions)) {
    allPromises.push(deleteFunction(resourceProperties, appSyncFunction));
  }

  await Promise.all(allPromises);
  console.log('Done deleting all functions');
};

// TODO: Add stabilization logic to ensure all resources are deleted before proceeding to next step.
const deleteAllResolvers = async (resourceProperties: ResourceProperties): Promise<void> => {
  console.log('deleteAllResolvers');

  const allResolvers = fetchAllRemoteResolvers(resourceProperties);

  const allPromises = [];
  for (const resolver of Object.values(allResolvers)) {
    allPromises.push(deleteResolver(resourceProperties, resolver));
  }

  await Promise.all(allPromises);
  console.log('Done deleting all resolvers');
};

const deleteFunction = async (
  resourceProperties: ResourceProperties,
  appSyncFunction: AppSyncVtlFunction,
): Promise<DeleteFunctionCommandOutput> => {
  const { functionId, name } = appSyncFunction;
  console.log(`Deleting function ${name}`);
  const { apiId } = resourceProperties;

  const input: DeleteFunctionCommandInput = {
    apiId,
    functionId,
  };
  const command = new DeleteFunctionCommand(input);
  return appSyncClient.send(command);
};

const deleteResolver = async (
  resourceProperties: ResourceProperties,
  resolver: AppSyncPipelineResolver,
): Promise<DeleteResolverCommandOutput> => {
  console.log(`Deleting resolver ${getResolverKey(resolver)}`);
  const { apiId } = resourceProperties;

  const input: DeleteResolverCommandInput = {
    apiId,
    typeName: resolver.typeName,
    fieldName: resolver.fieldName,
  };
  const command = new DeleteResolverCommand(input);
  return appSyncClient.send(command);
};

/**
 * Update a single AppSync Function. The value of `spec.functionId` must be the name provided by the computed resource, not the AppSync
 * `functionId`. The actual AppSync `functionId` will be resolved using `functionIdValueMap`
 */
const updateFunction = async (
  resourceProperties: ResourceProperties,
  spec: AppSyncVtlFunction,
  functionIdValueMap: FunctionIdValueMap,
): Promise<void> => {
  console.log(`Updating function ${spec.name}`);

  const { apiId } = resourceProperties;

  const updateFunctionCommand = new UpdateFunctionCommand({
    apiId,
    dataSourceName: spec.dataSource,
    functionId: functionIdValueMap[spec.name],
    name: spec.name,
    requestMappingTemplate: spec.requestMappingTemplate,
    responseMappingTemplate: spec.responseMappingTemplate,
    functionVersion: '2018-05-29',
  });
  await appSyncClient.send(updateFunctionCommand);
  console.log(`Updated function ${spec.name}`);
};

/**
 * Update a single AppSync Resolver. The values of the functions referenced in `spec.pipelineConfig.functions` must be the names provided by
 * the computed resource, not the AppSync `functionId`s. The actual AppSync `functionId`s will be resolved using `functionIdValueMap`.
 */
const updateResolver = async (
  resourceProperties: ResourceProperties,
  spec: AppSyncPipelineResolver,
  functionIdValueMap: FunctionIdValueMap,
): Promise<void> => {
  console.log(`Updating resolver ${getResolverKey(spec)}`);

  const { apiId } = resourceProperties;

  const updateResolverCommand = new UpdateResolverCommand({
    apiId,
    fieldName: spec.fieldName,
    typeName: spec.typeName,
    kind: 'PIPELINE',
    requestMappingTemplate: spec.requestMappingTemplate,
    responseMappingTemplate: spec.responseMappingTemplate,
    pipelineConfig: {
      functions: spec.pipelineConfig.functions?.map((x: string) => functionIdValueMap[x]),
    },
  });
  await appSyncClient.send(updateResolverCommand);
  console.log(`Updated resolver ${getResolverKey(spec)}`);
};

// #endregion

// #region remote resource fetch utils

const fetchAllRemoteResources = async (resourceProperties: ResourceProperties): Promise<ResourceMap> => {
  console.log('fetchAllRemoteResources start');
  const remoteFunctions = await fetchAllRemoteFunctions(resourceProperties);
  const remoteResolvers = await fetchAllRemoteResolvers(resourceProperties);
  const allRemoteResources: ResourceMap = {
    ...remoteFunctions,
    ...remoteResolvers,
  };
  console.log('fetchAllRemoteResources:', JSON.stringify(allRemoteResources));
  return allRemoteResources;
};

/**
 * Fetches all functions from the AppSync API, and returns a map keyed by function name. NB: Do not use function ID as the key for the
 * returned map, as it is not present in the computed resources.
 */
const fetchAllRemoteFunctions = async (resourceProperties: ResourceProperties): Promise<ResourceMap> => {
  console.log('fetchAllRemoteFunctions start');
  const { apiId } = resourceProperties;
  let nextToken: string | undefined = undefined;
  const allFunctions: Record<string, AppSyncVtlFunction> = {};

  do {
    const input: ListFunctionsCommandInput = {
      apiId,
      nextToken,
    };
    const command = new ListFunctionsCommand(input);

    const result = await appSyncClient.send(command);
    nextToken = result.nextToken;

    const functions = result.functions;
    if (!functions || functions.length === 0) {
      continue;
    }

    functions.forEach((fn) => {
      allFunctions[fn.name!] = {
        type: 'AppSyncVtlFunction',
        name: fn.name!,
        functionId: fn.functionId!,
        dataSource: fn.dataSourceName!,
        requestMappingTemplate: fn.requestMappingTemplate,
        responseMappingTemplate: fn.responseMappingTemplate,
      };
    });
  } while (nextToken);

  console.log('fetchAllRemoteFunctions:', JSON.stringify(allFunctions));
  return allFunctions;
};

const fetchAllRemoteResolvers = async (resourceProperties: ResourceProperties): Promise<ResourceMap> => {
  console.log('fetchAllRemoteResolvers');
  const typeNames = await fetchTypeNames(resourceProperties);
  const allResolvers: Record<string, AppSyncPipelineResolver> = {};

  for (const typeName of typeNames) {
    const resolvers = await fetchResolversForType(typeName, resourceProperties);
    Object.assign(allResolvers, resolvers);
  }

  console.log('fetchAllRemoteResolvers:', JSON.stringify(Object.keys(allResolvers)));
  return allResolvers;
};

const fetchResolversForType = async (
  typeName: string,
  resourceProperties: ResourceProperties,
): Promise<Record<string, AppSyncPipelineResolver>> => {
  console.log(`fetchResolversForType ${typeName}`);
  const { apiId } = resourceProperties;

  let nextToken: string | undefined = undefined;
  const resolversForType: Record<string, AppSyncPipelineResolver> = {};
  do {
    const input: ListResolversCommandInput = {
      apiId,
      typeName: typeName,
      nextToken,
    };
    const command = new ListResolversCommand(input);
    const result = await appSyncClient.send(command);
    nextToken = result.nextToken;
    const localResolvers = result.resolvers ?? [];
    if (localResolvers.length === 0) {
      continue;
    }

    localResolvers.forEach((resolver) => {
      resolversForType[getResolverKey(resolver)] = {
        fieldName: resolver.fieldName,
        pipelineConfig: {
          functions: resolver.pipelineConfig?.functions ?? [],
        },
        requestMappingTemplate: resolver.requestMappingTemplate!,
        responseMappingTemplate: resolver.responseMappingTemplate!,
        typeName: resolver.typeName!,
        type: 'PipelineResolver',
      };
    });
  } while (nextToken);

  console.log(`fetchResolversForType ${typeName}`, JSON.stringify(Object.keys(resolversForType)));
  return resolversForType;
};

const fetchTypeNames = async (resourceProperties: ResourceProperties): Promise<string[]> => {
  console.log('fetchTypeNames');
  const { apiId } = resourceProperties;

  let nextToken: string | undefined = undefined;
  const typeNames: string[] = [];
  do {
    const input: ListTypesCommandInput = {
      apiId,
      format: 'JSON',
      nextToken,
    };
    const command = new ListTypesCommand(input);
    const result = await appSyncClient.send(command);
    nextToken = result.nextToken;

    if (!result.types || result.types.length === 0) {
      continue;
    }
    const localNames = result.types.map((type) => type.name).filter((name) => name !== undefined) as string[];

    typeNames.push(...localNames);
  } while (nextToken);

  console.log('fetchTypeNames:', JSON.stringify(typeNames));
  return typeNames;
};

// #endregion

// #region ComputedResources utils

const fetchComputedResources = async (resourceProperties: ResourceProperties): Promise<ResourceMap> => {
  const { computedResourcesAssetBucket, computedResourcesAssetKey } = resourceProperties;
  console.log(`getComputedResources: ${computedResourcesAssetBucket}/${computedResourcesAssetKey}`);
  const computedResources = await fetchFromS3<ResourceMap>(computedResourcesAssetBucket, computedResourcesAssetKey);
  console.log(`computedResources: ${JSON.stringify(computedResources)}`);
  return computedResources;
};

const fetchFromS3 = async <T>(bucket: string, key: string): Promise<T> => {
  console.log(`fetchFromS3: ${bucket}/${key}`);
  const s3Client = new S3Client({});
  try {
    const response = await s3Client.send(
      new GetObjectCommand({
        Bucket: bucket,
        Key: key,
      }),
    );

    if (!response.Body) {
      throw new Error('Empty response body');
    }

    const bodyContents = await response.Body.transformToString();

    try {
      return JSON.parse(bodyContents) as T;
    } catch (parseError) {
      console.log('Failed to parse JSON');
      console.log(parseError);
      return {} as T;
      // throw new Error(`Failed to parse JSON: ${parseError.message}`);
    }
  } catch (error) {
    if (error instanceof NoSuchKey) {
      throw new Error(`File not found in bucket ${bucket} with key ${key}`);
    }
    throw error;
  }
};

// #endregion

// #region type utils

const isAppSyncVtlFunction = (obj: any): obj is AppSyncVtlFunction => {
  return obj.type === 'AppSyncVtlFunction';
};

const isAppSyncPipelineResolver = (obj: any): obj is AppSyncPipelineResolver => {
  return obj.type === 'PipelineResolver';
};

/**
 * Compare equality of two AppSyncVtlFunctions. Before evaluation, the function ID of the computed function
 * `pipelineConfig` will be translated to the actual AppSync function ids using `functionIdValueMap`.
 */
const isComputedFunctionEqualToRemoteFunction = (
  computedResource: AppSyncVtlFunction,
  remoteResource: AppSyncVtlFunction,
  functionIdValueMap: FunctionIdValueMap,
): boolean => {
  return (
    computedResource.dataSource === remoteResource.dataSource &&
    functionIdValueMap[computedResource.name] === remoteResource.functionId &&
    computedResource.name === remoteResource.name &&
    computedResource.requestMappingTemplate === remoteResource.requestMappingTemplate &&
    computedResource.responseMappingTemplate === remoteResource.responseMappingTemplate
  );
};

/**
 * Evaluate equality of two resolvers. Before evaluation, the function IDs in the computed resolver's `pipelineConfig` will be translated to
 * the actual AppSync function ids using `functionIdValueMap`.
 */
const isComputedResolverEqualToRemoteResolver = (
  computedResource: AppSyncPipelineResolver,
  remoteResource: AppSyncPipelineResolver,
  functionIdValueMap: FunctionIdValueMap,
): boolean => {
  const computedFunctions = (computedResource.pipelineConfig.functions ?? []).map((x) => functionIdValueMap[x]).join(',');
  const remoteFunctions = (remoteResource.pipelineConfig.functions ?? []).join(',');
  return (
    computedResource.fieldName === remoteResource.fieldName &&
    computedResource.typeName === remoteResource.typeName &&
    computedResource.requestMappingTemplate === remoteResource.requestMappingTemplate &&
    computedResource.responseMappingTemplate === remoteResource.responseMappingTemplate &&
    computedFunctions === remoteFunctions
  );
};

// #endregion
