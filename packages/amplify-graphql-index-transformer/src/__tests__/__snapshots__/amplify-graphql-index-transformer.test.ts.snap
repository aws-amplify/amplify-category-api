// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`@index with a single sort key adds a query field and GSI correctly 1`] = `
Object {
  "Mutation.createTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.createTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.createTest.req.vtl": "## [Start] Create Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Test\\"))
#set( $nullIndexFields = [] )
#set( $indexFields = [\\"category\\"] )
#foreach( $entry in $util.map.copyAndRetainAllKeys($mergedValues, $indexFields).entrySet() )
  #if( $util.isNull($entry.value) )
    $util.qr($nullIndexFields.add($entry.key))
  #end
#end
#set( $mergedValues = $util.map.copyAndRemoveAllKeys($mergedValues, $nullIndexFields) )
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": false
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - key condition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObjectKey )
  $util.qr($PutObject.put(\\"key\\", $ctx.stash.metadata.modelObjectKey))
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.createTest.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.deleteTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.deleteTest.req.vtl": "## [Start] Delete Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.deleteTest.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.updateTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.updateTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.updateTest.req.vtl": "## [Start] Mutation Update resolver. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyFields = [] )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( !$util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) && $ctx.stash.metadata.dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $ctx.stash.metadata.dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update
} )
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.updateTest.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.getTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.getTest.req.vtl": "## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $expression = \\"\\" )
  #set( $expressionNames = {} )
  #set( $expressionValues = {} )
  #foreach( $item in $ctx.stash.metadata.modelObjectKey.entrySet() )
    #set( $expression = \\"$expression#keyCount$velocityCount = :valueCount$velocityCount AND \\" )
    $util.qr($expressionNames.put(\\"#keyCount$velocityCount\\", $item.key))
    $util.qr($expressionValues.put(\\":valueCount$velocityCount\\", $item.value))
  #end
  #set( $expression = $expression.replaceAll(\\"AND $\\", \\"\\") )
  #set( $query = {
  \\"expression\\": $expression,
  \\"expressionNames\\": $expressionNames,
  \\"expressionValues\\": $expressionValues
} )
#else
  #set( $query = {
  \\"expression\\": \\"id = :id\\",
  \\"expressionValues\\": {
      \\":id\\":     $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.id))
  }
} )
#end
$util.qr($GetRequest.put(\\"query\\", $query))
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  $util.qr($GetRequest.put(\\"filter\\", $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.authFilter))))
#end
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.getTest.res.vtl": "## [Start] Get Response template. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#end
#if( !$ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
  $util.toJson($ctx.result.items[0])
#else
  #if( $ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
$util.unauthorized()
  #end
  $util.toJson(null)
#end
## [End] Get Response template. **",
  "Query.listTests.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.listTests.req.vtl": "## [Start] List Request. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $limit = $util.defaultIfNull($args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $args.nextToken )
  #set( $ListRequest.nextToken = $args.nextToken )
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQueryExpression) && !$util.isNullOrEmpty($ctx.stash.modelQueryExpression.expression) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $ctx.stash.modelQueryExpression))
  #if( !$util.isNull($args.sortDirection) && $args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.listTests.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.testsByCategory.postAuth.1.res.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.testsByCategory.req.vtl": "## [Start] Set query expression for key **
#set( $modelQueryExpression = {} )
## [Start] Validate key arguments. **
#if( !$util.isNull($ctx.args.createdAt) && $util.isNull($ctx.args.category) )
  $util.error(\\"When providing argument 'createdAt' you must also provide arguments category\\", \\"InvalidArgumentsError\\")
#end
## [End] Validate key arguments. **
#if( !$util.isNull($ctx.args.category) )
  #set( $modelQueryExpression.expression = \\"#category = :category\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#category\\": \\"category\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":category\\": {
      \\"S\\": \\"$ctx.args.category\\"
  }
} )
#end
## [Start] Applying Key Condition **
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.beginsWith) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.beginsWith\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.between) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey0\\", { \\"S\\": \\"$ctx.args.createdAt.between[0]\\" }))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey1\\", { \\"S\\": \\"$ctx.args.createdAt.between[1]\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.eq) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.eq\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.lt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.lt\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.le) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.le\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.gt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.gt\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.ge) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.ge\\" }))
#end
## [End] Applying Key Condition **
## [End] Set query expression for key **
#set( $limit = $util.defaultIfNull($context.args.limit, 100) )
#set( $QueryRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\",
  \\"limit\\": $limit,
  \\"query\\": $modelQueryExpression,
  \\"index\\": \\"CategoryGSI\\"
} )
#if( !$util.isNull($ctx.args.sortDirection)
                  && $ctx.args.sortDirection == \\"DESC\\" )
  #set( $QueryRequest.scanIndexForward = false )
#else
  #set( $QueryRequest.scanIndexForward = true )
#end
#if( $context.args.nextToken ) #set( $QueryRequest.nextToken = $context.args.nextToken ) #end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $ctx.args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = $ctx.args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $QueryRequest.filter = $filterExpression )
  #end
#end
$util.toJson($QueryRequest)",
  "Query.testsByCategory.res.vtl": "#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#end
$util.toJson($ctx.result)",
  "Subscription.onCreateTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onCreateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onCreateTest.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onDeleteTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onDeleteTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onDeleteTest.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onUpdateTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onUpdateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onUpdateTest.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
}
`;

exports[`@index with multiple sort keys adds a query field and GSI correctly 1`] = `
Object {
  "Mutation.createTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.createTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.createTest.preAuth.1.req.vtl": "## [Start] Merge default values and inputs. **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## [End] Merge default values and inputs. **
## [Start] Validate create mutation for @index 'GSI'. **
#set( $hasSeenSomeKeyArg = false )
#set( $keyFieldNames = [\\"kind\\", \\"date\\"] )
#foreach( $keyFieldName in $keyFieldNames )
#if( $mergedValues.containsKey(\\"$keyFieldName\\") ) #set( $hasSeenSomeKeyArg = true ) #end
#end
#foreach( $keyFieldName in $keyFieldNames )
  #if( $hasSeenSomeKeyArg && !$mergedValues.containsKey(\\"$keyFieldName\\") )
    $util.error(\\"When creating any part of the composite sort key for @index 'GSI', you must provide all fields for the key. Missing key: '$keyFieldName'.\\")
  #end
#end
## [End] Validate create mutation for @index 'GSI'. **
#if( $util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) )
  $util.qr($ctx.stash.metadata.put(\\"dynamodbNameOverrideMap\\", { 'kind#date': \\"kindDate\\" }))
#else
  $util.qr($ctx.stash.metadata.dynamodbNameOverrideMap.put('kind#date', \\"kindDate\\"))
#end
#if( $hasSeenSomeKeyArg )
  $util.qr($ctx.args.input.put('kind#date',\\"\${mergedValues.kind}#\${mergedValues.date}\\"))
#end
{}",
  "Mutation.createTest.req.vtl": "## [Start] Create Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Test\\"))
#set( $nullIndexFields = [] )
#set( $indexFields = [\\"email\\"] )
#foreach( $entry in $util.map.copyAndRetainAllKeys($mergedValues, $indexFields).entrySet() )
  #if( $util.isNull($entry.value) )
    $util.qr($nullIndexFields.add($entry.key))
  #end
#end
#set( $mergedValues = $util.map.copyAndRemoveAllKeys($mergedValues, $nullIndexFields) )
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": false
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - key condition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObjectKey )
  $util.qr($PutObject.put(\\"key\\", $ctx.stash.metadata.modelObjectKey))
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.createTest.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.deleteTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.deleteTest.preAuth.1.req.vtl": "## [Start] Merge default values and inputs. **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## [End] Merge default values and inputs. **
#if( $util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) )
  $util.qr($ctx.stash.metadata.put(\\"dynamodbNameOverrideMap\\", { 'kind#date': \\"kindDate\\" }))
#else
  $util.qr($ctx.stash.metadata.dynamodbNameOverrideMap.put('kind#date', \\"kindDate\\"))
#end
$util.qr($ctx.args.input.put('kind#date',\\"\${mergedValues.kind}#\${mergedValues.date}\\"))
{}",
  "Mutation.deleteTest.req.vtl": "## [Start] Delete Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.deleteTest.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.updateTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.updateTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.updateTest.preAuth.1.req.vtl": "## [Start] Merge default values and inputs. **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## [End] Merge default values and inputs. **
## [Start] Validate update mutation for @index 'GSI'. **
#set( $hasSeenSomeKeyArg = false )
#set( $keyFieldNames = [\\"kind\\", \\"date\\"] )
#foreach( $keyFieldName in $keyFieldNames )
#if( $mergedValues.containsKey(\\"$keyFieldName\\") ) #set( $hasSeenSomeKeyArg = true ) #end
#end
#foreach( $keyFieldName in $keyFieldNames )
  #if( $hasSeenSomeKeyArg && !$mergedValues.containsKey(\\"$keyFieldName\\") )
    $util.error(\\"When updating any part of the composite sort key for @index 'GSI', you must provide all fields for the key. Missing key: '$keyFieldName'.\\")
  #end
#end
## [End] Validate update mutation for @index 'GSI'. **
#if( $util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) )
  $util.qr($ctx.stash.metadata.put(\\"dynamodbNameOverrideMap\\", { 'kind#date': \\"kindDate\\" }))
#else
  $util.qr($ctx.stash.metadata.dynamodbNameOverrideMap.put('kind#date', \\"kindDate\\"))
#end
#if( $hasSeenSomeKeyArg )
  $util.qr($ctx.args.input.put('kind#date',\\"\${mergedValues.kind}#\${mergedValues.date}\\"))
#end
{}",
  "Mutation.updateTest.req.vtl": "## [Start] Mutation Update resolver. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyFields = [] )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( !$util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) && $ctx.stash.metadata.dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $ctx.stash.metadata.dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update
} )
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.updateTest.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.getTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.getTest.req.vtl": "## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $expression = \\"\\" )
  #set( $expressionNames = {} )
  #set( $expressionValues = {} )
  #foreach( $item in $ctx.stash.metadata.modelObjectKey.entrySet() )
    #set( $expression = \\"$expression#keyCount$velocityCount = :valueCount$velocityCount AND \\" )
    $util.qr($expressionNames.put(\\"#keyCount$velocityCount\\", $item.key))
    $util.qr($expressionValues.put(\\":valueCount$velocityCount\\", $item.value))
  #end
  #set( $expression = $expression.replaceAll(\\"AND $\\", \\"\\") )
  #set( $query = {
  \\"expression\\": $expression,
  \\"expressionNames\\": $expressionNames,
  \\"expressionValues\\": $expressionValues
} )
#else
  #set( $query = {
  \\"expression\\": \\"id = :id\\",
  \\"expressionValues\\": {
      \\":id\\":     $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.id))
  }
} )
#end
$util.qr($GetRequest.put(\\"query\\", $query))
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  $util.qr($GetRequest.put(\\"filter\\", $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.authFilter))))
#end
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.getTest.res.vtl": "## [Start] Get Response template. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#end
#if( !$ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
  $util.toJson($ctx.result.items[0])
#else
  #if( $ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
$util.unauthorized()
  #end
  $util.toJson(null)
#end
## [End] Get Response template. **",
  "Query.listByEmailKindDate.postAuth.1.res.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.listByEmailKindDate.req.vtl": "## [Start] Set query expression for key **
#set( $modelQueryExpression = {} )
## [Start] Validate key arguments. **
#if( !$util.isNull($ctx.args.kindDate) && $util.isNullOrBlank($ctx.args.email) )
  $util.error(\\"When providing argument 'kindDate' you must also provide 'email'.\\", \\"InvalidArgumentsError\\")
#end
#if( !$util.isNull($ctx.args.kindDate) )
  #set( $sortKeyArgumentOperations = $ctx.args.kindDate.keySet() )
  #if( $sortKeyArgumentOperations.size() > 1 )
    $util.error(\\"Argument kindDate must specify at most one key condition operation.\\", \\"InvalidArgumentsError\\")
  #end
  #foreach( $operation in $sortKeyArgumentOperations )
    #if( $operation == \\"between\\" )
      #if( $ctx.args.kindDate.between.size() != 2 )
        $util.error(\\"Argument 'kindDate.between' expects exactly two elements.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.kindDate.between[0].date) && $util.isNullOrBlank($ctx.args.kindDate.between[0].kind) )
        $util.error(\\"When providing argument 'kindDate.between[0].date' you must also provide 'kindDate.between[0].kind'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.kindDate.between[1].date) && $util.isNullOrBlank($ctx.args.kindDate.between[1].kind) )
        $util.error(\\"When providing argument 'kindDate.between[1].date' you must also provide 'kindDate.between[1].kind'.\\", \\"InvalidArgumentsError\\")
      #end
    #else
      #if( !$util.isNullOrBlank($ctx.args.kindDate.get(\\"$operation\\").date) && $util.isNullOrBlank($ctx.args.kindDate.get(\\"$operation\\").kind) )
        $util.error(\\"When providing argument 'kindDate.$operation.date' you must also provide 'kindDate.$operation.kind'.\\", \\"InvalidArgumentsError\\")
      #end
    #end
  #end
#end
## [End] Validate key arguments. **
#if( !$util.isNull($ctx.args.email) )
  #set( $modelQueryExpression.expression = \\"#email = :email\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#email\\": \\"email\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":email\\": {
      \\"S\\": \\"$ctx.args.email\\"
  }
} )
#end
## [Start] Applying Key Condition **
#set( $sortKeyValue = \\"\\" )
#set( $sortKeyValue2 = \\"\\" )
#if( !$util.isNull($ctx.args.kindDate) && !$util.isNull($ctx.args.kindDate.beginsWith) )
#if( !$util.isNull($ctx.args.kindDate.beginsWith.kind) ) #set( $sortKeyValue = \\"$ctx.args.kindDate.beginsWith.kind\\" ) #end
#if( !$util.isNull($ctx.args.kindDate.beginsWith.date) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.kindDate.beginsWith.date\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind#date\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.kindDate) && !$util.isNull($ctx.args.kindDate.between) )
  #if( $ctx.args.kindDate.between.size() != 2 )
    $util.error(\\"Argument kindDate.between expects exactly 2 elements.\\")
  #end
#if( !$util.isNull($ctx.args.kindDate.between[0].kind) ) #set( $sortKeyValue = \\"$ctx.args.kindDate.between[0].kind\\" ) #end
#if( !$util.isNull($ctx.args.kindDate.between[0].date) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.kindDate.between[0].date\\" ) #end
#if( !$util.isNull($ctx.args.kindDate.between[1].kind) ) #set( $sortKeyValue2 = \\"$ctx.args.kindDate.between[1].kind\\" ) #end
#if( !$util.isNull($ctx.args.kindDate.between[1].date) ) #set( $sortKeyValue2 = \\"$sortKeyValue2#$ctx.args.kindDate.between[1].date\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind#date\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey0\\", { \\"S\\": \\"$sortKeyValue\\" }))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey1\\", { \\"S\\": \\"$sortKeyValue2\\" }))
#end
#if( !$util.isNull($ctx.args.kindDate) && !$util.isNull($ctx.args.kindDate.eq) )
#if( !$util.isNull($ctx.args.kindDate.eq.kind) ) #set( $sortKeyValue = \\"$ctx.args.kindDate.eq.kind\\" ) #end
#if( !$util.isNull($ctx.args.kindDate.eq.date) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.kindDate.eq.date\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind#date\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.kindDate) && !$util.isNull($ctx.args.kindDate.lt) )
#if( !$util.isNull($ctx.args.kindDate.lt.kind) ) #set( $sortKeyValue = \\"$ctx.args.kindDate.lt.kind\\" ) #end
#if( !$util.isNull($ctx.args.kindDate.lt.date) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.kindDate.lt.date\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind#date\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.kindDate) && !$util.isNull($ctx.args.kindDate.le) )
#if( !$util.isNull($ctx.args.kindDate.le.kind) ) #set( $sortKeyValue = \\"$ctx.args.kindDate.le.kind\\" ) #end
#if( !$util.isNull($ctx.args.kindDate.le.date) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.kindDate.le.date\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind#date\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.kindDate) && !$util.isNull($ctx.args.kindDate.gt) )
#if( !$util.isNull($ctx.args.kindDate.gt.kind) ) #set( $sortKeyValue = \\"$ctx.args.kindDate.gt.kind\\" ) #end
#if( !$util.isNull($ctx.args.kindDate.gt.date) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.kindDate.gt.date\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind#date\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.kindDate) && !$util.isNull($ctx.args.kindDate.ge) )
#if( !$util.isNull($ctx.args.kindDate.ge.kind) ) #set( $sortKeyValue = \\"$ctx.args.kindDate.ge.kind\\" ) #end
#if( !$util.isNull($ctx.args.kindDate.ge.date) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.kindDate.ge.date\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"kind#date\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end


## [End] Applying Key Condition **
## [End] Set query expression for key **
#set( $limit = $util.defaultIfNull($context.args.limit, 100) )
#set( $QueryRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\",
  \\"limit\\": $limit,
  \\"query\\": $modelQueryExpression,
  \\"index\\": \\"GSI\\"
} )
#if( !$util.isNull($ctx.args.sortDirection)
                  && $ctx.args.sortDirection == \\"DESC\\" )
  #set( $QueryRequest.scanIndexForward = false )
#else
  #set( $QueryRequest.scanIndexForward = true )
#end
#if( $context.args.nextToken ) #set( $QueryRequest.nextToken = $context.args.nextToken ) #end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $ctx.args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = $ctx.args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $QueryRequest.filter = $filterExpression )
  #end
#end
$util.toJson($QueryRequest)",
  "Query.listByEmailKindDate.res.vtl": "#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#end
$util.toJson($ctx.result)",
  "Query.listTests.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.listTests.req.vtl": "## [Start] List Request. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $limit = $util.defaultIfNull($args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $args.nextToken )
  #set( $ListRequest.nextToken = $args.nextToken )
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQueryExpression) && !$util.isNullOrEmpty($ctx.stash.modelQueryExpression.expression) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $ctx.stash.modelQueryExpression))
  #if( !$util.isNull($args.sortDirection) && $args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.listTests.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Subscription.onCreateTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onCreateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onCreateTest.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onDeleteTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onDeleteTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onDeleteTest.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onUpdateTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onUpdateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onUpdateTest.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
}
`;

exports[`@index with no sort key field adds a query field and GSI correctly 1`] = `
Object {
  "Mutation.createTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.createTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.createTest.req.vtl": "## [Start] Create Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Test\\"))
#set( $nullIndexFields = [] )
#set( $indexFields = [\\"email\\"] )
#foreach( $entry in $util.map.copyAndRetainAllKeys($mergedValues, $indexFields).entrySet() )
  #if( $util.isNull($entry.value) )
    $util.qr($nullIndexFields.add($entry.key))
  #end
#end
#set( $mergedValues = $util.map.copyAndRemoveAllKeys($mergedValues, $nullIndexFields) )
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": false
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - key condition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObjectKey )
  $util.qr($PutObject.put(\\"key\\", $ctx.stash.metadata.modelObjectKey))
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.createTest.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.deleteTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.deleteTest.req.vtl": "## [Start] Delete Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.deleteTest.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.updateTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.updateTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.updateTest.req.vtl": "## [Start] Mutation Update resolver. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyFields = [] )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( !$util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) && $ctx.stash.metadata.dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $ctx.stash.metadata.dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update
} )
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.updateTest.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.getTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.getTest.req.vtl": "## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $expression = \\"\\" )
  #set( $expressionNames = {} )
  #set( $expressionValues = {} )
  #foreach( $item in $ctx.stash.metadata.modelObjectKey.entrySet() )
    #set( $expression = \\"$expression#keyCount$velocityCount = :valueCount$velocityCount AND \\" )
    $util.qr($expressionNames.put(\\"#keyCount$velocityCount\\", $item.key))
    $util.qr($expressionValues.put(\\":valueCount$velocityCount\\", $item.value))
  #end
  #set( $expression = $expression.replaceAll(\\"AND $\\", \\"\\") )
  #set( $query = {
  \\"expression\\": $expression,
  \\"expressionNames\\": $expressionNames,
  \\"expressionValues\\": $expressionValues
} )
#else
  #set( $query = {
  \\"expression\\": \\"id = :id\\",
  \\"expressionValues\\": {
      \\":id\\":     $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.id))
  }
} )
#end
$util.qr($GetRequest.put(\\"query\\", $query))
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  $util.qr($GetRequest.put(\\"filter\\", $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.authFilter))))
#end
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.getTest.res.vtl": "## [Start] Get Response template. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#end
#if( !$ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
  $util.toJson($ctx.result.items[0])
#else
  #if( $ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
$util.unauthorized()
  #end
  $util.toJson(null)
#end
## [End] Get Response template. **",
  "Query.listTests.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.listTests.req.vtl": "## [Start] List Request. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $limit = $util.defaultIfNull($args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $args.nextToken )
  #set( $ListRequest.nextToken = $args.nextToken )
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQueryExpression) && !$util.isNullOrEmpty($ctx.stash.modelQueryExpression.expression) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $ctx.stash.modelQueryExpression))
  #if( !$util.isNull($args.sortDirection) && $args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.listTests.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.testsByEmail.postAuth.1.res.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.testsByEmail.req.vtl": "## [Start] Set query expression for key **
#if( !$util.isNull($ctx.args.sortDirection) )
  $util.error(\\"sortDirection is not supported for List operations without a Sort key defined.\\", \\"InvalidArgumentsError\\")
#end
#set( $modelQueryExpression = {} )
#if( !$util.isNull($ctx.args.email) )
  #set( $modelQueryExpression.expression = \\"#email = :email\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#email\\": \\"email\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":email\\": {
      \\"S\\": \\"$ctx.args.email\\"
  }
} )
#end
## [End] Set query expression for key **
#set( $limit = $util.defaultIfNull($context.args.limit, 100) )
#set( $QueryRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\",
  \\"limit\\": $limit,
  \\"query\\": $modelQueryExpression,
  \\"index\\": \\"GSI_Email\\"
} )
#if( !$util.isNull($ctx.args.sortDirection)
                  && $ctx.args.sortDirection == \\"DESC\\" )
  #set( $QueryRequest.scanIndexForward = false )
#else
  #set( $QueryRequest.scanIndexForward = true )
#end
#if( $context.args.nextToken ) #set( $QueryRequest.nextToken = $context.args.nextToken ) #end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $ctx.args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = $ctx.args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $QueryRequest.filter = $filterExpression )
  #end
#end
$util.toJson($QueryRequest)",
  "Query.testsByEmail.res.vtl": "#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#end
$util.toJson($ctx.result)",
  "Subscription.onCreateTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onCreateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onCreateTest.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onDeleteTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onDeleteTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onDeleteTest.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onUpdateTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onUpdateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onUpdateTest.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
}
`;

exports[`GSI composite sort keys are wrapped in conditional to check presence in mutation 1`] = `
"## [Start] Create Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Person\\"))
#set( $nullIndexFields = [] )
#set( $indexFields = [\\"firstName\\"] )
#foreach( $entry in $util.map.copyAndRetainAllKeys($mergedValues, $indexFields).entrySet() )
  #if( $util.isNull($entry.value) )
    $util.qr($nullIndexFields.add($entry.key))
  #end
#end
#set( $mergedValues = $util.map.copyAndRemoveAllKeys($mergedValues, $nullIndexFields) )
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": false
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - key condition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObjectKey )
  $util.qr($PutObject.put(\\"key\\", $ctx.stash.metadata.modelObjectKey))
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **"
`;

exports[`GSI composite sort keys are wrapped in conditional to check presence in mutation 2`] = `
"## [Start] Mutation Update resolver. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyFields = [] )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( !$util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) && $ctx.stash.metadata.dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $ctx.stash.metadata.dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update
} )
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **"
`;

exports[`auth iam and sandbox auth disable should not add service directives 1`] = `
"type Test {
  id: ID!
  description: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelSubscriptionStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  in: [String]
  notIn: [String]
}

input ModelSubscriptionIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  in: [Int]
  notIn: [Int]
}

input ModelSubscriptionFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  in: [Float]
  notIn: [Float]
}

input ModelSubscriptionBooleanInput {
  ne: Boolean
  eq: Boolean
}

input ModelSubscriptionIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  in: [ID]
  notIn: [ID]
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelTestConnection {
  items: [Test]!
  nextToken: String
}

input ModelTestFilterInput {
  id: ModelIDInput
  description: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelTestFilterInput]
  or: [ModelTestFilterInput]
  not: ModelTestFilterInput
}

type Query {
  getTest(id: ID!): Test
  listTests(filter: ModelTestFilterInput, limit: Int, nextToken: String): ModelTestConnection
  testsByDescription(description: String!, sortDirection: ModelSortDirection, filter: ModelTestFilterInput, limit: Int, nextToken: String): ModelTestConnection
}

input ModelTestConditionInput {
  description: ModelStringInput
  and: [ModelTestConditionInput]
  or: [ModelTestConditionInput]
  not: ModelTestConditionInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
}

input CreateTestInput {
  id: ID
  description: String
}

input UpdateTestInput {
  id: ID!
  description: String
}

input DeleteTestInput {
  id: ID!
}

type Mutation {
  createTest(input: CreateTestInput!, condition: ModelTestConditionInput): Test
  updateTest(input: UpdateTestInput!, condition: ModelTestConditionInput): Test
  deleteTest(input: DeleteTestInput!, condition: ModelTestConditionInput): Test
}

input ModelSubscriptionTestFilterInput {
  id: ModelSubscriptionIDInput
  description: ModelSubscriptionStringInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionTestFilterInput]
  or: [ModelSubscriptionTestFilterInput]
}

type Subscription {
  onCreateTest(filter: ModelSubscriptionTestFilterInput): Test @aws_subscribe(mutations: [\\"createTest\\"])
  onUpdateTest(filter: ModelSubscriptionTestFilterInput): Test @aws_subscribe(mutations: [\\"updateTest\\"])
  onDeleteTest(filter: ModelSubscriptionTestFilterInput): Test @aws_subscribe(mutations: [\\"deleteTest\\"])
}
"
`;

exports[`auth iam and sandbox auth disable should not add service directives 2`] = `
"## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **"
`;

exports[`auth iam and sandbox auth enabled should add aws_iam and aws_api_key if not default mode of auth 1`] = `
"type Test @aws_api_key @aws_iam {
  id: ID!
  description: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelSubscriptionStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  in: [String]
  notIn: [String]
}

input ModelSubscriptionIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  in: [Int]
  notIn: [Int]
}

input ModelSubscriptionFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  in: [Float]
  notIn: [Float]
}

input ModelSubscriptionBooleanInput {
  ne: Boolean
  eq: Boolean
}

input ModelSubscriptionIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  in: [ID]
  notIn: [ID]
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelTestConnection @aws_api_key @aws_iam {
  items: [Test]!
  nextToken: String
}

input ModelTestFilterInput {
  id: ModelIDInput
  description: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelTestFilterInput]
  or: [ModelTestFilterInput]
  not: ModelTestFilterInput
}

type Query {
  getTest(id: ID!): Test @aws_api_key @aws_iam
  listTests(filter: ModelTestFilterInput, limit: Int, nextToken: String): ModelTestConnection @aws_api_key @aws_iam
  testsByDescription(description: String!, sortDirection: ModelSortDirection, filter: ModelTestFilterInput, limit: Int, nextToken: String): ModelTestConnection @aws_api_key @aws_iam
}

input ModelTestConditionInput {
  description: ModelStringInput
  and: [ModelTestConditionInput]
  or: [ModelTestConditionInput]
  not: ModelTestConditionInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
}

input CreateTestInput {
  id: ID
  description: String
}

input UpdateTestInput {
  id: ID!
  description: String
}

input DeleteTestInput {
  id: ID!
}

type Mutation {
  createTest(input: CreateTestInput!, condition: ModelTestConditionInput): Test @aws_api_key @aws_iam
  updateTest(input: UpdateTestInput!, condition: ModelTestConditionInput): Test @aws_api_key @aws_iam
  deleteTest(input: DeleteTestInput!, condition: ModelTestConditionInput): Test @aws_api_key @aws_iam
}

input ModelSubscriptionTestFilterInput {
  id: ModelSubscriptionIDInput
  description: ModelSubscriptionStringInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionTestFilterInput]
  or: [ModelSubscriptionTestFilterInput]
}

type Subscription {
  onCreateTest(filter: ModelSubscriptionTestFilterInput): Test @aws_subscribe(mutations: [\\"createTest\\"]) @aws_api_key @aws_iam
  onUpdateTest(filter: ModelSubscriptionTestFilterInput): Test @aws_subscribe(mutations: [\\"updateTest\\"]) @aws_api_key @aws_iam
  onDeleteTest(filter: ModelSubscriptionTestFilterInput): Test @aws_subscribe(mutations: [\\"deleteTest\\"]) @aws_api_key @aws_iam
}
"
`;

exports[`auth iam and sandbox auth enabled should add aws_iam and aws_api_key if not default mode of auth 2`] = `
"## [Start] Sandbox Mode Enabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  #if( $util.authType() == \\"API Key Authorization\\" )
    #return($util.toJson({}))
  #end
  #if( $util.authType() == \\"IAM Authorization\\" && $util.isNull($ctx.identity.cognitoIdentityPoolId) && $util.isNull($ctx.identity.cognitoIdentityId) )
    #return($util.toJson({}))
  #end
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Enabled. **"
`;

exports[`auth iam auth enabled should add aws_iam if not default mode of auth 1`] = `
"type Test @aws_iam {
  id: ID!
  description: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelSubscriptionStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  in: [String]
  notIn: [String]
}

input ModelSubscriptionIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  in: [Int]
  notIn: [Int]
}

input ModelSubscriptionFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  in: [Float]
  notIn: [Float]
}

input ModelSubscriptionBooleanInput {
  ne: Boolean
  eq: Boolean
}

input ModelSubscriptionIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  in: [ID]
  notIn: [ID]
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelTestConnection @aws_iam {
  items: [Test]!
  nextToken: String
}

input ModelTestFilterInput {
  id: ModelIDInput
  description: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelTestFilterInput]
  or: [ModelTestFilterInput]
  not: ModelTestFilterInput
}

type Query {
  getTest(id: ID!): Test @aws_iam
  listTests(filter: ModelTestFilterInput, limit: Int, nextToken: String): ModelTestConnection @aws_iam
  testsByDescription(description: String!, sortDirection: ModelSortDirection, filter: ModelTestFilterInput, limit: Int, nextToken: String): ModelTestConnection @aws_iam
}

input ModelTestConditionInput {
  description: ModelStringInput
  and: [ModelTestConditionInput]
  or: [ModelTestConditionInput]
  not: ModelTestConditionInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
}

input CreateTestInput {
  id: ID
  description: String
}

input UpdateTestInput {
  id: ID!
  description: String
}

input DeleteTestInput {
  id: ID!
}

type Mutation {
  createTest(input: CreateTestInput!, condition: ModelTestConditionInput): Test @aws_iam
  updateTest(input: UpdateTestInput!, condition: ModelTestConditionInput): Test @aws_iam
  deleteTest(input: DeleteTestInput!, condition: ModelTestConditionInput): Test @aws_iam
}

input ModelSubscriptionTestFilterInput {
  id: ModelSubscriptionIDInput
  description: ModelSubscriptionStringInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionTestFilterInput]
  or: [ModelSubscriptionTestFilterInput]
}

type Subscription {
  onCreateTest(filter: ModelSubscriptionTestFilterInput): Test @aws_subscribe(mutations: [\\"createTest\\"]) @aws_iam
  onUpdateTest(filter: ModelSubscriptionTestFilterInput): Test @aws_subscribe(mutations: [\\"updateTest\\"]) @aws_iam
  onDeleteTest(filter: ModelSubscriptionTestFilterInput): Test @aws_subscribe(mutations: [\\"deleteTest\\"]) @aws_iam
}
"
`;

exports[`auth iam auth enabled should add aws_iam if not default mode of auth 2`] = `
"## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  #if( $util.authType() == \\"IAM Authorization\\" && $util.isNull($ctx.identity.cognitoIdentityPoolId) && $util.isNull($ctx.identity.cognitoIdentityId) )
    #return($util.toJson({}))
  #end
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **"
`;

exports[`auth sandbox auth enabled should add apiKey if not default mode of auth 1`] = `
"type Test @aws_api_key {
  id: ID!
  description: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelSubscriptionStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  in: [String]
  notIn: [String]
}

input ModelSubscriptionIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  in: [Int]
  notIn: [Int]
}

input ModelSubscriptionFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  in: [Float]
  notIn: [Float]
}

input ModelSubscriptionBooleanInput {
  ne: Boolean
  eq: Boolean
}

input ModelSubscriptionIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  in: [ID]
  notIn: [ID]
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelTestConnection @aws_api_key {
  items: [Test]!
  nextToken: String
}

input ModelTestFilterInput {
  id: ModelIDInput
  description: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelTestFilterInput]
  or: [ModelTestFilterInput]
  not: ModelTestFilterInput
}

type Query {
  getTest(id: ID!): Test @aws_api_key
  listTests(filter: ModelTestFilterInput, limit: Int, nextToken: String): ModelTestConnection @aws_api_key
  testsByDescription(description: String!, sortDirection: ModelSortDirection, filter: ModelTestFilterInput, limit: Int, nextToken: String): ModelTestConnection @aws_api_key
}

input ModelTestConditionInput {
  description: ModelStringInput
  and: [ModelTestConditionInput]
  or: [ModelTestConditionInput]
  not: ModelTestConditionInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
}

input CreateTestInput {
  id: ID
  description: String
}

input UpdateTestInput {
  id: ID!
  description: String
}

input DeleteTestInput {
  id: ID!
}

type Mutation {
  createTest(input: CreateTestInput!, condition: ModelTestConditionInput): Test @aws_api_key
  updateTest(input: UpdateTestInput!, condition: ModelTestConditionInput): Test @aws_api_key
  deleteTest(input: DeleteTestInput!, condition: ModelTestConditionInput): Test @aws_api_key
}

input ModelSubscriptionTestFilterInput {
  id: ModelSubscriptionIDInput
  description: ModelSubscriptionStringInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionTestFilterInput]
  or: [ModelSubscriptionTestFilterInput]
}

type Subscription {
  onCreateTest(filter: ModelSubscriptionTestFilterInput): Test @aws_subscribe(mutations: [\\"createTest\\"]) @aws_api_key
  onUpdateTest(filter: ModelSubscriptionTestFilterInput): Test @aws_subscribe(mutations: [\\"updateTest\\"]) @aws_api_key
  onDeleteTest(filter: ModelSubscriptionTestFilterInput): Test @aws_subscribe(mutations: [\\"deleteTest\\"]) @aws_api_key
}
"
`;

exports[`auth sandbox auth enabled should add apiKey if not default mode of auth 2`] = `
"## [Start] Sandbox Mode Enabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  #if( $util.authType() == \\"API Key Authorization\\" )
    #return($util.toJson({}))
  #end
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Enabled. **"
`;

exports[`creates a primary key and a secondary index 1`] = `
Object {
  "Mutation.createTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.createTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.createTest.preAuth.1.req.vtl": "## [Start] Merge default values and inputs. **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## [End] Merge default values and inputs. **
## [Start] Set the primary key. **
$util.qr($ctx.stash.metadata.put(\\"modelObjectKey\\", {
  \\"email\\": $util.dynamodb.toDynamoDB($mergedValues.email),
  \\"createdAt\\": $util.dynamodb.toDynamoDB($mergedValues.createdAt)
}))
## [End] Set the primary key. **

{}",
  "Mutation.createTest.req.vtl": "## [Start] Create Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Test\\"))
#set( $nullIndexFields = [] )
#set( $indexFields = [\\"category\\"] )
#foreach( $entry in $util.map.copyAndRetainAllKeys($mergedValues, $indexFields).entrySet() )
  #if( $util.isNull($entry.value) )
    $util.qr($nullIndexFields.add($entry.key))
  #end
#end
#set( $mergedValues = $util.map.copyAndRemoveAllKeys($mergedValues, $nullIndexFields) )
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": false
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - key condition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObjectKey )
  $util.qr($PutObject.put(\\"key\\", $ctx.stash.metadata.modelObjectKey))
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.createTest.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.deleteTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.deleteTest.preAuth.1.req.vtl": "## [Start] Merge default values and inputs. **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## [End] Merge default values and inputs. **
## [Start] Set the primary key. **
$util.qr($ctx.stash.metadata.put(\\"modelObjectKey\\", {
  \\"email\\": $util.dynamodb.toDynamoDB($mergedValues.email),
  \\"createdAt\\": $util.dynamodb.toDynamoDB($mergedValues.createdAt)
}))
## [End] Set the primary key. **
{}",
  "Mutation.deleteTest.req.vtl": "## [Start] Delete Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.deleteTest.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.updateTest.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.updateTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.updateTest.preAuth.1.req.vtl": "## [Start] Merge default values and inputs. **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## [End] Merge default values and inputs. **
## [Start] Set the primary key. **
$util.qr($ctx.stash.metadata.put(\\"modelObjectKey\\", {
  \\"email\\": $util.dynamodb.toDynamoDB($mergedValues.email),
  \\"createdAt\\": $util.dynamodb.toDynamoDB($mergedValues.createdAt)
}))
## [End] Set the primary key. **

{}",
  "Mutation.updateTest.req.vtl": "## [Start] Mutation Update resolver. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyFields = [] )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( !$util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) && $ctx.stash.metadata.dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $ctx.stash.metadata.dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update
} )
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.updateTest.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.getTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.getTest.preAuth.1.req.vtl": "## [Start] Set the primary key. **
$util.qr($ctx.stash.metadata.put(\\"modelObjectKey\\", {
  \\"email\\": $util.dynamodb.toDynamoDB($ctx.args.email),
  \\"createdAt\\": $util.dynamodb.toDynamoDB($ctx.args.createdAt)
}))
## [End] Set the primary key. **
{}",
  "Query.getTest.req.vtl": "## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $expression = \\"\\" )
  #set( $expressionNames = {} )
  #set( $expressionValues = {} )
  #foreach( $item in $ctx.stash.metadata.modelObjectKey.entrySet() )
    #set( $expression = \\"$expression#keyCount$velocityCount = :valueCount$velocityCount AND \\" )
    $util.qr($expressionNames.put(\\"#keyCount$velocityCount\\", $item.key))
    $util.qr($expressionValues.put(\\":valueCount$velocityCount\\", $item.value))
  #end
  #set( $expression = $expression.replaceAll(\\"AND $\\", \\"\\") )
  #set( $query = {
  \\"expression\\": $expression,
  \\"expressionNames\\": $expressionNames,
  \\"expressionValues\\": $expressionValues
} )
#else
  #set( $query = {
  \\"expression\\": \\"id = :id\\",
  \\"expressionValues\\": {
      \\":id\\":     $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.id))
  }
} )
#end
$util.qr($GetRequest.put(\\"query\\", $query))
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  $util.qr($GetRequest.put(\\"filter\\", $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.authFilter))))
#end
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.getTest.res.vtl": "## [Start] Get Response template. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#end
#if( !$ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
  $util.toJson($ctx.result.items[0])
#else
  #if( $ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
$util.unauthorized()
  #end
  $util.toJson(null)
#end
## [End] Get Response template. **",
  "Query.listTests.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.listTests.preAuth.1.req.vtl": "## [Start] Set query expression for key **
#if( $util.isNull($ctx.args.email) && !$util.isNull($ctx.args.sortDirection) )
  $util.error(\\"When providing argument 'sortDirection' you must also provide argument 'email'.\\", \\"InvalidArgumentsError\\")
#end
#set( $modelQueryExpression = {} )
## [Start] Validate key arguments. **
#if( !$util.isNull($ctx.args.createdAt) && $util.isNull($ctx.args.email) )
  $util.error(\\"When providing argument 'createdAt' you must also provide arguments email\\", \\"InvalidArgumentsError\\")
#end
## [End] Validate key arguments. **
#if( !$util.isNull($ctx.args.email) )
  #set( $modelQueryExpression.expression = \\"#email = :email\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#email\\": \\"email\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":email\\": {
      \\"S\\": \\"$ctx.args.email\\"
  }
} )
#end
## [Start] Applying Key Condition **
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.beginsWith) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.beginsWith\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.between) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey0\\", { \\"S\\": \\"$ctx.args.createdAt.between[0]\\" }))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey1\\", { \\"S\\": \\"$ctx.args.createdAt.between[1]\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.eq) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.eq\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.lt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.lt\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.le) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.le\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.gt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.gt\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.ge) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.ge\\" }))
#end
## [End] Applying Key Condition **
## [End] Set query expression for key **
$util.qr($ctx.stash.put(\\"modelQueryExpression\\", $modelQueryExpression))
{}",
  "Query.listTests.req.vtl": "## [Start] List Request. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $limit = $util.defaultIfNull($args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $args.nextToken )
  #set( $ListRequest.nextToken = $args.nextToken )
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQueryExpression) && !$util.isNullOrEmpty($ctx.stash.modelQueryExpression.expression) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $ctx.stash.modelQueryExpression))
  #if( !$util.isNull($args.sortDirection) && $args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.listTests.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.testsByCategory.postAuth.1.res.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.testsByCategory.req.vtl": "## [Start] Set query expression for key **
#set( $modelQueryExpression = {} )
## [Start] Validate key arguments. **
#if( !$util.isNull($ctx.args.createdAt) && $util.isNull($ctx.args.category) )
  $util.error(\\"When providing argument 'createdAt' you must also provide arguments category\\", \\"InvalidArgumentsError\\")
#end
## [End] Validate key arguments. **
#if( !$util.isNull($ctx.args.category) )
  #set( $modelQueryExpression.expression = \\"#category = :category\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#category\\": \\"category\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":category\\": {
      \\"S\\": \\"$ctx.args.category\\"
  }
} )
#end
## [Start] Applying Key Condition **
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.beginsWith) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.beginsWith\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.between) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey0\\", { \\"S\\": \\"$ctx.args.createdAt.between[0]\\" }))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey1\\", { \\"S\\": \\"$ctx.args.createdAt.between[1]\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.eq) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.eq\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.lt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.lt\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.le) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.le\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.gt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.gt\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.ge) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.ge\\" }))
#end
## [End] Applying Key Condition **
## [End] Set query expression for key **
#set( $limit = $util.defaultIfNull($context.args.limit, 100) )
#set( $QueryRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\",
  \\"limit\\": $limit,
  \\"query\\": $modelQueryExpression,
  \\"index\\": \\"CategoryGSI\\"
} )
#if( !$util.isNull($ctx.args.sortDirection)
                  && $ctx.args.sortDirection == \\"DESC\\" )
  #set( $QueryRequest.scanIndexForward = false )
#else
  #set( $QueryRequest.scanIndexForward = true )
#end
#if( $context.args.nextToken ) #set( $QueryRequest.nextToken = $context.args.nextToken ) #end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $ctx.args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = $ctx.args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $QueryRequest.filter = $filterExpression )
  #end
#end
$util.toJson($QueryRequest)",
  "Query.testsByCategory.res.vtl": "#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#end
$util.toJson($ctx.result)",
  "Subscription.onCreateTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onCreateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onCreateTest.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onDeleteTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onDeleteTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onDeleteTest.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onUpdateTest.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onUpdateTest.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onUpdateTest.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
}
`;

exports[`should support index/primary key with sync resolvers 1`] = `
Object {
  "Mutation.createItem.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.createItem.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.createItem.preAuth.1.req.vtl": "## [Start] Merge default values and inputs. **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## [End] Merge default values and inputs. **
## [Start] Set the primary key. **
$util.qr($ctx.stash.metadata.put(\\"modelObjectKey\\", {
  \\"orderId\\": $util.dynamodb.toDynamoDB($mergedValues.orderId),
  \\"status#createdAt\\": $util.dynamodb.toDynamoDB(\\"\${mergedValues.status}#\${mergedValues.createdAt}\\")
}))
## [End] Set the primary key. **
#if( $util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) )
  $util.qr($ctx.stash.metadata.put(\\"dynamodbNameOverrideMap\\", { 'status#createdAt': \\"statusCreatedAt\\" }))
#else
  $util.qr($ctx.stash.metadata.dynamodbNameOverrideMap.put('status#createdAt', \\"statusCreatedAt\\"))
#end
$util.qr($ctx.args.input.put('status#createdAt',\\"\${mergedValues.status}#\${mergedValues.createdAt}\\"))
{}",
  "Mutation.createItem.req.vtl": "## [Start] Create Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Item\\"))
#set( $nullIndexFields = [] )
#set( $indexFields = [\\"status\\", \\"createdAt\\"] )
#foreach( $entry in $util.map.copyAndRetainAllKeys($mergedValues, $indexFields).entrySet() )
  #if( $util.isNull($entry.value) )
    $util.qr($nullIndexFields.add($entry.key))
  #end
#end
#set( $mergedValues = $util.map.copyAndRemoveAllKeys($mergedValues, $nullIndexFields) )
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": false
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - key condition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObjectKey )
  $util.qr($PutObject.put(\\"key\\", $ctx.stash.metadata.modelObjectKey))
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.createItem.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.deleteItem.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.deleteItem.preAuth.1.req.vtl": "## [Start] Merge default values and inputs. **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## [End] Merge default values and inputs. **
## [Start] Set the primary key. **
$util.qr($ctx.stash.metadata.put(\\"modelObjectKey\\", {
  \\"orderId\\": $util.dynamodb.toDynamoDB($mergedValues.orderId),
  \\"status#createdAt\\": $util.dynamodb.toDynamoDB(\\"\${mergedValues.status}#\${mergedValues.createdAt}\\")
}))
## [End] Set the primary key. **
{}",
  "Mutation.deleteItem.req.vtl": "## [Start] Delete Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.qr($DeleteRequest.put(\\"_version\\", $util.defaultIfNull($args.input[\\"_version\\"], 0)))
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.deleteItem.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.updateItem.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.updateItem.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.updateItem.preAuth.1.req.vtl": "## [Start] Merge default values and inputs. **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## [End] Merge default values and inputs. **
## [Start] Set the primary key. **
$util.qr($ctx.stash.metadata.put(\\"modelObjectKey\\", {
  \\"orderId\\": $util.dynamodb.toDynamoDB($mergedValues.orderId),
  \\"status#createdAt\\": $util.dynamodb.toDynamoDB(\\"\${mergedValues.status}#\${mergedValues.createdAt}\\")
}))
## [End] Set the primary key. **
#if( $util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) )
  $util.qr($ctx.stash.metadata.put(\\"dynamodbNameOverrideMap\\", { 'status#createdAt': \\"statusCreatedAt\\" }))
#else
  $util.qr($ctx.stash.metadata.dynamodbNameOverrideMap.put('status#createdAt', \\"statusCreatedAt\\"))
#end
$util.qr($ctx.args.input.put('status#createdAt',\\"\${mergedValues.status}#\${mergedValues.createdAt}\\"))
{}",
  "Mutation.updateItem.req.vtl": "## [Start] Mutation Update resolver. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyFields = [\\"_version\\", \\"_deleted\\", \\"_lastChangedAt\\"] )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\", \\"_version\\", \\"_deleted\\", \\"_lastChangedAt\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( !$util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) && $ctx.stash.metadata.dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $ctx.stash.metadata.dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update,
  \\"_version\\": $util.defaultIfNull($args.input[\\"_version\\"], 0)
} )
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.updateItem.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.getItem.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.getItem.preAuth.1.req.vtl": "## [Start] Set the primary key. **
$util.qr($ctx.stash.metadata.put(\\"modelObjectKey\\", {
  \\"orderId\\": $util.dynamodb.toDynamoDB($ctx.args.orderId),
  \\"status#createdAt\\": $util.dynamodb.toDynamoDB(\\"\${ctx.args.status}#\${ctx.args.createdAt}\\")
}))
## [End] Set the primary key. **
{}",
  "Query.getItem.req.vtl": "## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $expression = \\"\\" )
  #set( $expressionNames = {} )
  #set( $expressionValues = {} )
  #foreach( $item in $ctx.stash.metadata.modelObjectKey.entrySet() )
    #set( $expression = \\"$expression#keyCount$velocityCount = :valueCount$velocityCount AND \\" )
    $util.qr($expressionNames.put(\\"#keyCount$velocityCount\\", $item.key))
    $util.qr($expressionValues.put(\\":valueCount$velocityCount\\", $item.value))
  #end
  #set( $expression = $expression.replaceAll(\\"AND $\\", \\"\\") )
  #set( $query = {
  \\"expression\\": $expression,
  \\"expressionNames\\": $expressionNames,
  \\"expressionValues\\": $expressionValues
} )
#else
  #set( $query = {
  \\"expression\\": \\"id = :id\\",
  \\"expressionValues\\": {
      \\":id\\":     $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.id))
  }
} )
#end
$util.qr($GetRequest.put(\\"query\\", $query))
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  $util.qr($GetRequest.put(\\"filter\\", $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.authFilter))))
#end
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.getItem.res.vtl": "## [Start] Get Response template. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#end
#if( !$ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
  $util.toJson($ctx.result.items[0])
#else
  #if( $ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
$util.unauthorized()
  #end
  $util.toJson(null)
#end
## [End] Get Response template. **",
  "Query.itemsByCreatedAt.postAuth.1.res.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.itemsByCreatedAt.req.vtl": "## [Start] Set query expression for key **
#set( $modelQueryExpression = {} )
## [Start] Validate key arguments. **
#if( !$util.isNull($ctx.args.status) && $util.isNull($ctx.args.createdAt) )
  $util.error(\\"When providing argument 'status' you must also provide arguments createdAt\\", \\"InvalidArgumentsError\\")
#end
## [End] Validate key arguments. **
#if( !$util.isNull($ctx.args.createdAt) )
  #set( $modelQueryExpression.expression = \\"#createdAt = :createdAt\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#createdAt\\": \\"createdAt\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":createdAt\\": {
      \\"S\\": \\"$ctx.args.createdAt\\"
  }
} )
#end
## [Start] Applying Key Condition **
#if( !$util.isNull($ctx.args.status) && !$util.isNull($ctx.args.status.beginsWith) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.status.beginsWith\\" }))
#end
#if( !$util.isNull($ctx.args.status) && !$util.isNull($ctx.args.status.between) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey0\\", { \\"S\\": \\"$ctx.args.status.between[0]\\" }))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey1\\", { \\"S\\": \\"$ctx.args.status.between[1]\\" }))
#end
#if( !$util.isNull($ctx.args.status) && !$util.isNull($ctx.args.status.eq) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.status.eq\\" }))
#end
#if( !$util.isNull($ctx.args.status) && !$util.isNull($ctx.args.status.lt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.status.lt\\" }))
#end
#if( !$util.isNull($ctx.args.status) && !$util.isNull($ctx.args.status.le) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.status.le\\" }))
#end
#if( !$util.isNull($ctx.args.status) && !$util.isNull($ctx.args.status.gt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.status.gt\\" }))
#end
#if( !$util.isNull($ctx.args.status) && !$util.isNull($ctx.args.status.ge) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.status.ge\\" }))
#end
## [End] Applying Key Condition **
## [End] Set query expression for key **
#set( $limit = $util.defaultIfNull($context.args.limit, 100) )
#set( $QueryRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\",
  \\"limit\\": $limit,
  \\"query\\": $modelQueryExpression,
  \\"index\\": \\"ByCreatedAt\\"
} )
#if( !$util.isNull($ctx.args.sortDirection)
                  && $ctx.args.sortDirection == \\"DESC\\" )
  #set( $QueryRequest.scanIndexForward = false )
#else
  #set( $QueryRequest.scanIndexForward = true )
#end
#if( $context.args.nextToken ) #set( $QueryRequest.nextToken = $context.args.nextToken ) #end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $ctx.args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = $ctx.args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $QueryRequest.filter = $filterExpression )
  #end
#end
$util.toJson($QueryRequest)",
  "Query.itemsByCreatedAt.res.vtl": "#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#end
$util.toJson($ctx.result)",
  "Query.itemsByStatus.postAuth.1.res.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.itemsByStatus.req.vtl": "## [Start] Set query expression for key **
#set( $modelQueryExpression = {} )
## [Start] Validate key arguments. **
#if( !$util.isNull($ctx.args.createdAt) && $util.isNull($ctx.args.status) )
  $util.error(\\"When providing argument 'createdAt' you must also provide arguments status\\", \\"InvalidArgumentsError\\")
#end
## [End] Validate key arguments. **
#if( !$util.isNull($ctx.args.status) )
  #set( $modelQueryExpression.expression = \\"#status = :status\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#status\\": \\"status\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":status\\": {
      \\"S\\": \\"$ctx.args.status\\"
  }
} )
#end
## [Start] Applying Key Condition **
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.beginsWith) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.beginsWith\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.between) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey0\\", { \\"S\\": \\"$ctx.args.createdAt.between[0]\\" }))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey1\\", { \\"S\\": \\"$ctx.args.createdAt.between[1]\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.eq) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.eq\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.lt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.lt\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.le) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.le\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.gt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.gt\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.ge) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.ge\\" }))
#end
## [End] Applying Key Condition **
## [End] Set query expression for key **
#set( $limit = $util.defaultIfNull($context.args.limit, 100) )
#set( $QueryRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\",
  \\"limit\\": $limit,
  \\"query\\": $modelQueryExpression,
  \\"index\\": \\"ByStatus\\"
} )
#if( !$util.isNull($ctx.args.sortDirection)
                  && $ctx.args.sortDirection == \\"DESC\\" )
  #set( $QueryRequest.scanIndexForward = false )
#else
  #set( $QueryRequest.scanIndexForward = true )
#end
#if( $context.args.nextToken ) #set( $QueryRequest.nextToken = $context.args.nextToken ) #end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $ctx.args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = $ctx.args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $QueryRequest.filter = $filterExpression )
  #end
#end
$util.toJson($QueryRequest)",
  "Query.itemsByStatus.res.vtl": "#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#end
$util.toJson($ctx.result)",
  "Query.listItems.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.listItems.preAuth.1.req.vtl": "## [Start] Set query expression for key **
#if( $util.isNull($ctx.args.orderId) && !$util.isNull($ctx.args.sortDirection) )
  $util.error(\\"When providing argument 'sortDirection' you must also provide argument 'orderId'.\\", \\"InvalidArgumentsError\\")
#end
#set( $modelQueryExpression = {} )
## [Start] Validate key arguments. **
#if( !$util.isNull($ctx.args.statusCreatedAt) && $util.isNullOrBlank($ctx.args.orderId) )
  $util.error(\\"When providing argument 'statusCreatedAt' you must also provide 'orderId'.\\", \\"InvalidArgumentsError\\")
#end
#if( !$util.isNull($ctx.args.statusCreatedAt) )
  #set( $sortKeyArgumentOperations = $ctx.args.statusCreatedAt.keySet() )
  #if( $sortKeyArgumentOperations.size() > 1 )
    $util.error(\\"Argument statusCreatedAt must specify at most one key condition operation.\\", \\"InvalidArgumentsError\\")
  #end
  #foreach( $operation in $sortKeyArgumentOperations )
    #if( $operation == \\"between\\" )
      #if( $ctx.args.statusCreatedAt.between.size() != 2 )
        $util.error(\\"Argument 'statusCreatedAt.between' expects exactly two elements.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.statusCreatedAt.between[0].createdAt) && $util.isNullOrBlank($ctx.args.statusCreatedAt.between[0].status) )
        $util.error(\\"When providing argument 'statusCreatedAt.between[0].createdAt' you must also provide 'statusCreatedAt.between[0].status'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.statusCreatedAt.between[1].createdAt) && $util.isNullOrBlank($ctx.args.statusCreatedAt.between[1].status) )
        $util.error(\\"When providing argument 'statusCreatedAt.between[1].createdAt' you must also provide 'statusCreatedAt.between[1].status'.\\", \\"InvalidArgumentsError\\")
      #end
    #else
      #if( !$util.isNullOrBlank($ctx.args.statusCreatedAt.get(\\"$operation\\").createdAt) && $util.isNullOrBlank($ctx.args.statusCreatedAt.get(\\"$operation\\").status) )
        $util.error(\\"When providing argument 'statusCreatedAt.$operation.createdAt' you must also provide 'statusCreatedAt.$operation.status'.\\", \\"InvalidArgumentsError\\")
      #end
    #end
  #end
#end
## [End] Validate key arguments. **
#if( !$util.isNull($ctx.args.orderId) )
  #set( $modelQueryExpression.expression = \\"#orderId = :orderId\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#orderId\\": \\"orderId\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":orderId\\": {
      \\"S\\": \\"$ctx.args.orderId\\"
  }
} )
#end
## [Start] Applying Key Condition **
#set( $sortKeyValue = \\"\\" )
#set( $sortKeyValue2 = \\"\\" )
#if( !$util.isNull($ctx.args.statusCreatedAt) && !$util.isNull($ctx.args.statusCreatedAt.beginsWith) )
#if( !$util.isNull($ctx.args.statusCreatedAt.beginsWith.status) ) #set( $sortKeyValue = \\"$ctx.args.statusCreatedAt.beginsWith.status\\" ) #end
#if( !$util.isNull($ctx.args.statusCreatedAt.beginsWith.createdAt) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.statusCreatedAt.beginsWith.createdAt\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status#createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.statusCreatedAt) && !$util.isNull($ctx.args.statusCreatedAt.between) )
  #if( $ctx.args.statusCreatedAt.between.size() != 2 )
    $util.error(\\"Argument statusCreatedAt.between expects exactly 2 elements.\\")
  #end
#if( !$util.isNull($ctx.args.statusCreatedAt.between[0].status) ) #set( $sortKeyValue = \\"$ctx.args.statusCreatedAt.between[0].status\\" ) #end
#if( !$util.isNull($ctx.args.statusCreatedAt.between[0].createdAt) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.statusCreatedAt.between[0].createdAt\\" ) #end
#if( !$util.isNull($ctx.args.statusCreatedAt.between[1].status) ) #set( $sortKeyValue2 = \\"$ctx.args.statusCreatedAt.between[1].status\\" ) #end
#if( !$util.isNull($ctx.args.statusCreatedAt.between[1].createdAt) ) #set( $sortKeyValue2 = \\"$sortKeyValue2#$ctx.args.statusCreatedAt.between[1].createdAt\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status#createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey0\\", { \\"S\\": \\"$sortKeyValue\\" }))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey1\\", { \\"S\\": \\"$sortKeyValue2\\" }))
#end
#if( !$util.isNull($ctx.args.statusCreatedAt) && !$util.isNull($ctx.args.statusCreatedAt.eq) )
#if( !$util.isNull($ctx.args.statusCreatedAt.eq.status) ) #set( $sortKeyValue = \\"$ctx.args.statusCreatedAt.eq.status\\" ) #end
#if( !$util.isNull($ctx.args.statusCreatedAt.eq.createdAt) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.statusCreatedAt.eq.createdAt\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status#createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.statusCreatedAt) && !$util.isNull($ctx.args.statusCreatedAt.lt) )
#if( !$util.isNull($ctx.args.statusCreatedAt.lt.status) ) #set( $sortKeyValue = \\"$ctx.args.statusCreatedAt.lt.status\\" ) #end
#if( !$util.isNull($ctx.args.statusCreatedAt.lt.createdAt) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.statusCreatedAt.lt.createdAt\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status#createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.statusCreatedAt) && !$util.isNull($ctx.args.statusCreatedAt.le) )
#if( !$util.isNull($ctx.args.statusCreatedAt.le.status) ) #set( $sortKeyValue = \\"$ctx.args.statusCreatedAt.le.status\\" ) #end
#if( !$util.isNull($ctx.args.statusCreatedAt.le.createdAt) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.statusCreatedAt.le.createdAt\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status#createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.statusCreatedAt) && !$util.isNull($ctx.args.statusCreatedAt.gt) )
#if( !$util.isNull($ctx.args.statusCreatedAt.gt.status) ) #set( $sortKeyValue = \\"$ctx.args.statusCreatedAt.gt.status\\" ) #end
#if( !$util.isNull($ctx.args.statusCreatedAt.gt.createdAt) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.statusCreatedAt.gt.createdAt\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status#createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.statusCreatedAt) && !$util.isNull($ctx.args.statusCreatedAt.ge) )
#if( !$util.isNull($ctx.args.statusCreatedAt.ge.status) ) #set( $sortKeyValue = \\"$ctx.args.statusCreatedAt.ge.status\\" ) #end
#if( !$util.isNull($ctx.args.statusCreatedAt.ge.createdAt) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.statusCreatedAt.ge.createdAt\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status#createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end


## [End] Applying Key Condition **
## [End] Set query expression for key **
$util.qr($ctx.stash.put(\\"modelQueryExpression\\", $modelQueryExpression))
{}",
  "Query.listItems.req.vtl": "## [Start] List Request. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $limit = $util.defaultIfNull($args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $args.nextToken )
  #set( $ListRequest.nextToken = $args.nextToken )
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQueryExpression) && !$util.isNullOrEmpty($ctx.stash.modelQueryExpression.expression) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $ctx.stash.modelQueryExpression))
  #if( !$util.isNull($args.sortDirection) && $args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.listItems.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.syncItems.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.syncItems.preAuth.1.req.vtl": "## [Start] Set map initialization for @key **
#set( $index = \\"\\" )
#set( $scan = true )
#set( $filterMap = {} )
#set( $QueryMap = {} )
#set( $PkMap = {} )
#set( $SkMap = {} )
#set( $filterArgsMap = {} )
#if( $ctx.stash.QueryRequest )
  #return
#end
#set( $queryRequestVariables = {} )
## [End] Set map initialization for @key **
## [Start] Set query expression for @key **
$util.qr($QueryMap.put('status+createdAt' , 'ByStatus'))
$util.qr($PkMap.put('status' , 'ByStatus'))
$util.qr($SkMap.put(\\"ByStatus\\", [\\"createdAt\\"]))
## [End] Set query expression for @key **
## [Start] Set query expression for @key **
$util.qr($QueryMap.put('createdAt+status' , 'ByCreatedAt'))
$util.qr($PkMap.put('createdAt' , 'ByCreatedAt'))
$util.qr($SkMap.put(\\"ByCreatedAt\\", [\\"status\\"]))
## [End] Set query expression for @key **
## [Start] Set query expression for @key **
#set( $filterArgsMap = $ctx.args.filter.get(\\"and\\") )
#set( $isLastSyncInDeltaTTLWindow = false )
#set( $minLastSync = $util.time.nowEpochMilliSeconds() - $ctx.stash.deltaSyncTableTtl * 60 * 1000 )
#if( !$util.isNull($ctx.args.lastSync) && $ctx.args.lastSync != 0 && $minLastSync <= $ctx.args.lastSync )
  #set( $isLastSyncInDeltaTTLWindow = true )
#end
#if( !$util.isNullOrEmpty($filterArgsMap) && !$isLastSyncInDeltaTTLWindow )
  #set( $json = $filterArgsMap )
  #foreach( $item in $json )
    #set( $ind = $foreach.index )
    #foreach( $entry in $item.entrySet() )
      #if( $ind == 0 && !$util.isNullOrEmpty($entry.value.eq) && !$util.isNullOrEmpty($PkMap.get($entry.key)) )
        #set( $pk = $entry.key )
        #set( $scan = false )
        #set( $queryRequestVariables.partitionKey = $pk )
        #set( $queryRequestVariables.sortKeys = $SkMap.get($PkMap.get($pk)) )
        #set( $queryRequestVariables.partitionKeyFilter = {} )
        $util.qr($queryRequestVariables.partitionKeyFilter.put($pk, {'eq': $entry.value.eq}))
        $util.qr($ctx.args.put($pk,$entry.value.eq))
        #set( $index = $PkMap.get($pk) )
      #end
      #if( $ind == 1 && !$util.isNullOrEmpty($pk) && !$util.isNullOrEmpty($QueryMap.get(\\"\${pk}+$entry.key\\")) )
        #set( $sk = $entry.key )
        $util.qr($ctx.args.put($sk,$entry.value))
        #set( $index = $QueryMap.get(\\"\${pk}+$sk\\") )
      #else
        #if( $ind > 0 )
          $util.qr($filterMap.put($entry.key,$entry.value))
        #end
      #end
    #end
  #end
#else
  #set( $filterMap = $ctx.args.filter )
#end
## [End] Set query expression for @key **
## [Start] Set Primary Key initialization @key **
#set( $modelQueryExpression = {} )
#if( !$util.isNull($pk) )
  #set( $modelQueryExpression.expression = \\"#pk = :pk\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#pk\\": \\"$pk\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":pk\\": $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($pk)))
} )
#end
## [End] Set Primary Key initialization @key **
## [Start] Applying Key Condition **
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).beginsWith) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).beginsWith))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).between) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).between[0]))))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).between[1]))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).eq) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).eq))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).lt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).lt))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).le) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).le))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).gt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).gt))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).ge) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).ge))))
#end
## [End] Applying Key Condition **
## [Start]  Set query expression for @key **
#if( !$scan )
  #set( $limit = $util.defaultIfNull($context.args.limit, 100) )
  #set( $ctx.stash.QueryRequestVariables = $queryRequestVariables )
  #set( $ctx.stash.QueryRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Sync\\",
  \\"limit\\": $limit,
  \\"lastSync\\": $util.defaultIfNull($ctx.args.lastSync, null),
  \\"query\\": $modelQueryExpression
} )
  #if( !$util.isNull($ctx.args.sortDirection)
                    && $ctx.args.sortDirection == \\"DESC\\" )
    #set( $ctx.stash.QueryRequest.scanIndexForward = false )
  #else
    #set( $ctx.stash.QueryRequest.scanIndexForward = true )
  #end
#if( $context.args.nextToken ) #set( $ctx.stash.QueryRequest.nextToken = $context.args.nextToken ) #end
  #if( !$util.isNullOrEmpty($filterMap) && $util.toJson($filterMap) != $util.toJson({}) )
    #set( $ctx.stash.QueryRequest.filter = $filterMap )
  #end
  #if( $index != \\"dbTable\\" )
    #set( $ctx.stash.QueryRequest.index = $index )
  #end
#end
$util.toJson({})
## [End]  Set query expression for @key **
",
  "Query.syncItems.preAuth.2.req.vtl": "## [Start] Set map initialization for @key **
#set( $index = \\"\\" )
#set( $scan = true )
#set( $filterMap = {} )
#set( $QueryMap = {} )
#set( $PkMap = {} )
#set( $SkMap = {} )
#set( $filterArgsMap = {} )
#if( $ctx.stash.QueryRequest )
  #return
#end
#set( $queryRequestVariables = {} )
## [End] Set map initialization for @key **
## [Start] Set query expression for @key **
$util.qr($QueryMap.put('orderId+status+createdAt' , 'dbTable'))
$util.qr($PkMap.put('orderId' , 'dbTable'))
$util.qr($SkMap.put(\\"dbTable\\", [\\"status\\", \\"createdAt\\"]))
## [End] Set query expression for @key **
## [Start] Set query expression for @key **
#set( $filterArgsMap = $ctx.args.filter.get(\\"and\\") )
#set( $isLastSyncInDeltaTTLWindow = false )
#set( $minLastSync = $util.time.nowEpochMilliSeconds() - $ctx.stash.deltaSyncTableTtl * 60 * 1000 )
#if( !$util.isNull($ctx.args.lastSync) && $ctx.args.lastSync != 0 && $minLastSync <= $ctx.args.lastSync )
  #set( $isLastSyncInDeltaTTLWindow = true )
#end
#if( !$util.isNullOrEmpty($filterArgsMap) && !$isLastSyncInDeltaTTLWindow )
  #set( $json = $filterArgsMap )
  #foreach( $item in $json )
    #set( $ind = $foreach.index )
    #foreach( $entry in $item.entrySet() )
      #if( $ind == 0 && !$util.isNullOrEmpty($entry.value.eq) && !$util.isNullOrEmpty($PkMap.get($entry.key)) )
        #set( $pk = $entry.key )
        #set( $scan = false )
        #set( $queryRequestVariables.partitionKey = $pk )
        #set( $queryRequestVariables.sortKeys = $SkMap.get($PkMap.get($pk)) )
        #set( $queryRequestVariables.partitionKeyFilter = {} )
        $util.qr($queryRequestVariables.partitionKeyFilter.put($pk, {'eq': $entry.value.eq}))
        $util.qr($ctx.args.put($pk,$entry.value.eq))
        #set( $index = $PkMap.get($pk) )
      #end
      #if( $ind == 1 && !$util.isNullOrEmpty($pk) && !$util.isNullOrEmpty($QueryMap.get(\\"\${pk}+$entry.key\\")) )
        #set( $sk = $entry.key )
        $util.qr($ctx.args.put($sk,$entry.value))
        #set( $index = $QueryMap.get(\\"\${pk}+$sk\\") )
      #else
        #if( $ind > 0 )
          $util.qr($filterMap.put($entry.key,$entry.value))
        #end
      #end
    #end
  #end
#else
  #set( $filterMap = $ctx.args.filter )
#end
## [End] Set query expression for @key **
## [Start] Set Primary Key initialization @key **
#set( $modelQueryExpression = {} )
#if( !$util.isNull($pk) )
  #set( $modelQueryExpression.expression = \\"#pk = :pk\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#pk\\": \\"$pk\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":pk\\": $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($pk)))
} )
#end
## [End] Set Primary Key initialization @key **
## [Start] Applying Key Condition **
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).beginsWith) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).beginsWith))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).between) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).between[0]))))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).between[1]))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).eq) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).eq))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).lt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).lt))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).le) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).le))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).gt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).gt))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).ge) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).ge))))
#end
## [End] Applying Key Condition **
## [Start]  Set query expression for @key **
#if( !$scan )
  #set( $limit = $util.defaultIfNull($context.args.limit, 100) )
  #set( $ctx.stash.QueryRequestVariables = $queryRequestVariables )
  #set( $ctx.stash.QueryRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Sync\\",
  \\"limit\\": $limit,
  \\"lastSync\\": $util.defaultIfNull($ctx.args.lastSync, null),
  \\"query\\": $modelQueryExpression
} )
  #if( !$util.isNull($ctx.args.sortDirection)
                    && $ctx.args.sortDirection == \\"DESC\\" )
    #set( $ctx.stash.QueryRequest.scanIndexForward = false )
  #else
    #set( $ctx.stash.QueryRequest.scanIndexForward = true )
  #end
#if( $context.args.nextToken ) #set( $ctx.stash.QueryRequest.nextToken = $context.args.nextToken ) #end
  #if( !$util.isNullOrEmpty($filterMap) && $util.toJson($filterMap) != $util.toJson({}) )
    #set( $ctx.stash.QueryRequest.filter = $filterMap )
  #end
  #if( $index != \\"dbTable\\" )
    #set( $ctx.stash.QueryRequest.index = $index )
  #end
#end
$util.toJson({})
## [End]  Set query expression for @key **
",
  "Query.syncItems.req.vtl": "## [Start] Sync Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $queryFilterContainsAuthField = false )
#set( $authFilterContainsSortKey = false )
#set( $useScan = true )
#if( $util.isNullOrEmpty($ctx.stash.authFilter) && $ctx.stash.QueryRequest )
  #set( $useScan = false )
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( $ctx.stash.QueryRequestVariables.partitionKey )
    #foreach( $filterItem in $ctx.stash.authFilter.or )
      #if( $filterItem.get($ctx.stash.QueryRequestVariables.partitionKey) )
        #set( $queryFilterContainsAuthField = true )
      #end
    #end
    #if( !$queryFilterContainsAuthField )
      #foreach( $filterItem in $ctx.stash.authFilter.or )
        #foreach( $sortKey in $ctx.stash.QueryRequestVariables.sortKeys )
          #if( $filterItem.get($sortKey) )
            #set( $authFilterContainsSortKey = true )
          #end
        #end
      #end
      #if( !$authFilterContainsSortKey )
        #if( !$util.isNullOrEmpty($ctx.stash.QueryRequest.filter) )
          #set( $ctx.stash.QueryRequest.filter = {
  \\"and\\":   [$ctx.stash.QueryRequest.filter, $ctx.stash.authFilter]
} )
        #else
          #set( $ctx.stash.QueryRequest.filter = $ctx.stash.authFilter )
        #end
        #set( $useScan = false )
      #end
    #else
      #foreach( $filterItem in $ctx.stash.authFilter.or )
        #if( $util.toJson($filterItem) == $util.toJson($ctx.stash.QueryRequestVariables.partitionKeyFilter) )
          #set( $useScan = false )
        #end
      #end
    #end
  #end
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $filter = $filterExpression )
  #end
#end
#if( !$useScan )
  #if( $ctx.stash.QueryRequest.filter )
    #set( $ctx.stash.QueryRequest.filter = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.QueryRequest.filter)) )
  #end
  $util.toJson($ctx.stash.QueryRequest)
#else
{
      \\"version\\": \\"2018-05-29\\",
      \\"operation\\": \\"Sync\\",
      \\"filter\\":     #if( $filter )
$util.toJson($filter)
    #else
null
    #end,
      \\"limit\\": $util.defaultIfNull($args.limit, 100),
      \\"lastSync\\": $util.toJson($util.defaultIfNull($args.lastSync, null)),
      \\"nextToken\\": $util.toJson($util.defaultIfNull($args.nextToken, null))
  }
#end
## [End] Sync Request template. **",
  "Query.syncItems.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Subscription.onCreateItem.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onCreateItem.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onCreateItem.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onDeleteItem.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onDeleteItem.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onDeleteItem.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onUpdateItem.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onUpdateItem.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onUpdateItem.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
}
`;

exports[`sync query resolver renders with deltaSyncTableTTL override 1`] = `
Object {
  "Mutation.createSong.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.createSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.createSong.req.vtl": "## [Start] Create Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Song\\"))
#set( $nullIndexFields = [] )
#set( $indexFields = [\\"genre\\"] )
#foreach( $entry in $util.map.copyAndRetainAllKeys($mergedValues, $indexFields).entrySet() )
  #if( $util.isNull($entry.value) )
    $util.qr($nullIndexFields.add($entry.key))
  #end
#end
#set( $mergedValues = $util.map.copyAndRemoveAllKeys($mergedValues, $nullIndexFields) )
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": false
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - key condition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObjectKey )
  $util.qr($PutObject.put(\\"key\\", $ctx.stash.metadata.modelObjectKey))
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.createSong.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.deleteSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.deleteSong.req.vtl": "## [Start] Delete Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.qr($DeleteRequest.put(\\"_version\\", $util.defaultIfNull($args.input[\\"_version\\"], 0)))
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.deleteSong.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.updateSong.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.updateSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.updateSong.req.vtl": "## [Start] Mutation Update resolver. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyFields = [\\"_version\\", \\"_deleted\\", \\"_lastChangedAt\\"] )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\", \\"_version\\", \\"_deleted\\", \\"_lastChangedAt\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( !$util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) && $ctx.stash.metadata.dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $ctx.stash.metadata.dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update,
  \\"_version\\": $util.defaultIfNull($args.input[\\"_version\\"], 0)
} )
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.updateSong.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.getSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.getSong.req.vtl": "## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $expression = \\"\\" )
  #set( $expressionNames = {} )
  #set( $expressionValues = {} )
  #foreach( $item in $ctx.stash.metadata.modelObjectKey.entrySet() )
    #set( $expression = \\"$expression#keyCount$velocityCount = :valueCount$velocityCount AND \\" )
    $util.qr($expressionNames.put(\\"#keyCount$velocityCount\\", $item.key))
    $util.qr($expressionValues.put(\\":valueCount$velocityCount\\", $item.value))
  #end
  #set( $expression = $expression.replaceAll(\\"AND $\\", \\"\\") )
  #set( $query = {
  \\"expression\\": $expression,
  \\"expressionNames\\": $expressionNames,
  \\"expressionValues\\": $expressionValues
} )
#else
  #set( $query = {
  \\"expression\\": \\"id = :id\\",
  \\"expressionValues\\": {
      \\":id\\":     $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.id))
  }
} )
#end
$util.qr($GetRequest.put(\\"query\\", $query))
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  $util.qr($GetRequest.put(\\"filter\\", $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.authFilter))))
#end
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.getSong.res.vtl": "## [Start] Get Response template. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#end
#if( !$ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
  $util.toJson($ctx.result.items[0])
#else
  #if( $ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
$util.unauthorized()
  #end
  $util.toJson(null)
#end
## [End] Get Response template. **",
  "Query.listSongs.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.listSongs.req.vtl": "## [Start] List Request. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $limit = $util.defaultIfNull($args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $args.nextToken )
  #set( $ListRequest.nextToken = $args.nextToken )
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQueryExpression) && !$util.isNullOrEmpty($ctx.stash.modelQueryExpression.expression) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $ctx.stash.modelQueryExpression))
  #if( !$util.isNull($args.sortDirection) && $args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.listSongs.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.songInfoByGenre.postAuth.1.res.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.songInfoByGenre.req.vtl": "## [Start] Set query expression for key **
#if( !$util.isNull($ctx.args.sortDirection) )
  $util.error(\\"sortDirection is not supported for List operations without a Sort key defined.\\", \\"InvalidArgumentsError\\")
#end
#set( $modelQueryExpression = {} )
#if( !$util.isNull($ctx.args.genre) )
  #set( $modelQueryExpression.expression = \\"#genre = :genre\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#genre\\": \\"genre\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":genre\\": {
      \\"S\\": \\"$ctx.args.genre\\"
  }
} )
#end
## [End] Set query expression for key **
#set( $limit = $util.defaultIfNull($context.args.limit, 100) )
#set( $QueryRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\",
  \\"limit\\": $limit,
  \\"query\\": $modelQueryExpression,
  \\"index\\": \\"byGenre\\"
} )
#if( !$util.isNull($ctx.args.sortDirection)
                  && $ctx.args.sortDirection == \\"DESC\\" )
  #set( $QueryRequest.scanIndexForward = false )
#else
  #set( $QueryRequest.scanIndexForward = true )
#end
#if( $context.args.nextToken ) #set( $QueryRequest.nextToken = $context.args.nextToken ) #end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $ctx.args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = $ctx.args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $QueryRequest.filter = $filterExpression )
  #end
#end
$util.toJson($QueryRequest)",
  "Query.songInfoByGenre.res.vtl": "#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#end
$util.toJson($ctx.result)",
  "Query.syncSongs.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.syncSongs.preAuth.1.req.vtl": "## [Start] Set map initialization for @key **
#set( $index = \\"\\" )
#set( $scan = true )
#set( $filterMap = {} )
#set( $QueryMap = {} )
#set( $PkMap = {} )
#set( $SkMap = {} )
#set( $filterArgsMap = {} )
#if( $ctx.stash.QueryRequest )
  #return
#end
#set( $queryRequestVariables = {} )
## [End] Set map initialization for @key **
## [Start] Set query expression for @key **
$util.qr($QueryMap.put('genre' , 'byGenre'))
$util.qr($PkMap.put('genre' , 'byGenre'))
$util.qr($SkMap.put(\\"byGenre\\", []))
## [End] Set query expression for @key **
## [Start] Set query expression for @key **
#set( $filterArgsMap = $ctx.args.filter.get(\\"and\\") )
#set( $isLastSyncInDeltaTTLWindow = false )
#set( $minLastSync = $util.time.nowEpochMilliSeconds() - $ctx.stash.deltaSyncTableTtl * 60 * 1000 )
#if( !$util.isNull($ctx.args.lastSync) && $ctx.args.lastSync != 0 && $minLastSync <= $ctx.args.lastSync )
  #set( $isLastSyncInDeltaTTLWindow = true )
#end
#if( !$util.isNullOrEmpty($filterArgsMap) && !$isLastSyncInDeltaTTLWindow )
  #set( $json = $filterArgsMap )
  #foreach( $item in $json )
    #set( $ind = $foreach.index )
    #foreach( $entry in $item.entrySet() )
      #if( $ind == 0 && !$util.isNullOrEmpty($entry.value.eq) && !$util.isNullOrEmpty($PkMap.get($entry.key)) )
        #set( $pk = $entry.key )
        #set( $scan = false )
        #set( $queryRequestVariables.partitionKey = $pk )
        #set( $queryRequestVariables.sortKeys = $SkMap.get($PkMap.get($pk)) )
        #set( $queryRequestVariables.partitionKeyFilter = {} )
        $util.qr($queryRequestVariables.partitionKeyFilter.put($pk, {'eq': $entry.value.eq}))
        $util.qr($ctx.args.put($pk,$entry.value.eq))
        #set( $index = $PkMap.get($pk) )
      #end
      #if( $ind == 1 && !$util.isNullOrEmpty($pk) && !$util.isNullOrEmpty($QueryMap.get(\\"\${pk}+$entry.key\\")) )
        #set( $sk = $entry.key )
        $util.qr($ctx.args.put($sk,$entry.value))
        #set( $index = $QueryMap.get(\\"\${pk}+$sk\\") )
      #else
        #if( $ind > 0 )
          $util.qr($filterMap.put($entry.key,$entry.value))
        #end
      #end
    #end
  #end
#else
  #set( $filterMap = $ctx.args.filter )
#end
## [End] Set query expression for @key **
## [Start] Set Primary Key initialization @key **
#set( $modelQueryExpression = {} )
#if( !$util.isNull($pk) )
  #set( $modelQueryExpression.expression = \\"#pk = :pk\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#pk\\": \\"$pk\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":pk\\": $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($pk)))
} )
#end
## [End] Set Primary Key initialization @key **
## [Start] Applying Key Condition **
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).beginsWith) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).beginsWith))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).between) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).between[0]))))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).between[1]))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).eq) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).eq))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).lt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).lt))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).le) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).le))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).gt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).gt))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).ge) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).ge))))
#end
## [End] Applying Key Condition **
## [Start]  Set query expression for @key **
#if( !$scan )
  #set( $limit = $util.defaultIfNull($context.args.limit, 100) )
  #set( $ctx.stash.QueryRequestVariables = $queryRequestVariables )
  #set( $ctx.stash.QueryRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Sync\\",
  \\"limit\\": $limit,
  \\"lastSync\\": $util.defaultIfNull($ctx.args.lastSync, null),
  \\"query\\": $modelQueryExpression
} )
  #if( !$util.isNull($ctx.args.sortDirection)
                    && $ctx.args.sortDirection == \\"DESC\\" )
    #set( $ctx.stash.QueryRequest.scanIndexForward = false )
  #else
    #set( $ctx.stash.QueryRequest.scanIndexForward = true )
  #end
#if( $context.args.nextToken ) #set( $ctx.stash.QueryRequest.nextToken = $context.args.nextToken ) #end
  #if( !$util.isNullOrEmpty($filterMap) && $util.toJson($filterMap) != $util.toJson({}) )
    #set( $ctx.stash.QueryRequest.filter = $filterMap )
  #end
  #if( $index != \\"dbTable\\" )
    #set( $ctx.stash.QueryRequest.index = $index )
  #end
#end
$util.toJson({})
## [End]  Set query expression for @key **
",
  "Query.syncSongs.req.vtl": "## [Start] Sync Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $queryFilterContainsAuthField = false )
#set( $authFilterContainsSortKey = false )
#set( $useScan = true )
#if( $util.isNullOrEmpty($ctx.stash.authFilter) && $ctx.stash.QueryRequest )
  #set( $useScan = false )
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( $ctx.stash.QueryRequestVariables.partitionKey )
    #foreach( $filterItem in $ctx.stash.authFilter.or )
      #if( $filterItem.get($ctx.stash.QueryRequestVariables.partitionKey) )
        #set( $queryFilterContainsAuthField = true )
      #end
    #end
    #if( !$queryFilterContainsAuthField )
      #foreach( $filterItem in $ctx.stash.authFilter.or )
        #foreach( $sortKey in $ctx.stash.QueryRequestVariables.sortKeys )
          #if( $filterItem.get($sortKey) )
            #set( $authFilterContainsSortKey = true )
          #end
        #end
      #end
      #if( !$authFilterContainsSortKey )
        #if( !$util.isNullOrEmpty($ctx.stash.QueryRequest.filter) )
          #set( $ctx.stash.QueryRequest.filter = {
  \\"and\\":   [$ctx.stash.QueryRequest.filter, $ctx.stash.authFilter]
} )
        #else
          #set( $ctx.stash.QueryRequest.filter = $ctx.stash.authFilter )
        #end
        #set( $useScan = false )
      #end
    #else
      #foreach( $filterItem in $ctx.stash.authFilter.or )
        #if( $util.toJson($filterItem) == $util.toJson($ctx.stash.QueryRequestVariables.partitionKeyFilter) )
          #set( $useScan = false )
        #end
      #end
    #end
  #end
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $filter = $filterExpression )
  #end
#end
#if( !$useScan )
  #if( $ctx.stash.QueryRequest.filter )
    #set( $ctx.stash.QueryRequest.filter = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.QueryRequest.filter)) )
  #end
  $util.toJson($ctx.stash.QueryRequest)
#else
{
      \\"version\\": \\"2018-05-29\\",
      \\"operation\\": \\"Sync\\",
      \\"filter\\":     #if( $filter )
$util.toJson($filter)
    #else
null
    #end,
      \\"limit\\": $util.defaultIfNull($args.limit, 100),
      \\"lastSync\\": $util.toJson($util.defaultIfNull($args.lastSync, null)),
      \\"nextToken\\": $util.toJson($util.defaultIfNull($args.nextToken, null))
  }
#end
## [End] Sync Request template. **",
  "Query.syncSongs.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Subscription.onCreateSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onCreateSong.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onCreateSong.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onDeleteSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onDeleteSong.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onDeleteSong.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onUpdateSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onUpdateSong.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onUpdateSong.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
}
`;

exports[`sync query resolver renders without overrides 1`] = `
Object {
  "Mutation.createSong.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.createSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.createSong.req.vtl": "## [Start] Create Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Song\\"))
#set( $nullIndexFields = [] )
#set( $indexFields = [\\"genre\\"] )
#foreach( $entry in $util.map.copyAndRetainAllKeys($mergedValues, $indexFields).entrySet() )
  #if( $util.isNull($entry.value) )
    $util.qr($nullIndexFields.add($entry.key))
  #end
#end
#set( $mergedValues = $util.map.copyAndRemoveAllKeys($mergedValues, $nullIndexFields) )
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": false
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - key condition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObjectKey )
  $util.qr($PutObject.put(\\"key\\", $ctx.stash.metadata.modelObjectKey))
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.createSong.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.deleteSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.deleteSong.req.vtl": "## [Start] Delete Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.qr($DeleteRequest.put(\\"_version\\", $util.defaultIfNull($args.input[\\"_version\\"], 0)))
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.deleteSong.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.updateSong.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.updateSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.updateSong.req.vtl": "## [Start] Mutation Update resolver. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyFields = [\\"_version\\", \\"_deleted\\", \\"_lastChangedAt\\"] )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\", \\"_version\\", \\"_deleted\\", \\"_lastChangedAt\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( !$util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) && $ctx.stash.metadata.dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $ctx.stash.metadata.dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update,
  \\"_version\\": $util.defaultIfNull($args.input[\\"_version\\"], 0)
} )
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.updateSong.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.getSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.getSong.req.vtl": "## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $expression = \\"\\" )
  #set( $expressionNames = {} )
  #set( $expressionValues = {} )
  #foreach( $item in $ctx.stash.metadata.modelObjectKey.entrySet() )
    #set( $expression = \\"$expression#keyCount$velocityCount = :valueCount$velocityCount AND \\" )
    $util.qr($expressionNames.put(\\"#keyCount$velocityCount\\", $item.key))
    $util.qr($expressionValues.put(\\":valueCount$velocityCount\\", $item.value))
  #end
  #set( $expression = $expression.replaceAll(\\"AND $\\", \\"\\") )
  #set( $query = {
  \\"expression\\": $expression,
  \\"expressionNames\\": $expressionNames,
  \\"expressionValues\\": $expressionValues
} )
#else
  #set( $query = {
  \\"expression\\": \\"id = :id\\",
  \\"expressionValues\\": {
      \\":id\\":     $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.id))
  }
} )
#end
$util.qr($GetRequest.put(\\"query\\", $query))
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  $util.qr($GetRequest.put(\\"filter\\", $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.authFilter))))
#end
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.getSong.res.vtl": "## [Start] Get Response template. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#end
#if( !$ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
  $util.toJson($ctx.result.items[0])
#else
  #if( $ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
$util.unauthorized()
  #end
  $util.toJson(null)
#end
## [End] Get Response template. **",
  "Query.listSongs.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.listSongs.req.vtl": "## [Start] List Request. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $limit = $util.defaultIfNull($args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $args.nextToken )
  #set( $ListRequest.nextToken = $args.nextToken )
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQueryExpression) && !$util.isNullOrEmpty($ctx.stash.modelQueryExpression.expression) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $ctx.stash.modelQueryExpression))
  #if( !$util.isNull($args.sortDirection) && $args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.listSongs.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.songInfoByGenre.postAuth.1.res.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.songInfoByGenre.req.vtl": "## [Start] Set query expression for key **
#if( !$util.isNull($ctx.args.sortDirection) )
  $util.error(\\"sortDirection is not supported for List operations without a Sort key defined.\\", \\"InvalidArgumentsError\\")
#end
#set( $modelQueryExpression = {} )
#if( !$util.isNull($ctx.args.genre) )
  #set( $modelQueryExpression.expression = \\"#genre = :genre\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#genre\\": \\"genre\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":genre\\": {
      \\"S\\": \\"$ctx.args.genre\\"
  }
} )
#end
## [End] Set query expression for key **
#set( $limit = $util.defaultIfNull($context.args.limit, 100) )
#set( $QueryRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\",
  \\"limit\\": $limit,
  \\"query\\": $modelQueryExpression,
  \\"index\\": \\"byGenre\\"
} )
#if( !$util.isNull($ctx.args.sortDirection)
                  && $ctx.args.sortDirection == \\"DESC\\" )
  #set( $QueryRequest.scanIndexForward = false )
#else
  #set( $QueryRequest.scanIndexForward = true )
#end
#if( $context.args.nextToken ) #set( $QueryRequest.nextToken = $context.args.nextToken ) #end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $ctx.args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = $ctx.args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $QueryRequest.filter = $filterExpression )
  #end
#end
$util.toJson($QueryRequest)",
  "Query.songInfoByGenre.res.vtl": "#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#end
$util.toJson($ctx.result)",
  "Query.syncSongs.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.syncSongs.preAuth.1.req.vtl": "## [Start] Set map initialization for @key **
#set( $index = \\"\\" )
#set( $scan = true )
#set( $filterMap = {} )
#set( $QueryMap = {} )
#set( $PkMap = {} )
#set( $SkMap = {} )
#set( $filterArgsMap = {} )
#if( $ctx.stash.QueryRequest )
  #return
#end
#set( $queryRequestVariables = {} )
## [End] Set map initialization for @key **
## [Start] Set query expression for @key **
$util.qr($QueryMap.put('genre' , 'byGenre'))
$util.qr($PkMap.put('genre' , 'byGenre'))
$util.qr($SkMap.put(\\"byGenre\\", []))
## [End] Set query expression for @key **
## [Start] Set query expression for @key **
#set( $filterArgsMap = $ctx.args.filter.get(\\"and\\") )
#set( $isLastSyncInDeltaTTLWindow = false )
#set( $minLastSync = $util.time.nowEpochMilliSeconds() - $ctx.stash.deltaSyncTableTtl * 60 * 1000 )
#if( !$util.isNull($ctx.args.lastSync) && $ctx.args.lastSync != 0 && $minLastSync <= $ctx.args.lastSync )
  #set( $isLastSyncInDeltaTTLWindow = true )
#end
#if( !$util.isNullOrEmpty($filterArgsMap) && !$isLastSyncInDeltaTTLWindow )
  #set( $json = $filterArgsMap )
  #foreach( $item in $json )
    #set( $ind = $foreach.index )
    #foreach( $entry in $item.entrySet() )
      #if( $ind == 0 && !$util.isNullOrEmpty($entry.value.eq) && !$util.isNullOrEmpty($PkMap.get($entry.key)) )
        #set( $pk = $entry.key )
        #set( $scan = false )
        #set( $queryRequestVariables.partitionKey = $pk )
        #set( $queryRequestVariables.sortKeys = $SkMap.get($PkMap.get($pk)) )
        #set( $queryRequestVariables.partitionKeyFilter = {} )
        $util.qr($queryRequestVariables.partitionKeyFilter.put($pk, {'eq': $entry.value.eq}))
        $util.qr($ctx.args.put($pk,$entry.value.eq))
        #set( $index = $PkMap.get($pk) )
      #end
      #if( $ind == 1 && !$util.isNullOrEmpty($pk) && !$util.isNullOrEmpty($QueryMap.get(\\"\${pk}+$entry.key\\")) )
        #set( $sk = $entry.key )
        $util.qr($ctx.args.put($sk,$entry.value))
        #set( $index = $QueryMap.get(\\"\${pk}+$sk\\") )
      #else
        #if( $ind > 0 )
          $util.qr($filterMap.put($entry.key,$entry.value))
        #end
      #end
    #end
  #end
#else
  #set( $filterMap = $ctx.args.filter )
#end
## [End] Set query expression for @key **
## [Start] Set Primary Key initialization @key **
#set( $modelQueryExpression = {} )
#if( !$util.isNull($pk) )
  #set( $modelQueryExpression.expression = \\"#pk = :pk\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#pk\\": \\"$pk\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":pk\\": $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($pk)))
} )
#end
## [End] Set Primary Key initialization @key **
## [Start] Applying Key Condition **
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).beginsWith) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).beginsWith))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).between) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).between[0]))))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).between[1]))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).eq) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).eq))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).lt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).lt))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).le) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).le))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).gt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).gt))))
#end
#if( !$util.isNull($ctx.args.get($sk)) && !$util.isNull($ctx.args.get($sk).ge) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", $sk))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.get($sk).ge))))
#end
## [End] Applying Key Condition **
## [Start]  Set query expression for @key **
#if( !$scan )
  #set( $limit = $util.defaultIfNull($context.args.limit, 100) )
  #set( $ctx.stash.QueryRequestVariables = $queryRequestVariables )
  #set( $ctx.stash.QueryRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Sync\\",
  \\"limit\\": $limit,
  \\"lastSync\\": $util.defaultIfNull($ctx.args.lastSync, null),
  \\"query\\": $modelQueryExpression
} )
  #if( !$util.isNull($ctx.args.sortDirection)
                    && $ctx.args.sortDirection == \\"DESC\\" )
    #set( $ctx.stash.QueryRequest.scanIndexForward = false )
  #else
    #set( $ctx.stash.QueryRequest.scanIndexForward = true )
  #end
#if( $context.args.nextToken ) #set( $ctx.stash.QueryRequest.nextToken = $context.args.nextToken ) #end
  #if( !$util.isNullOrEmpty($filterMap) && $util.toJson($filterMap) != $util.toJson({}) )
    #set( $ctx.stash.QueryRequest.filter = $filterMap )
  #end
  #if( $index != \\"dbTable\\" )
    #set( $ctx.stash.QueryRequest.index = $index )
  #end
#end
$util.toJson({})
## [End]  Set query expression for @key **
",
  "Query.syncSongs.req.vtl": "## [Start] Sync Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $queryFilterContainsAuthField = false )
#set( $authFilterContainsSortKey = false )
#set( $useScan = true )
#if( $util.isNullOrEmpty($ctx.stash.authFilter) && $ctx.stash.QueryRequest )
  #set( $useScan = false )
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( $ctx.stash.QueryRequestVariables.partitionKey )
    #foreach( $filterItem in $ctx.stash.authFilter.or )
      #if( $filterItem.get($ctx.stash.QueryRequestVariables.partitionKey) )
        #set( $queryFilterContainsAuthField = true )
      #end
    #end
    #if( !$queryFilterContainsAuthField )
      #foreach( $filterItem in $ctx.stash.authFilter.or )
        #foreach( $sortKey in $ctx.stash.QueryRequestVariables.sortKeys )
          #if( $filterItem.get($sortKey) )
            #set( $authFilterContainsSortKey = true )
          #end
        #end
      #end
      #if( !$authFilterContainsSortKey )
        #if( !$util.isNullOrEmpty($ctx.stash.QueryRequest.filter) )
          #set( $ctx.stash.QueryRequest.filter = {
  \\"and\\":   [$ctx.stash.QueryRequest.filter, $ctx.stash.authFilter]
} )
        #else
          #set( $ctx.stash.QueryRequest.filter = $ctx.stash.authFilter )
        #end
        #set( $useScan = false )
      #end
    #else
      #foreach( $filterItem in $ctx.stash.authFilter.or )
        #if( $util.toJson($filterItem) == $util.toJson($ctx.stash.QueryRequestVariables.partitionKeyFilter) )
          #set( $useScan = false )
        #end
      #end
    #end
  #end
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $filter = $filterExpression )
  #end
#end
#if( !$useScan )
  #if( $ctx.stash.QueryRequest.filter )
    #set( $ctx.stash.QueryRequest.filter = $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.QueryRequest.filter)) )
  #end
  $util.toJson($ctx.stash.QueryRequest)
#else
{
      \\"version\\": \\"2018-05-29\\",
      \\"operation\\": \\"Sync\\",
      \\"filter\\":     #if( $filter )
$util.toJson($filter)
    #else
null
    #end,
      \\"limit\\": $util.defaultIfNull($args.limit, 100),
      \\"lastSync\\": $util.toJson($util.defaultIfNull($args.lastSync, null)),
      \\"nextToken\\": $util.toJson($util.defaultIfNull($args.nextToken, null))
  }
#end
## [End] Sync Request template. **",
  "Query.syncSongs.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type, $ctx.result)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Subscription.onCreateSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onCreateSong.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onCreateSong.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onDeleteSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onDeleteSong.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onDeleteSong.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onUpdateSong.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onUpdateSong.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onUpdateSong.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
}
`;

exports[`validate resolver code 1`] = `
Object {
  "Mutation.createItem.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $createdAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"id\\", $util.autoId()))
$util.qr($ctx.stash.defaultValues.put(\\"createdAt\\", $createdAt))
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $createdAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.createItem.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.createItem.preAuth.1.req.vtl": "## [Start] Merge default values and inputs. **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## [End] Merge default values and inputs. **
## [Start] Set the primary key. **
$util.qr($ctx.stash.metadata.put(\\"modelObjectKey\\", {
  \\"orderId\\": $util.dynamodb.toDynamoDB($mergedValues.orderId),
  \\"status#createdAt\\": $util.dynamodb.toDynamoDB(\\"\${mergedValues.status}#\${mergedValues.createdAt}\\")
}))
## [End] Set the primary key. **
#if( $util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) )
  $util.qr($ctx.stash.metadata.put(\\"dynamodbNameOverrideMap\\", { 'status#createdAt': \\"statusCreatedAt\\" }))
#else
  $util.qr($ctx.stash.metadata.dynamodbNameOverrideMap.put('status#createdAt', \\"statusCreatedAt\\"))
#end
$util.qr($ctx.args.input.put('status#createdAt',\\"\${mergedValues.status}#\${mergedValues.createdAt}\\"))
{}",
  "Mutation.createItem.req.vtl": "## [Start] Create Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
$util.qr($mergedValues.put(\\"__typename\\", \\"Item\\"))
#set( $nullIndexFields = [] )
#set( $indexFields = [\\"status\\", \\"createdAt\\"] )
#foreach( $entry in $util.map.copyAndRetainAllKeys($mergedValues, $indexFields).entrySet() )
  #if( $util.isNull($entry.value) )
    $util.qr($nullIndexFields.add($entry.key))
  #end
#end
#set( $mergedValues = $util.map.copyAndRemoveAllKeys($mergedValues, $nullIndexFields) )
#set( $PutObject = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"PutItem\\",
  \\"attributeValues\\":   $util.dynamodb.toMapValues($mergedValues),
  \\"condition\\": $condition
} )
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": false
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": false
  }
}))
#end
## End - key condition **
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($PutObject.put(\\"condition\\", $Conditions))
#end
#if( $ctx.stash.metadata.modelObjectKey )
  $util.qr($PutObject.put(\\"key\\", $ctx.stash.metadata.modelObjectKey))
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($mergedValues.id)
} )
  $util.qr($PutObject.put(\\"key\\", $Key))
#end
$util.toJson($PutObject)
## [End] Create Request template. **",
  "Mutation.createItem.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.deleteItem.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.deleteItem.preAuth.1.req.vtl": "## [Start] Merge default values and inputs. **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## [End] Merge default values and inputs. **
## [Start] Set the primary key. **
$util.qr($ctx.stash.metadata.put(\\"modelObjectKey\\", {
  \\"orderId\\": $util.dynamodb.toDynamoDB($mergedValues.orderId),
  \\"status#createdAt\\": $util.dynamodb.toDynamoDB(\\"\${mergedValues.status}#\${mergedValues.createdAt}\\")
}))
## [End] Set the primary key. **
{}",
  "Mutation.deleteItem.req.vtl": "## [Start] Delete Request template. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $DeleteRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"DeleteItem\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
$util.qr($DeleteRequest.put(\\"key\\", $Key))
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($DeleteRequest.put(\\"condition\\", $Conditions))
#end
$util.toJson($DeleteRequest)
## [End] Delete Request template. **",
  "Mutation.deleteItem.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Mutation.updateItem.init.1.req.vtl": "## [Start] Initialization default values. **
$util.qr($ctx.stash.put(\\"defaultValues\\", $util.defaultIfNull($ctx.stash.defaultValues, {})))
#set( $updatedAt = $util.time.nowISO8601() )
$util.qr($ctx.stash.defaultValues.put(\\"updatedAt\\", $updatedAt))
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Initialization default values. **",
  "Mutation.updateItem.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Mutation.updateItem.preAuth.1.req.vtl": "## [Start] Merge default values and inputs. **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
$util.qr($mergedValues.putAll($util.defaultIfNull($ctx.args.input, {})))
## [End] Merge default values and inputs. **
## [Start] Set the primary key. **
$util.qr($ctx.stash.metadata.put(\\"modelObjectKey\\", {
  \\"orderId\\": $util.dynamodb.toDynamoDB($mergedValues.orderId),
  \\"status#createdAt\\": $util.dynamodb.toDynamoDB(\\"\${mergedValues.status}#\${mergedValues.createdAt}\\")
}))
## [End] Set the primary key. **
#if( $util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) )
  $util.qr($ctx.stash.metadata.put(\\"dynamodbNameOverrideMap\\", { 'status#createdAt': \\"statusCreatedAt\\" }))
#else
  $util.qr($ctx.stash.metadata.dynamodbNameOverrideMap.put('status#createdAt', \\"statusCreatedAt\\"))
#end
$util.qr($ctx.args.input.put('status#createdAt',\\"\${mergedValues.status}#\${mergedValues.createdAt}\\"))
{}",
  "Mutation.updateItem.req.vtl": "## [Start] Mutation Update resolver. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
## Set the default values to put request **
#set( $mergedValues = $util.defaultIfNull($ctx.stash.defaultValues, {}) )
## copy the values from input **
$util.qr($mergedValues.putAll($util.defaultIfNull($args.input, {})))
## set the typename **
## Initialize the vars for creating ddb expression **
#set( $expNames = {} )
#set( $expValues = {} )
#set( $expSet = {} )
#set( $expAdd = {} )
#set( $expRemove = [] )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $Key = $ctx.stash.metadata.modelObjectKey )
#else
  #set( $Key = {
  \\"id\\":   $util.dynamodb.toDynamoDB($args.input.id)
} )
#end
## Model key **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyFields = [] )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyFields.add(\\"$entry.key\\"))
  #end
#else
  #set( $keyFields = [\\"id\\"] )
#end
#foreach( $entry in $util.map.copyAndRemoveAllKeys($mergedValues, $keyFields).entrySet() )
  #if( !$util.isNull($ctx.stash.metadata.dynamodbNameOverrideMap) && $ctx.stash.metadata.dynamodbNameOverrideMap.containsKey(\\"$entry.key\\") )
    #set( $entryKeyAttributeName = $ctx.stash.metadata.dynamodbNameOverrideMap.get(\\"$entry.key\\") )
  #else
    #set( $entryKeyAttributeName = $entry.key )
  #end
  #if( $util.isNull($entry.value) )
    #set( $discard = $expRemove.add(\\"#$entryKeyAttributeName\\") )
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
  #else
    $util.qr($expSet.put(\\"#$entryKeyAttributeName\\", \\":$entryKeyAttributeName\\"))
    $util.qr($expNames.put(\\"#$entryKeyAttributeName\\", \\"$entry.key\\"))
    $util.qr($expValues.put(\\":$entryKeyAttributeName\\", $util.dynamodb.toDynamoDB($entry.value)))
  #end
#end
#set( $expression = \\"\\" )
#if( !$expSet.isEmpty() )
  #set( $expression = \\"SET\\" )
  #foreach( $entry in $expSet.entrySet() )
    #set( $expression = \\"$expression $entry.key = $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expAdd.isEmpty() )
  #set( $expression = \\"$expression ADD\\" )
  #foreach( $entry in $expAdd.entrySet() )
    #set( $expression = \\"$expression $entry.key $entry.value\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#if( !$expRemove.isEmpty() )
  #set( $expression = \\"$expression REMOVE\\" )
  #foreach( $entry in $expRemove )
    #set( $expression = \\"$expression $entry\\" )
    #if( $foreach.hasNext() )
      #set( $expression = \\"$expression,\\" )
    #end
  #end
#end
#set( $update = {} )
$util.qr($update.put(\\"expression\\", \\"$expression\\"))
#if( !$expNames.isEmpty() )
  $util.qr($update.put(\\"expressionNames\\", $expNames))
#end
#if( !$expValues.isEmpty() )
  $util.qr($update.put(\\"expressionValues\\", $expValues))
#end
## Begin - key condition **
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $keyConditionExpr = {} )
  #set( $keyConditionExprNames = {} )
  #foreach( $entry in $ctx.stash.metadata.modelObjectKey.entrySet() )
    $util.qr($keyConditionExpr.put(\\"keyCondition$velocityCount\\", {
  \\"attributeExists\\": true
}))
    $util.qr($keyConditionExprNames.put(\\"#keyCondition$velocityCount\\", \\"$entry.key\\"))
  #end
  $util.qr($ctx.stash.conditions.add($keyConditionExpr))
#else
  $util.qr($ctx.stash.conditions.add({
  \\"id\\": {
      \\"attributeExists\\": true
  }
}))
#end
## End - key condition **
#if( $args.condition )
  $util.qr($ctx.stash.conditions.add($args.condition))
#end
## Start condition block **
#if( $ctx.stash.conditions && $ctx.stash.conditions.size() != 0 )
  #set( $mergedConditions = {
  \\"and\\": $ctx.stash.conditions
} )
  #set( $Conditions = $util.parseJson($util.transform.toDynamoDBConditionExpression($mergedConditions)) )
  #if( $Conditions.expressionValues && $Conditions.expressionValues.size() == 0 )
    #set( $Conditions = {
  \\"expression\\": $Conditions.expression,
  \\"expressionNames\\": $Conditions.expressionNames
} )
  #end
  ## End condition block **
#end
#set( $UpdateItem = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"UpdateItem\\",
  \\"key\\": $Key,
  \\"update\\": $update
} )
#if( $Conditions )
  #if( $keyConditionExprNames )
    $util.qr($Conditions.expressionNames.putAll($keyConditionExprNames))
  #end
  $util.qr($UpdateItem.put(\\"condition\\", $Conditions))
#end
$util.toJson($UpdateItem)
## [End] Mutation Update resolver. **",
  "Mutation.updateItem.res.vtl": "## [Start] ResponseTemplate. **
$util.qr($ctx.result.put(\\"__operation\\", \\"Mutation\\"))
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Query.getItem.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.getItem.preAuth.1.req.vtl": "## [Start] Set the primary key. **
$util.qr($ctx.stash.metadata.put(\\"modelObjectKey\\", {
  \\"orderId\\": $util.dynamodb.toDynamoDB($ctx.args.orderId),
  \\"status#createdAt\\": $util.dynamodb.toDynamoDB(\\"\${ctx.args.status}#\${ctx.args.createdAt}\\")
}))
## [End] Set the primary key. **
{}",
  "Query.getItem.req.vtl": "## [Start] Get Request template. **
#set( $GetRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\"
} )
#if( $ctx.stash.metadata.modelObjectKey )
  #set( $expression = \\"\\" )
  #set( $expressionNames = {} )
  #set( $expressionValues = {} )
  #foreach( $item in $ctx.stash.metadata.modelObjectKey.entrySet() )
    #set( $expression = \\"$expression#keyCount$velocityCount = :valueCount$velocityCount AND \\" )
    $util.qr($expressionNames.put(\\"#keyCount$velocityCount\\", $item.key))
    $util.qr($expressionValues.put(\\":valueCount$velocityCount\\", $item.value))
  #end
  #set( $expression = $expression.replaceAll(\\"AND $\\", \\"\\") )
  #set( $query = {
  \\"expression\\": $expression,
  \\"expressionNames\\": $expressionNames,
  \\"expressionValues\\": $expressionValues
} )
#else
  #set( $query = {
  \\"expression\\": \\"id = :id\\",
  \\"expressionValues\\": {
      \\":id\\":     $util.parseJson($util.dynamodb.toDynamoDBJson($ctx.args.id))
  }
} )
#end
$util.qr($GetRequest.put(\\"query\\", $query))
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  $util.qr($GetRequest.put(\\"filter\\", $util.parseJson($util.transform.toDynamoDBFilterExpression($ctx.stash.authFilter))))
#end
$util.toJson($GetRequest)
## [End] Get Request template. **",
  "Query.getItem.res.vtl": "## [Start] Get Response template. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#end
#if( !$ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
  $util.toJson($ctx.result.items[0])
#else
  #if( $ctx.result.items.isEmpty() && $ctx.result.scannedCount == 1 )
$util.unauthorized()
  #end
  $util.toJson(null)
#end
## [End] Get Response template. **",
  "Query.itemsByCreatedAt.postAuth.1.res.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.itemsByCreatedAt.req.vtl": "## [Start] Set query expression for key **
#set( $modelQueryExpression = {} )
## [Start] Validate key arguments. **
#if( !$util.isNull($ctx.args.status) && $util.isNull($ctx.args.createdAt) )
  $util.error(\\"When providing argument 'status' you must also provide arguments createdAt\\", \\"InvalidArgumentsError\\")
#end
## [End] Validate key arguments. **
#if( !$util.isNull($ctx.args.createdAt) )
  #set( $modelQueryExpression.expression = \\"#createdAt = :createdAt\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#createdAt\\": \\"createdAt\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":createdAt\\": {
      \\"S\\": \\"$ctx.args.createdAt\\"
  }
} )
#end
## [Start] Applying Key Condition **
#if( !$util.isNull($ctx.args.status) && !$util.isNull($ctx.args.status.beginsWith) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.status.beginsWith\\" }))
#end
#if( !$util.isNull($ctx.args.status) && !$util.isNull($ctx.args.status.between) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey0\\", { \\"S\\": \\"$ctx.args.status.between[0]\\" }))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey1\\", { \\"S\\": \\"$ctx.args.status.between[1]\\" }))
#end
#if( !$util.isNull($ctx.args.status) && !$util.isNull($ctx.args.status.eq) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.status.eq\\" }))
#end
#if( !$util.isNull($ctx.args.status) && !$util.isNull($ctx.args.status.lt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.status.lt\\" }))
#end
#if( !$util.isNull($ctx.args.status) && !$util.isNull($ctx.args.status.le) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.status.le\\" }))
#end
#if( !$util.isNull($ctx.args.status) && !$util.isNull($ctx.args.status.gt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.status.gt\\" }))
#end
#if( !$util.isNull($ctx.args.status) && !$util.isNull($ctx.args.status.ge) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.status.ge\\" }))
#end
## [End] Applying Key Condition **
## [End] Set query expression for key **
#set( $limit = $util.defaultIfNull($context.args.limit, 100) )
#set( $QueryRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\",
  \\"limit\\": $limit,
  \\"query\\": $modelQueryExpression,
  \\"index\\": \\"ByCreatedAt\\"
} )
#if( !$util.isNull($ctx.args.sortDirection)
                  && $ctx.args.sortDirection == \\"DESC\\" )
  #set( $QueryRequest.scanIndexForward = false )
#else
  #set( $QueryRequest.scanIndexForward = true )
#end
#if( $context.args.nextToken ) #set( $QueryRequest.nextToken = $context.args.nextToken ) #end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $ctx.args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = $ctx.args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $QueryRequest.filter = $filterExpression )
  #end
#end
$util.toJson($QueryRequest)",
  "Query.itemsByCreatedAt.res.vtl": "#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#end
$util.toJson($ctx.result)",
  "Query.itemsByStatus.postAuth.1.res.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.itemsByStatus.req.vtl": "## [Start] Set query expression for key **
#set( $modelQueryExpression = {} )
## [Start] Validate key arguments. **
#if( !$util.isNull($ctx.args.createdAt) && $util.isNull($ctx.args.status) )
  $util.error(\\"When providing argument 'createdAt' you must also provide arguments status\\", \\"InvalidArgumentsError\\")
#end
## [End] Validate key arguments. **
#if( !$util.isNull($ctx.args.status) )
  #set( $modelQueryExpression.expression = \\"#status = :status\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#status\\": \\"status\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":status\\": {
      \\"S\\": \\"$ctx.args.status\\"
  }
} )
#end
## [Start] Applying Key Condition **
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.beginsWith) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.beginsWith\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.between) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey0\\", { \\"S\\": \\"$ctx.args.createdAt.between[0]\\" }))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey1\\", { \\"S\\": \\"$ctx.args.createdAt.between[1]\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.eq) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.eq\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.lt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.lt\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.le) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.le\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.gt) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.gt\\" }))
#end
#if( !$util.isNull($ctx.args.createdAt) && !$util.isNull($ctx.args.createdAt.ge) )
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$ctx.args.createdAt.ge\\" }))
#end
## [End] Applying Key Condition **
## [End] Set query expression for key **
#set( $limit = $util.defaultIfNull($context.args.limit, 100) )
#set( $QueryRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"operation\\": \\"Query\\",
  \\"limit\\": $limit,
  \\"query\\": $modelQueryExpression,
  \\"index\\": \\"ByStatus\\"
} )
#if( !$util.isNull($ctx.args.sortDirection)
                  && $ctx.args.sortDirection == \\"DESC\\" )
  #set( $QueryRequest.scanIndexForward = false )
#else
  #set( $QueryRequest.scanIndexForward = true )
#end
#if( $context.args.nextToken ) #set( $QueryRequest.nextToken = $context.args.nextToken ) #end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $ctx.args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($ctx.args.filter) )
    #set( $filter = $ctx.args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $QueryRequest.filter = $filterExpression )
  #end
#end
$util.toJson($QueryRequest)",
  "Query.itemsByStatus.res.vtl": "#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#end
$util.toJson($ctx.result)",
  "Query.listItems.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Query.listItems.preAuth.1.req.vtl": "## [Start] Set query expression for key **
#if( $util.isNull($ctx.args.orderId) && !$util.isNull($ctx.args.sortDirection) )
  $util.error(\\"When providing argument 'sortDirection' you must also provide argument 'orderId'.\\", \\"InvalidArgumentsError\\")
#end
#set( $modelQueryExpression = {} )
## [Start] Validate key arguments. **
#if( !$util.isNull($ctx.args.statusCreatedAt) && $util.isNullOrBlank($ctx.args.orderId) )
  $util.error(\\"When providing argument 'statusCreatedAt' you must also provide 'orderId'.\\", \\"InvalidArgumentsError\\")
#end
#if( !$util.isNull($ctx.args.statusCreatedAt) )
  #set( $sortKeyArgumentOperations = $ctx.args.statusCreatedAt.keySet() )
  #if( $sortKeyArgumentOperations.size() > 1 )
    $util.error(\\"Argument statusCreatedAt must specify at most one key condition operation.\\", \\"InvalidArgumentsError\\")
  #end
  #foreach( $operation in $sortKeyArgumentOperations )
    #if( $operation == \\"between\\" )
      #if( $ctx.args.statusCreatedAt.between.size() != 2 )
        $util.error(\\"Argument 'statusCreatedAt.between' expects exactly two elements.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.statusCreatedAt.between[0].createdAt) && $util.isNullOrBlank($ctx.args.statusCreatedAt.between[0].status) )
        $util.error(\\"When providing argument 'statusCreatedAt.between[0].createdAt' you must also provide 'statusCreatedAt.between[0].status'.\\", \\"InvalidArgumentsError\\")
      #end
      #if( !$util.isNullOrBlank($ctx.args.statusCreatedAt.between[1].createdAt) && $util.isNullOrBlank($ctx.args.statusCreatedAt.between[1].status) )
        $util.error(\\"When providing argument 'statusCreatedAt.between[1].createdAt' you must also provide 'statusCreatedAt.between[1].status'.\\", \\"InvalidArgumentsError\\")
      #end
    #else
      #if( !$util.isNullOrBlank($ctx.args.statusCreatedAt.get(\\"$operation\\").createdAt) && $util.isNullOrBlank($ctx.args.statusCreatedAt.get(\\"$operation\\").status) )
        $util.error(\\"When providing argument 'statusCreatedAt.$operation.createdAt' you must also provide 'statusCreatedAt.$operation.status'.\\", \\"InvalidArgumentsError\\")
      #end
    #end
  #end
#end
## [End] Validate key arguments. **
#if( !$util.isNull($ctx.args.orderId) )
  #set( $modelQueryExpression.expression = \\"#orderId = :orderId\\" )
  #set( $modelQueryExpression.expressionNames = {
  \\"#orderId\\": \\"orderId\\"
} )
  #set( $modelQueryExpression.expressionValues = {
  \\":orderId\\": {
      \\"S\\": \\"$ctx.args.orderId\\"
  }
} )
#end
## [Start] Applying Key Condition **
#set( $sortKeyValue = \\"\\" )
#set( $sortKeyValue2 = \\"\\" )
#if( !$util.isNull($ctx.args.statusCreatedAt) && !$util.isNull($ctx.args.statusCreatedAt.beginsWith) )
#if( !$util.isNull($ctx.args.statusCreatedAt.beginsWith.status) ) #set( $sortKeyValue = \\"$ctx.args.statusCreatedAt.beginsWith.status\\" ) #end
#if( !$util.isNull($ctx.args.statusCreatedAt.beginsWith.createdAt) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.statusCreatedAt.beginsWith.createdAt\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status#createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.statusCreatedAt) && !$util.isNull($ctx.args.statusCreatedAt.between) )
  #if( $ctx.args.statusCreatedAt.between.size() != 2 )
    $util.error(\\"Argument statusCreatedAt.between expects exactly 2 elements.\\")
  #end
#if( !$util.isNull($ctx.args.statusCreatedAt.between[0].status) ) #set( $sortKeyValue = \\"$ctx.args.statusCreatedAt.between[0].status\\" ) #end
#if( !$util.isNull($ctx.args.statusCreatedAt.between[0].createdAt) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.statusCreatedAt.between[0].createdAt\\" ) #end
#if( !$util.isNull($ctx.args.statusCreatedAt.between[1].status) ) #set( $sortKeyValue2 = \\"$ctx.args.statusCreatedAt.between[1].status\\" ) #end
#if( !$util.isNull($ctx.args.statusCreatedAt.between[1].createdAt) ) #set( $sortKeyValue2 = \\"$sortKeyValue2#$ctx.args.statusCreatedAt.between[1].createdAt\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status#createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey0\\", { \\"S\\": \\"$sortKeyValue\\" }))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey1\\", { \\"S\\": \\"$sortKeyValue2\\" }))
#end
#if( !$util.isNull($ctx.args.statusCreatedAt) && !$util.isNull($ctx.args.statusCreatedAt.eq) )
#if( !$util.isNull($ctx.args.statusCreatedAt.eq.status) ) #set( $sortKeyValue = \\"$ctx.args.statusCreatedAt.eq.status\\" ) #end
#if( !$util.isNull($ctx.args.statusCreatedAt.eq.createdAt) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.statusCreatedAt.eq.createdAt\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey = :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status#createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.statusCreatedAt) && !$util.isNull($ctx.args.statusCreatedAt.lt) )
#if( !$util.isNull($ctx.args.statusCreatedAt.lt.status) ) #set( $sortKeyValue = \\"$ctx.args.statusCreatedAt.lt.status\\" ) #end
#if( !$util.isNull($ctx.args.statusCreatedAt.lt.createdAt) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.statusCreatedAt.lt.createdAt\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey < :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status#createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.statusCreatedAt) && !$util.isNull($ctx.args.statusCreatedAt.le) )
#if( !$util.isNull($ctx.args.statusCreatedAt.le.status) ) #set( $sortKeyValue = \\"$ctx.args.statusCreatedAt.le.status\\" ) #end
#if( !$util.isNull($ctx.args.statusCreatedAt.le.createdAt) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.statusCreatedAt.le.createdAt\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey <= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status#createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.statusCreatedAt) && !$util.isNull($ctx.args.statusCreatedAt.gt) )
#if( !$util.isNull($ctx.args.statusCreatedAt.gt.status) ) #set( $sortKeyValue = \\"$ctx.args.statusCreatedAt.gt.status\\" ) #end
#if( !$util.isNull($ctx.args.statusCreatedAt.gt.createdAt) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.statusCreatedAt.gt.createdAt\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey > :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status#createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end
#if( !$util.isNull($ctx.args.statusCreatedAt) && !$util.isNull($ctx.args.statusCreatedAt.ge) )
#if( !$util.isNull($ctx.args.statusCreatedAt.ge.status) ) #set( $sortKeyValue = \\"$ctx.args.statusCreatedAt.ge.status\\" ) #end
#if( !$util.isNull($ctx.args.statusCreatedAt.ge.createdAt) ) #set( $sortKeyValue = \\"$sortKeyValue#$ctx.args.statusCreatedAt.ge.createdAt\\" ) #end
  #set( $modelQueryExpression.expression = \\"$modelQueryExpression.expression AND #sortKey >= :sortKey\\" )
  $util.qr($modelQueryExpression.expressionNames.put(\\"#sortKey\\", \\"status#createdAt\\"))
  $util.qr($modelQueryExpression.expressionValues.put(\\":sortKey\\", { \\"S\\": \\"$sortKeyValue\\" }))
#end


## [End] Applying Key Condition **
## [End] Set query expression for key **
$util.qr($ctx.stash.put(\\"modelQueryExpression\\", $modelQueryExpression))
{}",
  "Query.listItems.req.vtl": "## [Start] List Request. **
#set( $args = $util.defaultIfNull($ctx.stash.transformedArgs, $ctx.args) )
#set( $limit = $util.defaultIfNull($args.limit, 100) )
#set( $ListRequest = {
  \\"version\\": \\"2018-05-29\\",
  \\"limit\\": $limit
} )
#if( $args.nextToken )
  #set( $ListRequest.nextToken = $args.nextToken )
#end
#if( !$util.isNullOrEmpty($ctx.stash.authFilter) )
  #set( $filter = $ctx.stash.authFilter )
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = {
  \\"and\\":   [$filter, $args.filter]
} )
  #end
#else
  #if( !$util.isNullOrEmpty($args.filter) )
    #set( $filter = $args.filter )
  #end
#end
#if( !$util.isNullOrEmpty($filter) )
  #set( $filterExpression = $util.parseJson($util.transform.toDynamoDBFilterExpression($filter)) )
  #if( $util.isNullOrEmpty($filterExpression) )
    $util.error(\\"Unable to process the filter expression\\", \\"Unrecognized Filter\\")
  #end
  #if( !$util.isNullOrBlank($filterExpression.expression) )
    #if( $filterExpression.expressionValues.size() == 0 )
      $util.qr($filterExpression.remove(\\"expressionValues\\"))
    #end
    #set( $ListRequest.filter = $filterExpression )
  #end
#end
#if( !$util.isNull($ctx.stash.modelQueryExpression) && !$util.isNullOrEmpty($ctx.stash.modelQueryExpression.expression) )
  $util.qr($ListRequest.put(\\"operation\\", \\"Query\\"))
  $util.qr($ListRequest.put(\\"query\\", $ctx.stash.modelQueryExpression))
  #if( !$util.isNull($args.sortDirection) && $args.sortDirection == \\"DESC\\" )
    #set( $ListRequest.scanIndexForward = false )
  #else
    #set( $ListRequest.scanIndexForward = true )
  #end
#else
  $util.qr($ListRequest.put(\\"operation\\", \\"Scan\\"))
#end
#if( !$util.isNull($ctx.stash.metadata.index) )
  #set( $ListRequest.IndexName = $ctx.stash.metadata.index )
#end
$util.toJson($ListRequest)
## [End] List Request. **",
  "Query.listItems.res.vtl": "## [Start] ResponseTemplate. **
#if( $ctx.error )
  $util.error($ctx.error.message, $ctx.error.type)
#else
  $util.toJson($ctx.result)
#end
## [End] ResponseTemplate. **",
  "Subscription.onCreateItem.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onCreateItem.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onCreateItem.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onDeleteItem.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onDeleteItem.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onDeleteItem.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
  "Subscription.onUpdateItem.postAuth.1.req.vtl": "## [Start] Sandbox Mode Disabled. **
#if( !$ctx.stash.get(\\"hasAuth\\") )
  $util.unauthorized()
#end
$util.toJson({})
## [End] Sandbox Mode Disabled. **",
  "Subscription.onUpdateItem.req.vtl": "## [Start] Subscription Request template. **
$util.toJson({
  \\"version\\": \\"2018-05-29\\",
  \\"payload\\": {}
})
## [End] Subscription Request template. **",
  "Subscription.onUpdateItem.res.vtl": "## [Start] Subscription Response template. **
#if( !$util.isNullOrEmpty($ctx.args.filter) )
$extensions.setSubscriptionFilter($util.transform.toSubscriptionFilter($ctx.args.filter))
#end
$util.toJson(null)
## [End] Subscription Response template. **",
}
`;
