// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`generation route custom query 1`] = `
Object {
  "Fn::Join": Array [
    "",
    Array [
      "export const request = (ctx) => {
  ctx.stash.typeName = \\"Query\\";
  ctx.stash.fieldName = \\"generateRecipe\\";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = \\"HTTP\\";
  ctx.stash.metadata.apiId = \\"",
      Object {
        "Fn::GetAtt": Array [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "\\";
  ctx.stash.connectionAttributes = {};
  ctx.stash.endpoint = \\"https://bedrock-runtime.",
      Object {
        "Ref": "AWS::Region",
      },
      ".amazonaws.com\\";
  ctx.stash.authRole = \\"arn:aws:sts::",
      Object {
        "Ref": "AWS::AccountId",
      },
      ":assumed-role/",
      Object {
        "Ref": "authRoleName",
      },
      "/CognitoIdentityCredentials\\";
  ctx.stash.unauthRole = \\"arn:aws:sts::",
      Object {
        "Ref": "AWS::AccountId",
      },
      ":assumed-role/",
      Object {
        "Ref": "unauthRoleName",
      },
      "/CognitoIdentityCredentials\\";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`generation route custom query 2`] = `
"export function request(ctx) {
    const toolConfig = {\\"tools\\":[{\\"toolSpec\\":{\\"name\\":\\"responseType\\",\\"description\\":\\"Generate a response type for the given field\\",\\"inputSchema\\":{\\"json\\":{\\"type\\":\\"object\\",\\"properties\\":{\\"value\\":{\\"type\\":\\"object\\",\\"properties\\":{\\"name\\":{\\"type\\":\\"string\\",\\"description\\":\\"A UTF-8 character sequence.\\"},\\"ingredients\\":{\\"type\\":\\"array\\",\\"items\\":{\\"type\\":\\"string\\",\\"description\\":\\"A UTF-8 character sequence.\\"}},\\"instructions\\":{\\"type\\":\\"string\\",\\"description\\":\\"A UTF-8 character sequence.\\"}},\\"required\\":[]}},\\"required\\":[\\"value\\"]}}}}],\\"toolChoice\\":{\\"tool\\":{\\"name\\":\\"responseType\\"}}};
    const prompt = \`You are a helpful assistant that generates recipes.\`;
    const args = JSON.stringify(ctx.args);

    return {
      resourcePath: '/model/anthropic.claude-3-haiku-20240307-v1:0/converse',
      method: 'POST',
      params: {
        headers: {
          'Content-Type': 'application/json',
        },
        body: {
          messages: [
          {
            role: 'user',
            content: [
              {
                text: args
              }
            ],
          }
        ],
        system: [{ text: prompt }],
        toolConfig,
        // default inference config
      }
    }
  }
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }
  const body = JSON.parse(ctx.result.body);
  const { content } = body.output.message;

  if (content.length < 1) {
    util.error('No content block in assistant response.', 'error');
  }

  const toolUse = content[0].toolUse;
  if (!toolUse) {
    util.error('Missing tool use block in assistant response.', 'error');
  }

  const response = toolUse.input.value;
  return response;
}"
`;

exports[`generation route model type with null timestamps 1`] = `
Object {
  "Fn::Join": Array [
    "",
    Array [
      "export const request = (ctx) => {
  ctx.stash.typeName = \\"Query\\";
  ctx.stash.fieldName = \\"makeTodo\\";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = \\"HTTP\\";
  ctx.stash.metadata.apiId = \\"",
      Object {
        "Fn::GetAtt": Array [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "\\";
  ctx.stash.connectionAttributes = {};
  ctx.stash.endpoint = \\"https://bedrock-runtime.",
      Object {
        "Ref": "AWS::Region",
      },
      ".amazonaws.com\\";
  ctx.stash.authRole = \\"arn:aws:sts::",
      Object {
        "Ref": "AWS::AccountId",
      },
      ":assumed-role/",
      Object {
        "Ref": "authRoleName",
      },
      "/CognitoIdentityCredentials\\";
  ctx.stash.unauthRole = \\"arn:aws:sts::",
      Object {
        "Ref": "AWS::AccountId",
      },
      ":assumed-role/",
      Object {
        "Ref": "unauthRoleName",
      },
      "/CognitoIdentityCredentials\\";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`generation route model type with null timestamps 2`] = `
"export function request(ctx) {
    const toolConfig = {\\"tools\\":[{\\"toolSpec\\":{\\"name\\":\\"responseType\\",\\"description\\":\\"Generate a response type for the given field\\",\\"inputSchema\\":{\\"json\\":{\\"type\\":\\"object\\",\\"properties\\":{\\"value\\":{\\"type\\":\\"object\\",\\"properties\\":{\\"content\\":{\\"type\\":\\"string\\",\\"description\\":\\"A UTF-8 character sequence.\\"},\\"isDone\\":{\\"type\\":\\"boolean\\",\\"description\\":\\"A boolean value.\\"},\\"id\\":{\\"type\\":\\"string\\",\\"description\\":\\"A unique identifier for an object. This scalar is serialized like a String but isn't meant to be human-readable.\\"}},\\"required\\":[\\"id\\"]}},\\"required\\":[\\"value\\"]}}}}],\\"toolChoice\\":{\\"tool\\":{\\"name\\":\\"responseType\\"}}};
    const prompt = \`Make a string based on the description.\`;
    const args = JSON.stringify(ctx.args);

    return {
      resourcePath: '/model/anthropic.claude-3-haiku-20240307-v1:0/converse',
      method: 'POST',
      params: {
        headers: {
          'Content-Type': 'application/json',
        },
        body: {
          messages: [
          {
            role: 'user',
            content: [
              {
                text: args
              }
            ],
          }
        ],
        system: [{ text: prompt }],
        toolConfig,
        // default inference config
      }
    }
  }
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }
  const body = JSON.parse(ctx.result.body);
  const { content } = body.output.message;

  if (content.length < 1) {
    util.error('No content block in assistant response.', 'error');
  }

  const toolUse = content[0].toolUse;
  if (!toolUse) {
    util.error('Missing tool use block in assistant response.', 'error');
  }

  const response = toolUse.input.value;
  return response;
}"
`;

exports[`generation route scalar type 1`] = `
Object {
  "Fn::Join": Array [
    "",
    Array [
      "export const request = (ctx) => {
  ctx.stash.typeName = \\"Query\\";
  ctx.stash.fieldName = \\"makeTodo\\";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = \\"HTTP\\";
  ctx.stash.metadata.apiId = \\"",
      Object {
        "Fn::GetAtt": Array [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "\\";
  ctx.stash.connectionAttributes = {};
  ctx.stash.endpoint = \\"https://bedrock-runtime.",
      Object {
        "Ref": "AWS::Region",
      },
      ".amazonaws.com\\";
  ctx.stash.authRole = \\"arn:aws:sts::",
      Object {
        "Ref": "AWS::AccountId",
      },
      ":assumed-role/",
      Object {
        "Ref": "authRoleName",
      },
      "/CognitoIdentityCredentials\\";
  ctx.stash.unauthRole = \\"arn:aws:sts::",
      Object {
        "Ref": "AWS::AccountId",
      },
      ":assumed-role/",
      Object {
        "Ref": "unauthRoleName",
      },
      "/CognitoIdentityCredentials\\";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`generation route scalar type 2`] = `
"export function request(ctx) {
    const toolConfig = {\\"tools\\":[{\\"toolSpec\\":{\\"name\\":\\"responseType\\",\\"description\\":\\"Generate a response type for the given field\\",\\"inputSchema\\":{\\"json\\":{\\"type\\":\\"object\\",\\"properties\\":{\\"value\\":{\\"type\\":\\"string\\",\\"description\\":\\"A UTF-8 character sequence.\\"}},\\"required\\":[\\"value\\"]}}}}],\\"toolChoice\\":{\\"tool\\":{\\"name\\":\\"responseType\\"}}};
    const prompt = \`Make a string based on the description.\`;
    const args = JSON.stringify(ctx.args);

    return {
      resourcePath: '/model/anthropic.claude-3-haiku-20240307-v1:0/converse',
      method: 'POST',
      params: {
        headers: {
          'Content-Type': 'application/json',
        },
        body: {
          messages: [
          {
            role: 'user',
            content: [
              {
                text: args
              }
            ],
          }
        ],
        system: [{ text: prompt }],
        toolConfig,
        // default inference config
      }
    }
  }
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }
  const body = JSON.parse(ctx.result.body);
  const { content } = body.output.message;

  if (content.length < 1) {
    util.error('No content block in assistant response.', 'error');
  }

  const toolUse = content[0].toolUse;
  if (!toolUse) {
    util.error('Missing tool use block in assistant response.', 'error');
  }

  const response = toolUse.input.value;
  return response;
}"
`;

exports[`generation route scalar type 3`] = `
"type Query {
  makeTodo(description: String!): String
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelSubscriptionStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  in: [String]
  notIn: [String]
}

input ModelSubscriptionIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  in: [Int]
  notIn: [Int]
}

input ModelSubscriptionFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  in: [Float]
  notIn: [Float]
}

input ModelSubscriptionBooleanInput {
  ne: Boolean
  eq: Boolean
}

input ModelSubscriptionIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  in: [ID]
  notIn: [ID]
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}
"
`;
