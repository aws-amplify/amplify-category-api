// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`generation route custom query 1`] = `
Object {
  "Fn::Join": Array [
    "",
    Array [
      "export const request = (ctx) => {
  ctx.stash.typeName = \\"Query\\";
  ctx.stash.fieldName = \\"generateRecipe\\";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = \\"HTTP\\";
  ctx.stash.metadata.apiId = \\"",
      Object {
        "Fn::GetAtt": Array [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "\\";
  ctx.stash.connectionAttributes = {};
  ctx.stash.endpoint = \\"https://bedrock-runtime.",
      Object {
        "Ref": "AWS::Region",
      },
      ".amazonaws.com\\";
  ctx.stash.authRole = \\"arn:aws:sts::",
      Object {
        "Ref": "AWS::AccountId",
      },
      ":assumed-role/",
      Object {
        "Ref": "authRoleName",
      },
      "/CognitoIdentityCredentials\\";
  ctx.stash.unauthRole = \\"arn:aws:sts::",
      Object {
        "Ref": "AWS::AccountId",
      },
      ":assumed-role/",
      Object {
        "Ref": "unauthRoleName",
      },
      "/CognitoIdentityCredentials\\";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`generation route custom query 2`] = `
"export function request(ctx) {
  const toolConfig = {\\"tools\\":[{\\"toolSpec\\":{\\"name\\":\\"responseType\\",\\"description\\":\\"Generate a response type for the given field\\",\\"inputSchema\\":{\\"json\\":{\\"type\\":\\"object\\",\\"properties\\":{\\"value\\":{\\"type\\":\\"object\\",\\"properties\\":{\\"name\\":{\\"type\\":\\"string\\",\\"description\\":\\"A UTF-8 character sequence.\\"},\\"ingredients\\":{\\"type\\":\\"array\\",\\"items\\":{\\"type\\":\\"string\\",\\"description\\":\\"A UTF-8 character sequence.\\"}},\\"instructions\\":{\\"type\\":\\"string\\",\\"description\\":\\"A UTF-8 character sequence.\\"}},\\"required\\":[]}},\\"required\\":[\\"value\\"]}}}}],\\"toolChoice\\":{\\"tool\\":{\\"name\\":\\"responseType\\"}}};
  const prompt = \`You are a helpful assistant that generates recipes.\`;
  const args = JSON.stringify(ctx.args);

  return {
    resourcePath: '/model/anthropic.claude-3-haiku-20240307-v1:0/converse',
    method: 'POST',
    params: {
      headers: { 'Content-Type': 'application/json' },
      body: {
        messages: [{
          role: 'user',
          content: [{ text: args }],
        }],
        system: [{ text: prompt }],
        toolConfig,
        // default inference config
      }
    }
  }
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }
  const body = JSON.parse(ctx.result.body);
  const { content } = body.output.message;

  if (content.length < 1) {
    util.error('No content block in assistant response.', 'error');
  }

  const toolUse = content[0].toolUse;
  if (!toolUse) {
    util.error('Missing tool use block in assistant response.', 'error');
  }

  const response = toolUse.input.value;
  return response;
}"
`;

exports[`generation route model type with null timestamps 1`] = `
Object {
  "Fn::Join": Array [
    "",
    Array [
      "export const request = (ctx) => {
  ctx.stash.typeName = \\"Query\\";
  ctx.stash.fieldName = \\"makeTodo\\";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = \\"HTTP\\";
  ctx.stash.metadata.apiId = \\"",
      Object {
        "Fn::GetAtt": Array [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "\\";
  ctx.stash.connectionAttributes = {};
  ctx.stash.endpoint = \\"https://bedrock-runtime.",
      Object {
        "Ref": "AWS::Region",
      },
      ".amazonaws.com\\";
  ctx.stash.authRole = \\"arn:aws:sts::",
      Object {
        "Ref": "AWS::AccountId",
      },
      ":assumed-role/",
      Object {
        "Ref": "authRoleName",
      },
      "/CognitoIdentityCredentials\\";
  ctx.stash.unauthRole = \\"arn:aws:sts::",
      Object {
        "Ref": "AWS::AccountId",
      },
      ":assumed-role/",
      Object {
        "Ref": "unauthRoleName",
      },
      "/CognitoIdentityCredentials\\";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`generation route model type with null timestamps 2`] = `
"export function request(ctx) {
  const toolConfig = {\\"tools\\":[{\\"toolSpec\\":{\\"name\\":\\"responseType\\",\\"description\\":\\"Generate a response type for the given field\\",\\"inputSchema\\":{\\"json\\":{\\"type\\":\\"object\\",\\"properties\\":{\\"value\\":{\\"type\\":\\"object\\",\\"properties\\":{\\"content\\":{\\"type\\":\\"string\\",\\"description\\":\\"A UTF-8 character sequence.\\"},\\"isDone\\":{\\"type\\":\\"boolean\\",\\"description\\":\\"A boolean value.\\"},\\"id\\":{\\"type\\":\\"string\\",\\"description\\":\\"A unique identifier for an object. This scalar is serialized like a String but isn't meant to be human-readable.\\"}},\\"required\\":[\\"id\\"]}},\\"required\\":[\\"value\\"]}}}}],\\"toolChoice\\":{\\"tool\\":{\\"name\\":\\"responseType\\"}}};
  const prompt = \`Make a string based on the description.\`;
  const args = JSON.stringify(ctx.args);

  return {
    resourcePath: '/model/anthropic.claude-3-haiku-20240307-v1:0/converse',
    method: 'POST',
    params: {
      headers: { 'Content-Type': 'application/json' },
      body: {
        messages: [{
          role: 'user',
          content: [{ text: args }],
        }],
        system: [{ text: prompt }],
        toolConfig,
        // default inference config
      }
    }
  }
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }
  const body = JSON.parse(ctx.result.body);
  const { content } = body.output.message;

  if (content.length < 1) {
    util.error('No content block in assistant response.', 'error');
  }

  const toolUse = content[0].toolUse;
  if (!toolUse) {
    util.error('Missing tool use block in assistant response.', 'error');
  }

  const response = toolUse.input.value;
  return response;
}"
`;

exports[`generation route scalar type 1`] = `
Object {
  "Fn::Join": Array [
    "",
    Array [
      "export const request = (ctx) => {
  ctx.stash.typeName = \\"Query\\";
  ctx.stash.fieldName = \\"makeTodo\\";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = \\"HTTP\\";
  ctx.stash.metadata.apiId = \\"",
      Object {
        "Fn::GetAtt": Array [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "\\";
  ctx.stash.connectionAttributes = {};
  ctx.stash.endpoint = \\"https://bedrock-runtime.",
      Object {
        "Ref": "AWS::Region",
      },
      ".amazonaws.com\\";
  ctx.stash.authRole = \\"arn:aws:sts::",
      Object {
        "Ref": "AWS::AccountId",
      },
      ":assumed-role/",
      Object {
        "Ref": "authRoleName",
      },
      "/CognitoIdentityCredentials\\";
  ctx.stash.unauthRole = \\"arn:aws:sts::",
      Object {
        "Ref": "AWS::AccountId",
      },
      ":assumed-role/",
      Object {
        "Ref": "unauthRoleName",
      },
      "/CognitoIdentityCredentials\\";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`generation route scalar type 2`] = `
"export function request(ctx) {
  const toolConfig = {\\"tools\\":[{\\"toolSpec\\":{\\"name\\":\\"responseType\\",\\"description\\":\\"Generate a response type for the given field\\",\\"inputSchema\\":{\\"json\\":{\\"type\\":\\"object\\",\\"properties\\":{\\"value\\":{\\"type\\":\\"string\\",\\"description\\":\\"A UTF-8 character sequence.\\"}},\\"required\\":[\\"value\\"]}}}}],\\"toolChoice\\":{\\"tool\\":{\\"name\\":\\"responseType\\"}}};
  const prompt = \`Make a string based on the description.\`;
  const args = JSON.stringify(ctx.args);

  return {
    resourcePath: '/model/anthropic.claude-3-haiku-20240307-v1:0/converse',
    method: 'POST',
    params: {
      headers: { 'Content-Type': 'application/json' },
      body: {
        messages: [{
          role: 'user',
          content: [{ text: args }],
        }],
        system: [{ text: prompt }],
        toolConfig,
        // default inference config
      }
    }
  }
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }
  const body = JSON.parse(ctx.result.body);
  const { content } = body.output.message;

  if (content.length < 1) {
    util.error('No content block in assistant response.', 'error');
  }

  const toolUse = content[0].toolUse;
  if (!toolUse) {
    util.error('Missing tool use block in assistant response.', 'error');
  }

  const response = toolUse.input.value;
  return response;
}"
`;
