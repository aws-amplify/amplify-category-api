// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: AssistantResponseMutation auth slot function code 1`] = `
"export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: AssistantResponseMutation init slot function code 1`] = `
"export function request(ctx) {
  ctx.stash.graphqlApiEndpoint = '[[GRAPHQL_API_ENDPOINT]]';
  ctx.stash.defaultValues = ctx.stash.defaultValues ?? {};
  ctx.stash.defaultValues.id = util.autoId();
  const createdAt = util.time.nowISO8601();
  ctx.stash.defaultValues.createdAt = createdAt;
  ctx.stash.defaultValues.updatedAt = createdAt;
  return {
    version: '2018-05-09',
    payload: {},
  };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: AssistantResponseMutation resolver code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Mutation";
  ctx.stash.fieldName = "createAssistantResponsePirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "AMAZON_DYNAMODB";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  ctx.stash.tableName = "",
      {
        "Fn::Select": [
          1,
          {
            "Fn::Split": [
              "/",
              {
                "Fn::Select": [
                  5,
                  {
                    "Fn::Split": [
                      ":",
                      {
                        "Fn::GetAtt": [
                          "ConversationMessagePirateChat",
                          "Outputs.transformerrootstackConversationMessagePirateChatConversationMessagePirateChatTableFC80206BTableArn",
                        ],
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      },
      "";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: AssistantResponseMutation verify session owner slot function code 1`] = `
"export function request(ctx) {
  const { authFilter } = ctx.stash;
  const { conversationId } = ctx.args.input;

  const query = {
    expression: 'id = :id',
    expressionValues: util.dynamodb.toMapValues({
      ':id': conversationId,
    }),
  };

  const filter = JSON.parse(util.transform.toDynamoDBFilterExpression(authFilter));

  return {
    operation: 'Query',
    query,
    filter,
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }

  if (ctx.result.items.length !== 0) {
    return ctx.result.items[0];
  }

  util.error('Conversation not found', 'ResourceNotFound');
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: AssistantResponseStreamMutation auth slot function code 1`] = `
"export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: AssistantResponseStreamMutation data slot function code 1`] = `
"import { util } from '@aws-appsync/utils';
import * as ddb from '@aws-appsync/utils/dynamodb';

/**
 * Sends a request to the attached data source
 * @param {import('@aws-appsync/utils').Context} ctx the context
 * @returns {*} the request
 */
export function request(ctx) {
  const {
    conversationId,
    associatedUserMessageId,
    accumulatedTurnContent,
    errors,
  } = ctx.args.input;

  const { owner } = ctx.args;

  if (errors) {
    runtime.earlyReturn({
      id: \`\${associatedUserMessageId}#response\`,
      conversationId,
      associatedUserMessageId,
      errors,
      owner,
    });
  }
  const { createdAt, updatedAt } = ctx.stash.defaultValues;

  const assistantResponseId = \`\${associatedUserMessageId}#response\`;
  const expression = 'SET #typename = :typename, #conversationId = :conversationId, #associatedUserMessageId = :associatedUserMessageId, #role = :role, #content = :content, #owner = :owner, #createdAt = if_not_exists(#createdAt, :createdAt), #updatedAt = :updatedAt';

  const expressionValues = util.dynamodb.toMapValues({
    ':typename': 'ConversationMessagePirateChat',
    ':conversationId': conversationId,
    ':associatedUserMessageId': associatedUserMessageId,
    ':role': 'assistant',
    ':content': accumulatedTurnContent,
    ':owner': owner,
    ':createdAt': createdAt,
    ':updatedAt': updatedAt,
  });

  // https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html
  const expressionNames = {
    '#typename': '__typename',
    '#conversationId': 'conversationId',
    '#associatedUserMessageId': 'associatedUserMessageId',
    '#role': 'role',
    '#content': 'content',
    '#owner': 'owner',
    '#createdAt': 'createdAt',
    '#updatedAt': 'updatedAt',
  };

  return {
    operation: 'UpdateItem',
    key: util.dynamodb.toMapValues({ id: assistantResponseId }),
    update: {
      expression,
      expressionValues,
      expressionNames,
    },
  };
}

/**
 * Returns the resolver result
 * @param {import('@aws-appsync/utils').Context} ctx the context
 * @returns {*} the result
 */
export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }
  const streamId = \`\${ctx.args.input.associatedUserMessageId}#stream\`;
  const { owner } = ctx.args;
  const event = ctx.args.input;

  const streamEvent = {
    ...event,
    __typename: 'ConversationMessageStreamPart',
    id: streamId,
    owner,
  };

  // TODO: The lambda event should provide the toolUse directly.
  if (event.contentBlockToolUse && event.contentBlockToolUse.toolUse) {
    streamEvent.contentBlockToolUse = event.contentBlockToolUse.toolUse;
  }

  return streamEvent;
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: AssistantResponseStreamMutation init slot function code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export function request(ctx) {
  ctx.stash.graphqlApiEndpoint = '",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "GraphQLUrl",
        ],
      },
      "';
  ctx.stash.defaultValues = ctx.stash.defaultValues ?? {};
  ctx.stash.defaultValues.id = util.autoId();
  const createdAt = util.time.nowISO8601();
  ctx.stash.defaultValues.createdAt = createdAt;
  ctx.stash.defaultValues.updatedAt = createdAt;
  return {
    version: '2018-05-09',
    payload: {},
  };
}

export function response(ctx) {
  return {};
}
",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: AssistantResponseStreamMutation resolver code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Mutation";
  ctx.stash.fieldName = "createAssistantResponseStreamPirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "AMAZON_DYNAMODB";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  ctx.stash.tableName = "",
      {
        "Fn::Select": [
          1,
          {
            "Fn::Split": [
              "/",
              {
                "Fn::Select": [
                  5,
                  {
                    "Fn::Split": [
                      ":",
                      {
                        "Fn::GetAtt": [
                          "ConversationMessagePirateChat",
                          "Outputs.transformerrootstackConversationMessagePirateChatConversationMessagePirateChatTableFC80206BTableArn",
                        ],
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      },
      "";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: AssistantResponseStreamMutation verify session owner slot function code 1`] = `
"export function request(ctx) {
  const { authFilter } = ctx.stash;
  const { conversationId } = ctx.args.input;

  const query = {
    expression: 'id = :id',
    expressionValues: util.dynamodb.toMapValues({
      ':id': conversationId,
    }),
  };

  const filter = JSON.parse(util.transform.toDynamoDBFilterExpression(authFilter));

  return {
    operation: 'Query',
    query,
    filter,
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }

  if (ctx.result.items.length !== 0) {
    return ctx.result.items[0];
  }

  util.error('Conversation not found', 'ResourceNotFound');
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: AssistantResponseSubscription data slot function code 1`] = `
"import { util, extensions } from '@aws-appsync/utils';

export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  ctx.args.filter = { ...ctx.stash.authFilter, and: [{ conversationId: { eq: ctx.args.conversationId } }] };
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  const subscriptionFilter = util.transform.toSubscriptionFilter(ctx.args.filter);
  extensions.setSubscriptionFilter(subscriptionFilter);
  return null;
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: AssistantResponseSubscription resolver code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Subscription";
  ctx.stash.fieldName = "onCreateAssistantResponsePirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "NONE";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: ListConversationsInit resolver function code 1`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  ctx.stash.metadata.index = 'gsi-Conversation.typename.updatedAt';
  ctx.stash.modelQueryExpression = {
      expression: '#typename = :typename',
      expressionNames: {
        '#typename': '__typename',
      },
      expressionValues: util.dynamodb.toMapValues({
        ':typename': 'ConversationPirateChat',
      }),
    };
  ctx.args.sortDirection = 'DESC';
  return {};
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: ListMessagesInit resolver function code 1`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  ctx.stash.metadata.index = 'gsi-ConversationMessage.conversationId.createdAt';
  const conversationId = ctx.args?.filter?.conversationId?.eq;
  if (conversationId) {
    // If a conversationId was provided, we're going to execute a query
    // rather than a scan. The index (gsi) we're performing this query on has
    // a partitionKey of conversationId.
    // We need to remove conversationId from the filter to prevent a
    // DynamoDB exception:
    // \`Filter Expression can only contain non-primary key attributes\`
    delete ctx.args.filter.conversationId;
    // If conversationId was the only filter, remove the filter object
    // to prevent errors when the \`{}\` filter is combined with
    // the \`authFilter\` further downstream.
    if (Object.keys(ctx.args.filter).length === 0) {
        delete ctx.args.filter;
    }
    ctx.stash.modelQueryExpression = {
      expression: '#conversationId = :conversationId',
      expressionNames: {
        '#conversationId': 'conversationId',
      },
      expressionValues: util.dynamodb.toMapValues({
        ':conversationId': conversationId,
      }),
    };
  }
  ctx.args.sortDirection = 'DESC';
  return {};
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: ListMessagesPostDataLoad resolver function code 1`] = `
"export function request(ctx) {
  return {};
}

export function response(ctx) {
  // Conversation messages are retrieved from DynamoDB in descending order by createdAt.
  // We reverse them here because the most recent messages should be last in the list for clients:
  // We can't use ascending order because we can miss the most recent messages due to limits / pagination.
  const { items, ...rest } = ctx.prev.result;
  const reversed = items.reverse();
  return { items: reversed, ...rest };
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: SendMessageMutation auth slot function code 1`] = `
"export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: SendMessageMutation init slot function code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export function request(ctx) {
  ctx.stash.graphqlApiEndpoint = '",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "GraphQLUrl",
        ],
      },
      "';
  ctx.stash.defaultValues = ctx.stash.defaultValues ?? {};
  ctx.stash.defaultValues.id = util.autoId();
  const createdAt = util.time.nowISO8601();
  ctx.stash.defaultValues.createdAt = createdAt;
  ctx.stash.defaultValues.updatedAt = createdAt;
  return {
    version: '2018-05-09',
    payload: {},
  };
}

export function response(ctx) {
  return {};
}
",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: SendMessageMutation invoke lambda slot function code 1`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { args, request } = ctx;
  const { graphqlApiEndpoint } = ctx.stash;

  const selectionSet = 'associatedUserMessageId contentBlockDeltaIndex contentBlockDoneAtIndex contentBlockIndex contentBlockText contentBlockToolUse { toolUseId name input } conversationId id stopReason owner errors { errorType message }';

  const streamingResponseMutation = {
    name: 'createAssistantResponseStreamPirateChat',
    inputTypeName: 'CreateConversationMessagePirateChatAssistantStreamingInput',
    selectionSet,
  };

  const currentMessageId = ctx.stash.defaultValues.id;

  const modelConfiguration = {
    modelId: "anthropic.claude-3-haiku-20240307-v1:0",
    systemPrompt: "You are a helpful chatbot. Answer questions to the best of your ability.",
    inferenceConfiguration: {"temperature":0.5,"topP":0.9,"maxTokens":100},
  };

  const clientTools = args.toolConfiguration?.tools?.map((tool) => {
    return { ...tool.toolSpec };
  });
  const dataTools = undefined;
  const toolsConfiguration = { dataTools, clientTools };

  const messageHistoryQuery = {
    getQueryName: 'getConversationMessagePirateChat',
    getQueryInputTypeName: 'ID',
    listQueryName: 'listConversationMessagePirateChats',
    listQueryInputTypeName: 'ModelConversationMessagePirateChatFilterInput',
    listQueryLimit: undefined,
  };

  const authHeader = request.headers['authorization'];
  const payload = {
    conversationId: args.conversationId,
    currentMessageId,
    responseMutation: streamingResponseMutation,
    graphqlApiEndpoint,
    modelConfiguration,
    request: { headers: { authorization: authHeader } },
    messageHistoryQuery,
    toolsConfiguration,
    streamResponse: true,
  };

  return {
    operation: 'Invoke',
    payload,
    invocationType: 'Event',
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.appendError(ctx.error.message, ctx.error.type);
  }
  const response = {
    __typename: 'ConversationMessagePirateChat',
    id: ctx.stash.defaultValues.id,
    conversationId: ctx.args.conversationId,
    role: 'user',
    content: ctx.args.content,
    aiContext: ctx.args.aiContext,
    toolConfiguration: ctx.args.toolConfiguration,
    createdAt: ctx.stash.defaultValues.createdAt,
    updatedAt: ctx.stash.defaultValues.updatedAt,
  };
  return response;
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: SendMessageMutation resolver code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Mutation";
  ctx.stash.fieldName = "pirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "AWS_LAMBDA";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  ctx.stash.lambdaFunctionArn = "",
      {
        "Fn::GetAtt": [
          "PirateChatConversationDirectiveLambdaStack",
          "Outputs.transformerrootstackPirateChatConversationDirectiveLambdaStackPirateChatDefaultConversationHandlerconversationHandlerFunction2B526F1AArn",
        ],
      },
      "";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: SendMessageMutation verify session owner slot function code 1`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { authFilter } = ctx.stash;
  const { conversationId } = ctx.args;

  const filter = JSON.parse(util.transform.toDynamoDBFilterExpression(authFilter));

  return {
    operation: 'UpdateItem',
    key: util.dynamodb.toMapValues({ id: conversationId }),
    update: {
      expression: 'SET #updatedAt = :updatedAt',
      expressionValues: util.dynamodb.toMapValues({
        ':updatedAt': ctx.stash.defaultValues.createdAt,
      }),
      expressionNames: {
        '#updatedAt': 'updatedAt',
      },
    },
    condition: filter
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.error('Conversation not found', 'ResourceNotFound');
  }

  return ctx.result;
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration: SendMessageMutation write message to table slot function code 1`] = `
"import { util } from '@aws-appsync/utils';
import * as ddb from '@aws-appsync/utils/dynamodb';

export function request(ctx) {
  const args = ctx.stash.transformedArgs ?? ctx.args;
  const defaultValues = ctx.stash.defaultValues ?? {};
  const message = {
    __typename: 'ConversationMessagePirateChat',
    role: 'user',
    ...args,
    ...defaultValues,
  };
  const id = ctx.stash.defaultValues.id;

  return ddb.put({ key: { id }, item: message });
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  } else {
    return ctx.result;
  }
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: AssistantResponseMutation auth slot function code 1`] = `
"export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: AssistantResponseMutation init slot function code 1`] = `
"export function request(ctx) {
  ctx.stash.graphqlApiEndpoint = '[[GRAPHQL_API_ENDPOINT]]';
  ctx.stash.defaultValues = ctx.stash.defaultValues ?? {};
  ctx.stash.defaultValues.id = util.autoId();
  const createdAt = util.time.nowISO8601();
  ctx.stash.defaultValues.createdAt = createdAt;
  ctx.stash.defaultValues.updatedAt = createdAt;
  return {
    version: '2018-05-09',
    payload: {},
  };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: AssistantResponseMutation resolver code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Mutation";
  ctx.stash.fieldName = "createAssistantResponsePirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "AMAZON_DYNAMODB";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  ctx.stash.tableName = "",
      {
        "Fn::Select": [
          1,
          {
            "Fn::Split": [
              "/",
              {
                "Fn::Select": [
                  5,
                  {
                    "Fn::Split": [
                      ":",
                      {
                        "Fn::GetAtt": [
                          "ConversationMessagePirateChat",
                          "Outputs.transformerrootstackConversationMessagePirateChatConversationMessagePirateChatTableFC80206BTableArn",
                        ],
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      },
      "";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: AssistantResponseMutation verify session owner slot function code 1`] = `
"export function request(ctx) {
  const { authFilter } = ctx.stash;
  const { conversationId } = ctx.args.input;

  const query = {
    expression: 'id = :id',
    expressionValues: util.dynamodb.toMapValues({
      ':id': conversationId,
    }),
  };

  const filter = JSON.parse(util.transform.toDynamoDBFilterExpression(authFilter));

  return {
    operation: 'Query',
    query,
    filter,
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }

  if (ctx.result.items.length !== 0) {
    return ctx.result.items[0];
  }

  util.error('Conversation not found', 'ResourceNotFound');
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: AssistantResponseStreamMutation auth slot function code 1`] = `
"export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: AssistantResponseStreamMutation data slot function code 1`] = `
"import { util } from '@aws-appsync/utils';
import * as ddb from '@aws-appsync/utils/dynamodb';

/**
 * Sends a request to the attached data source
 * @param {import('@aws-appsync/utils').Context} ctx the context
 * @returns {*} the request
 */
export function request(ctx) {
  const {
    conversationId,
    associatedUserMessageId,
    accumulatedTurnContent,
    errors,
  } = ctx.args.input;

  const { owner } = ctx.args;

  if (errors) {
    runtime.earlyReturn({
      id: \`\${associatedUserMessageId}#response\`,
      conversationId,
      associatedUserMessageId,
      errors,
      owner,
    });
  }
  const { createdAt, updatedAt } = ctx.stash.defaultValues;

  const assistantResponseId = \`\${associatedUserMessageId}#response\`;
  const expression = 'SET #typename = :typename, #conversationId = :conversationId, #associatedUserMessageId = :associatedUserMessageId, #role = :role, #content = :content, #owner = :owner, #createdAt = if_not_exists(#createdAt, :createdAt), #updatedAt = :updatedAt';

  const expressionValues = util.dynamodb.toMapValues({
    ':typename': 'ConversationMessagePirateChat',
    ':conversationId': conversationId,
    ':associatedUserMessageId': associatedUserMessageId,
    ':role': 'assistant',
    ':content': accumulatedTurnContent,
    ':owner': owner,
    ':createdAt': createdAt,
    ':updatedAt': updatedAt,
  });

  // https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html
  const expressionNames = {
    '#typename': '__typename',
    '#conversationId': 'conversationId',
    '#associatedUserMessageId': 'associatedUserMessageId',
    '#role': 'role',
    '#content': 'content',
    '#owner': 'owner',
    '#createdAt': 'createdAt',
    '#updatedAt': 'updatedAt',
  };

  return {
    operation: 'UpdateItem',
    key: util.dynamodb.toMapValues({ id: assistantResponseId }),
    update: {
      expression,
      expressionValues,
      expressionNames,
    },
  };
}

/**
 * Returns the resolver result
 * @param {import('@aws-appsync/utils').Context} ctx the context
 * @returns {*} the result
 */
export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }
  const streamId = \`\${ctx.args.input.associatedUserMessageId}#stream\`;
  const { owner } = ctx.args;
  const event = ctx.args.input;

  const streamEvent = {
    ...event,
    __typename: 'ConversationMessageStreamPart',
    id: streamId,
    owner,
  };

  // TODO: The lambda event should provide the toolUse directly.
  if (event.contentBlockToolUse && event.contentBlockToolUse.toolUse) {
    streamEvent.contentBlockToolUse = event.contentBlockToolUse.toolUse;
  }

  return streamEvent;
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: AssistantResponseStreamMutation init slot function code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export function request(ctx) {
  ctx.stash.graphqlApiEndpoint = '",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "GraphQLUrl",
        ],
      },
      "';
  ctx.stash.defaultValues = ctx.stash.defaultValues ?? {};
  ctx.stash.defaultValues.id = util.autoId();
  const createdAt = util.time.nowISO8601();
  ctx.stash.defaultValues.createdAt = createdAt;
  ctx.stash.defaultValues.updatedAt = createdAt;
  return {
    version: '2018-05-09',
    payload: {},
  };
}

export function response(ctx) {
  return {};
}
",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: AssistantResponseStreamMutation resolver code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Mutation";
  ctx.stash.fieldName = "createAssistantResponseStreamPirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "AMAZON_DYNAMODB";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  ctx.stash.tableName = "",
      {
        "Fn::Select": [
          1,
          {
            "Fn::Split": [
              "/",
              {
                "Fn::Select": [
                  5,
                  {
                    "Fn::Split": [
                      ":",
                      {
                        "Fn::GetAtt": [
                          "ConversationMessagePirateChat",
                          "Outputs.transformerrootstackConversationMessagePirateChatConversationMessagePirateChatTableFC80206BTableArn",
                        ],
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      },
      "";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: AssistantResponseStreamMutation verify session owner slot function code 1`] = `
"export function request(ctx) {
  const { authFilter } = ctx.stash;
  const { conversationId } = ctx.args.input;

  const query = {
    expression: 'id = :id',
    expressionValues: util.dynamodb.toMapValues({
      ':id': conversationId,
    }),
  };

  const filter = JSON.parse(util.transform.toDynamoDBFilterExpression(authFilter));

  return {
    operation: 'Query',
    query,
    filter,
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }

  if (ctx.result.items.length !== 0) {
    return ctx.result.items[0];
  }

  util.error('Conversation not found', 'ResourceNotFound');
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: AssistantResponseSubscription data slot function code 1`] = `
"import { util, extensions } from '@aws-appsync/utils';

export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  ctx.args.filter = { ...ctx.stash.authFilter, and: [{ conversationId: { eq: ctx.args.conversationId } }] };
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  const subscriptionFilter = util.transform.toSubscriptionFilter(ctx.args.filter);
  extensions.setSubscriptionFilter(subscriptionFilter);
  return null;
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: AssistantResponseSubscription resolver code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Subscription";
  ctx.stash.fieldName = "onCreateAssistantResponsePirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "NONE";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: ListConversationsInit resolver function code 1`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  ctx.stash.metadata.index = 'gsi-Conversation.typename.updatedAt';
  ctx.stash.modelQueryExpression = {
      expression: '#typename = :typename',
      expressionNames: {
        '#typename': '__typename',
      },
      expressionValues: util.dynamodb.toMapValues({
        ':typename': 'ConversationPirateChat',
      }),
    };
  ctx.args.sortDirection = 'DESC';
  return {};
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: ListMessagesInit resolver function code 1`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  ctx.stash.metadata.index = 'gsi-ConversationMessage.conversationId.createdAt';
  const conversationId = ctx.args?.filter?.conversationId?.eq;
  if (conversationId) {
    // If a conversationId was provided, we're going to execute a query
    // rather than a scan. The index (gsi) we're performing this query on has
    // a partitionKey of conversationId.
    // We need to remove conversationId from the filter to prevent a
    // DynamoDB exception:
    // \`Filter Expression can only contain non-primary key attributes\`
    delete ctx.args.filter.conversationId;
    // If conversationId was the only filter, remove the filter object
    // to prevent errors when the \`{}\` filter is combined with
    // the \`authFilter\` further downstream.
    if (Object.keys(ctx.args.filter).length === 0) {
        delete ctx.args.filter;
    }
    ctx.stash.modelQueryExpression = {
      expression: '#conversationId = :conversationId',
      expressionNames: {
        '#conversationId': 'conversationId',
      },
      expressionValues: util.dynamodb.toMapValues({
        ':conversationId': conversationId,
      }),
    };
  }
  ctx.args.sortDirection = 'DESC';
  return {};
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: ListMessagesPostDataLoad resolver function code 1`] = `
"export function request(ctx) {
  return {};
}

export function response(ctx) {
  // Conversation messages are retrieved from DynamoDB in descending order by createdAt.
  // We reverse them here because the most recent messages should be last in the list for clients:
  // We can't use ascending order because we can miss the most recent messages due to limits / pagination.
  const { items, ...rest } = ctx.prev.result;
  const reversed = items.reverse();
  return { items: reversed, ...rest };
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: SendMessageMutation auth slot function code 1`] = `
"export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: SendMessageMutation init slot function code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export function request(ctx) {
  ctx.stash.graphqlApiEndpoint = '",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "GraphQLUrl",
        ],
      },
      "';
  ctx.stash.defaultValues = ctx.stash.defaultValues ?? {};
  ctx.stash.defaultValues.id = util.autoId();
  const createdAt = util.time.nowISO8601();
  ctx.stash.defaultValues.createdAt = createdAt;
  ctx.stash.defaultValues.updatedAt = createdAt;
  return {
    version: '2018-05-09',
    payload: {},
  };
}

export function response(ctx) {
  return {};
}
",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: SendMessageMutation invoke lambda slot function code 1`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { args, request } = ctx;
  const { graphqlApiEndpoint } = ctx.stash;

  const selectionSet = 'associatedUserMessageId contentBlockDeltaIndex contentBlockDoneAtIndex contentBlockIndex contentBlockText contentBlockToolUse { toolUseId name input } conversationId id stopReason owner errors { errorType message }';

  const streamingResponseMutation = {
    name: 'createAssistantResponseStreamPirateChat',
    inputTypeName: 'CreateConversationMessagePirateChatAssistantStreamingInput',
    selectionSet,
  };

  const currentMessageId = ctx.stash.defaultValues.id;

  const modelConfiguration = {
    modelId: "anthropic.claude-3-haiku-20240307-v1:0",
    systemPrompt: "You are a helpful chatbot. Answer questions to the best of your ability.",
    inferenceConfiguration: undefined,
  };

  const clientTools = args.toolConfiguration?.tools?.map((tool) => {
    return { ...tool.toolSpec };
  });
  const dataTools = [{"name":"listCustomers","description":"Provides data about the customer sending a message","inputSchema":{"json":{"type":"object","properties":{},"required":[]}},"graphqlRequestInputDescriptor":{"selectionSet":"items { name email activeCart { products { name price } customerId id createdAt updatedAt owner } orderHistory { items { products { name price } customerId id createdAt updatedAt owner } nextToken } id createdAt updatedAt owner } nextToken","propertyTypes":{},"queryName":"listCustomers"}}];
  const toolsConfiguration = { dataTools, clientTools };

  const messageHistoryQuery = {
    getQueryName: 'getConversationMessagePirateChat',
    getQueryInputTypeName: 'ID',
    listQueryName: 'listConversationMessagePirateChats',
    listQueryInputTypeName: 'ModelConversationMessagePirateChatFilterInput',
    listQueryLimit: undefined,
  };

  const authHeader = request.headers['authorization'];
  const payload = {
    conversationId: args.conversationId,
    currentMessageId,
    responseMutation: streamingResponseMutation,
    graphqlApiEndpoint,
    modelConfiguration,
    request: { headers: { authorization: authHeader } },
    messageHistoryQuery,
    toolsConfiguration,
    streamResponse: true,
  };

  return {
    operation: 'Invoke',
    payload,
    invocationType: 'Event',
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.appendError(ctx.error.message, ctx.error.type);
  }
  const response = {
    __typename: 'ConversationMessagePirateChat',
    id: ctx.stash.defaultValues.id,
    conversationId: ctx.args.conversationId,
    role: 'user',
    content: ctx.args.content,
    aiContext: ctx.args.aiContext,
    toolConfiguration: ctx.args.toolConfiguration,
    createdAt: ctx.stash.defaultValues.createdAt,
    updatedAt: ctx.stash.defaultValues.updatedAt,
  };
  return response;
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: SendMessageMutation resolver code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Mutation";
  ctx.stash.fieldName = "pirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "AWS_LAMBDA";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  ctx.stash.lambdaFunctionArn = "",
      {
        "Fn::GetAtt": [
          "PirateChatConversationDirectiveLambdaStack",
          "Outputs.transformerrootstackPirateChatConversationDirectiveLambdaStackPirateChatDefaultConversationHandlerconversationHandlerFunction2B526F1AArn",
        ],
      },
      "";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: SendMessageMutation verify session owner slot function code 1`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { authFilter } = ctx.stash;
  const { conversationId } = ctx.args;

  const filter = JSON.parse(util.transform.toDynamoDBFilterExpression(authFilter));

  return {
    operation: 'UpdateItem',
    key: util.dynamodb.toMapValues({ id: conversationId }),
    update: {
      expression: 'SET #updatedAt = :updatedAt',
      expressionValues: util.dynamodb.toMapValues({
        ':updatedAt': ctx.stash.defaultValues.createdAt,
      }),
      expressionNames: {
        '#updatedAt': 'updatedAt',
      },
    },
    condition: filter
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.error('Conversation not found', 'ResourceNotFound');
  }

  return ctx.result;
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships: SendMessageMutation write message to table slot function code 1`] = `
"import { util } from '@aws-appsync/utils';
import * as ddb from '@aws-appsync/utils/dynamodb';

export function request(ctx) {
  const args = ctx.stash.transformedArgs ?? ctx.args;
  const defaultValues = ctx.stash.defaultValues ?? {};
  const message = {
    __typename: 'ConversationMessagePirateChat',
    role: 'user',
    ...args,
    ...defaultValues,
  };
  const id = ctx.stash.defaultValues.id;

  return ddb.put({ key: { id }, item: message });
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  } else {
    return ctx.result;
  }
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: AssistantResponseMutation auth slot function code 1`] = `
"export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: AssistantResponseMutation init slot function code 1`] = `
"export function request(ctx) {
  ctx.stash.graphqlApiEndpoint = '[[GRAPHQL_API_ENDPOINT]]';
  ctx.stash.defaultValues = ctx.stash.defaultValues ?? {};
  ctx.stash.defaultValues.id = util.autoId();
  const createdAt = util.time.nowISO8601();
  ctx.stash.defaultValues.createdAt = createdAt;
  ctx.stash.defaultValues.updatedAt = createdAt;
  return {
    version: '2018-05-09',
    payload: {},
  };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: AssistantResponseMutation resolver code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Mutation";
  ctx.stash.fieldName = "createAssistantResponsePirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "AMAZON_DYNAMODB";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  ctx.stash.tableName = "",
      {
        "Fn::Select": [
          1,
          {
            "Fn::Split": [
              "/",
              {
                "Fn::Select": [
                  5,
                  {
                    "Fn::Split": [
                      ":",
                      {
                        "Fn::GetAtt": [
                          "ConversationMessagePirateChat",
                          "Outputs.transformerrootstackConversationMessagePirateChatConversationMessagePirateChatTableFC80206BTableArn",
                        ],
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      },
      "";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: AssistantResponseMutation verify session owner slot function code 1`] = `
"export function request(ctx) {
  const { authFilter } = ctx.stash;
  const { conversationId } = ctx.args.input;

  const query = {
    expression: 'id = :id',
    expressionValues: util.dynamodb.toMapValues({
      ':id': conversationId,
    }),
  };

  const filter = JSON.parse(util.transform.toDynamoDBFilterExpression(authFilter));

  return {
    operation: 'Query',
    query,
    filter,
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }

  if (ctx.result.items.length !== 0) {
    return ctx.result.items[0];
  }

  util.error('Conversation not found', 'ResourceNotFound');
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: AssistantResponseStreamMutation auth slot function code 1`] = `
"export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: AssistantResponseStreamMutation data slot function code 1`] = `
"import { util } from '@aws-appsync/utils';
import * as ddb from '@aws-appsync/utils/dynamodb';

/**
 * Sends a request to the attached data source
 * @param {import('@aws-appsync/utils').Context} ctx the context
 * @returns {*} the request
 */
export function request(ctx) {
  const {
    conversationId,
    associatedUserMessageId,
    accumulatedTurnContent,
    errors,
  } = ctx.args.input;

  const { owner } = ctx.args;

  if (errors) {
    runtime.earlyReturn({
      id: \`\${associatedUserMessageId}#response\`,
      conversationId,
      associatedUserMessageId,
      errors,
      owner,
    });
  }
  const { createdAt, updatedAt } = ctx.stash.defaultValues;

  const assistantResponseId = \`\${associatedUserMessageId}#response\`;
  const expression = 'SET #typename = :typename, #conversationId = :conversationId, #associatedUserMessageId = :associatedUserMessageId, #role = :role, #content = :content, #owner = :owner, #createdAt = if_not_exists(#createdAt, :createdAt), #updatedAt = :updatedAt';

  const expressionValues = util.dynamodb.toMapValues({
    ':typename': 'ConversationMessagePirateChat',
    ':conversationId': conversationId,
    ':associatedUserMessageId': associatedUserMessageId,
    ':role': 'assistant',
    ':content': accumulatedTurnContent,
    ':owner': owner,
    ':createdAt': createdAt,
    ':updatedAt': updatedAt,
  });

  // https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html
  const expressionNames = {
    '#typename': '__typename',
    '#conversationId': 'conversationId',
    '#associatedUserMessageId': 'associatedUserMessageId',
    '#role': 'role',
    '#content': 'content',
    '#owner': 'owner',
    '#createdAt': 'createdAt',
    '#updatedAt': 'updatedAt',
  };

  return {
    operation: 'UpdateItem',
    key: util.dynamodb.toMapValues({ id: assistantResponseId }),
    update: {
      expression,
      expressionValues,
      expressionNames,
    },
  };
}

/**
 * Returns the resolver result
 * @param {import('@aws-appsync/utils').Context} ctx the context
 * @returns {*} the result
 */
export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }
  const streamId = \`\${ctx.args.input.associatedUserMessageId}#stream\`;
  const { owner } = ctx.args;
  const event = ctx.args.input;

  const streamEvent = {
    ...event,
    __typename: 'ConversationMessageStreamPart',
    id: streamId,
    owner,
  };

  // TODO: The lambda event should provide the toolUse directly.
  if (event.contentBlockToolUse && event.contentBlockToolUse.toolUse) {
    streamEvent.contentBlockToolUse = event.contentBlockToolUse.toolUse;
  }

  return streamEvent;
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: AssistantResponseStreamMutation init slot function code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export function request(ctx) {
  ctx.stash.graphqlApiEndpoint = '",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "GraphQLUrl",
        ],
      },
      "';
  ctx.stash.defaultValues = ctx.stash.defaultValues ?? {};
  ctx.stash.defaultValues.id = util.autoId();
  const createdAt = util.time.nowISO8601();
  ctx.stash.defaultValues.createdAt = createdAt;
  ctx.stash.defaultValues.updatedAt = createdAt;
  return {
    version: '2018-05-09',
    payload: {},
  };
}

export function response(ctx) {
  return {};
}
",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: AssistantResponseStreamMutation resolver code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Mutation";
  ctx.stash.fieldName = "createAssistantResponseStreamPirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "AMAZON_DYNAMODB";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  ctx.stash.tableName = "",
      {
        "Fn::Select": [
          1,
          {
            "Fn::Split": [
              "/",
              {
                "Fn::Select": [
                  5,
                  {
                    "Fn::Split": [
                      ":",
                      {
                        "Fn::GetAtt": [
                          "ConversationMessagePirateChat",
                          "Outputs.transformerrootstackConversationMessagePirateChatConversationMessagePirateChatTableFC80206BTableArn",
                        ],
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      },
      "";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: AssistantResponseStreamMutation verify session owner slot function code 1`] = `
"export function request(ctx) {
  const { authFilter } = ctx.stash;
  const { conversationId } = ctx.args.input;

  const query = {
    expression: 'id = :id',
    expressionValues: util.dynamodb.toMapValues({
      ':id': conversationId,
    }),
  };

  const filter = JSON.parse(util.transform.toDynamoDBFilterExpression(authFilter));

  return {
    operation: 'Query',
    query,
    filter,
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }

  if (ctx.result.items.length !== 0) {
    return ctx.result.items[0];
  }

  util.error('Conversation not found', 'ResourceNotFound');
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: AssistantResponseSubscription data slot function code 1`] = `
"import { util, extensions } from '@aws-appsync/utils';

export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  ctx.args.filter = { ...ctx.stash.authFilter, and: [{ conversationId: { eq: ctx.args.conversationId } }] };
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  const subscriptionFilter = util.transform.toSubscriptionFilter(ctx.args.filter);
  extensions.setSubscriptionFilter(subscriptionFilter);
  return null;
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: AssistantResponseSubscription resolver code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Subscription";
  ctx.stash.fieldName = "onCreateAssistantResponsePirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "NONE";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: ListConversationsInit resolver function code 1`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  ctx.stash.metadata.index = 'gsi-Conversation.typename.updatedAt';
  ctx.stash.modelQueryExpression = {
      expression: '#typename = :typename',
      expressionNames: {
        '#typename': '__typename',
      },
      expressionValues: util.dynamodb.toMapValues({
        ':typename': 'ConversationPirateChat',
      }),
    };
  ctx.args.sortDirection = 'DESC';
  return {};
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: ListMessagesInit resolver function code 1`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  ctx.stash.metadata.index = 'gsi-ConversationMessage.conversationId.createdAt';
  const conversationId = ctx.args?.filter?.conversationId?.eq;
  if (conversationId) {
    // If a conversationId was provided, we're going to execute a query
    // rather than a scan. The index (gsi) we're performing this query on has
    // a partitionKey of conversationId.
    // We need to remove conversationId from the filter to prevent a
    // DynamoDB exception:
    // \`Filter Expression can only contain non-primary key attributes\`
    delete ctx.args.filter.conversationId;
    // If conversationId was the only filter, remove the filter object
    // to prevent errors when the \`{}\` filter is combined with
    // the \`authFilter\` further downstream.
    if (Object.keys(ctx.args.filter).length === 0) {
        delete ctx.args.filter;
    }
    ctx.stash.modelQueryExpression = {
      expression: '#conversationId = :conversationId',
      expressionNames: {
        '#conversationId': 'conversationId',
      },
      expressionValues: util.dynamodb.toMapValues({
        ':conversationId': conversationId,
      }),
    };
  }
  ctx.args.sortDirection = 'DESC';
  return {};
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: ListMessagesPostDataLoad resolver function code 1`] = `
"export function request(ctx) {
  return {};
}

export function response(ctx) {
  // Conversation messages are retrieved from DynamoDB in descending order by createdAt.
  // We reverse them here because the most recent messages should be last in the list for clients:
  // We can't use ascending order because we can miss the most recent messages due to limits / pagination.
  const { items, ...rest } = ctx.prev.result;
  const reversed = items.reverse();
  return { items: reversed, ...rest };
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: SendMessageMutation auth slot function code 1`] = `
"export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: SendMessageMutation init slot function code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export function request(ctx) {
  ctx.stash.graphqlApiEndpoint = '",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "GraphQLUrl",
        ],
      },
      "';
  ctx.stash.defaultValues = ctx.stash.defaultValues ?? {};
  ctx.stash.defaultValues.id = util.autoId();
  const createdAt = util.time.nowISO8601();
  ctx.stash.defaultValues.createdAt = createdAt;
  ctx.stash.defaultValues.updatedAt = createdAt;
  return {
    version: '2018-05-09',
    payload: {},
  };
}

export function response(ctx) {
  return {};
}
",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: SendMessageMutation invoke lambda slot function code 1`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { args, request } = ctx;
  const { graphqlApiEndpoint } = ctx.stash;

  const selectionSet = 'associatedUserMessageId contentBlockDeltaIndex contentBlockDoneAtIndex contentBlockIndex contentBlockText contentBlockToolUse { toolUseId name input } conversationId id stopReason owner errors { errorType message }';

  const streamingResponseMutation = {
    name: 'createAssistantResponseStreamPirateChat',
    inputTypeName: 'CreateConversationMessagePirateChatAssistantStreamingInput',
    selectionSet,
  };

  const currentMessageId = ctx.stash.defaultValues.id;

  const modelConfiguration = {
    modelId: "anthropic.claude-3-haiku-20240307-v1:0",
    systemPrompt: "You are a helpful chatbot. Answer questions to the best of your ability.",
    inferenceConfiguration: undefined,
  };

  const clientTools = args.toolConfiguration?.tools?.map((tool) => {
    return { ...tool.toolSpec };
  });
  const dataTools = [{"name":"listTodos","description":"lists todos","inputSchema":{"json":{"type":"object","properties":{},"required":[]}},"graphqlRequestInputDescriptor":{"selectionSet":"items { content isDone id createdAt updatedAt owner } nextToken","propertyTypes":{},"queryName":"listTodos"}}];
  const toolsConfiguration = { dataTools, clientTools };

  const messageHistoryQuery = {
    getQueryName: 'getConversationMessagePirateChat',
    getQueryInputTypeName: 'ID',
    listQueryName: 'listConversationMessagePirateChats',
    listQueryInputTypeName: 'ModelConversationMessagePirateChatFilterInput',
    listQueryLimit: undefined,
  };

  const authHeader = request.headers['authorization'];
  const payload = {
    conversationId: args.conversationId,
    currentMessageId,
    responseMutation: streamingResponseMutation,
    graphqlApiEndpoint,
    modelConfiguration,
    request: { headers: { authorization: authHeader } },
    messageHistoryQuery,
    toolsConfiguration,
    streamResponse: true,
  };

  return {
    operation: 'Invoke',
    payload,
    invocationType: 'Event',
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.appendError(ctx.error.message, ctx.error.type);
  }
  const response = {
    __typename: 'ConversationMessagePirateChat',
    id: ctx.stash.defaultValues.id,
    conversationId: ctx.args.conversationId,
    role: 'user',
    content: ctx.args.content,
    aiContext: ctx.args.aiContext,
    toolConfiguration: ctx.args.toolConfiguration,
    createdAt: ctx.stash.defaultValues.createdAt,
    updatedAt: ctx.stash.defaultValues.updatedAt,
  };
  return response;
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: SendMessageMutation resolver code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Mutation";
  ctx.stash.fieldName = "pirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "AWS_LAMBDA";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  ctx.stash.lambdaFunctionArn = "",
      {
        "Fn::GetAtt": [
          "PirateChatConversationDirectiveLambdaStack",
          "Outputs.transformerrootstackPirateChatConversationDirectiveLambdaStackPirateChatDefaultConversationHandlerconversationHandlerFunction2B526F1AArn",
        ],
      },
      "";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: SendMessageMutation verify session owner slot function code 1`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { authFilter } = ctx.stash;
  const { conversationId } = ctx.args;

  const filter = JSON.parse(util.transform.toDynamoDBFilterExpression(authFilter));

  return {
    operation: 'UpdateItem',
    key: util.dynamodb.toMapValues({ id: conversationId }),
    update: {
      expression: 'SET #updatedAt = :updatedAt',
      expressionValues: util.dynamodb.toMapValues({
        ':updatedAt': ctx.stash.defaultValues.createdAt,
      }),
      expressionNames: {
        '#updatedAt': 'updatedAt',
      },
    },
    condition: filter
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.error('Conversation not found', 'ResourceNotFound');
  }

  return ctx.result;
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool: SendMessageMutation write message to table slot function code 1`] = `
"import { util } from '@aws-appsync/utils';
import * as ddb from '@aws-appsync/utils/dynamodb';

export function request(ctx) {
  const args = ctx.stash.transformedArgs ?? ctx.args;
  const defaultValues = ctx.stash.defaultValues ?? {};
  const message = {
    __typename: 'ConversationMessagePirateChat',
    role: 'user',
    ...args,
    ...defaultValues,
  };
  const id = ctx.stash.defaultValues.id;

  return ddb.put({ key: { id }, item: message });
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  } else {
    return ctx.result;
  }
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: AssistantResponseMutation auth slot function code 1`] = `
"export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: AssistantResponseMutation init slot function code 1`] = `
"export function request(ctx) {
  ctx.stash.graphqlApiEndpoint = '[[GRAPHQL_API_ENDPOINT]]';
  ctx.stash.defaultValues = ctx.stash.defaultValues ?? {};
  ctx.stash.defaultValues.id = util.autoId();
  const createdAt = util.time.nowISO8601();
  ctx.stash.defaultValues.createdAt = createdAt;
  ctx.stash.defaultValues.updatedAt = createdAt;
  return {
    version: '2018-05-09',
    payload: {},
  };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: AssistantResponseMutation resolver code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Mutation";
  ctx.stash.fieldName = "createAssistantResponsePirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "AMAZON_DYNAMODB";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  ctx.stash.tableName = "",
      {
        "Fn::Select": [
          1,
          {
            "Fn::Split": [
              "/",
              {
                "Fn::Select": [
                  5,
                  {
                    "Fn::Split": [
                      ":",
                      {
                        "Fn::GetAtt": [
                          "ConversationMessagePirateChat",
                          "Outputs.transformerrootstackConversationMessagePirateChatConversationMessagePirateChatTableFC80206BTableArn",
                        ],
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      },
      "";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: AssistantResponseMutation verify session owner slot function code 1`] = `
"export function request(ctx) {
  const { authFilter } = ctx.stash;
  const { conversationId } = ctx.args.input;

  const query = {
    expression: 'id = :id',
    expressionValues: util.dynamodb.toMapValues({
      ':id': conversationId,
    }),
  };

  const filter = JSON.parse(util.transform.toDynamoDBFilterExpression(authFilter));

  return {
    operation: 'Query',
    query,
    filter,
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }

  if (ctx.result.items.length !== 0) {
    return ctx.result.items[0];
  }

  util.error('Conversation not found', 'ResourceNotFound');
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: AssistantResponseStreamMutation auth slot function code 1`] = `
"export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: AssistantResponseStreamMutation data slot function code 1`] = `
"import { util } from '@aws-appsync/utils';
import * as ddb from '@aws-appsync/utils/dynamodb';

/**
 * Sends a request to the attached data source
 * @param {import('@aws-appsync/utils').Context} ctx the context
 * @returns {*} the request
 */
export function request(ctx) {
  const {
    conversationId,
    associatedUserMessageId,
    accumulatedTurnContent,
    errors,
  } = ctx.args.input;

  const { owner } = ctx.args;

  if (errors) {
    runtime.earlyReturn({
      id: \`\${associatedUserMessageId}#response\`,
      conversationId,
      associatedUserMessageId,
      errors,
      owner,
    });
  }
  const { createdAt, updatedAt } = ctx.stash.defaultValues;

  const assistantResponseId = \`\${associatedUserMessageId}#response\`;
  const expression = 'SET #typename = :typename, #conversationId = :conversationId, #associatedUserMessageId = :associatedUserMessageId, #role = :role, #content = :content, #owner = :owner, #createdAt = if_not_exists(#createdAt, :createdAt), #updatedAt = :updatedAt';

  const expressionValues = util.dynamodb.toMapValues({
    ':typename': 'ConversationMessagePirateChat',
    ':conversationId': conversationId,
    ':associatedUserMessageId': associatedUserMessageId,
    ':role': 'assistant',
    ':content': accumulatedTurnContent,
    ':owner': owner,
    ':createdAt': createdAt,
    ':updatedAt': updatedAt,
  });

  // https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html
  const expressionNames = {
    '#typename': '__typename',
    '#conversationId': 'conversationId',
    '#associatedUserMessageId': 'associatedUserMessageId',
    '#role': 'role',
    '#content': 'content',
    '#owner': 'owner',
    '#createdAt': 'createdAt',
    '#updatedAt': 'updatedAt',
  };

  return {
    operation: 'UpdateItem',
    key: util.dynamodb.toMapValues({ id: assistantResponseId }),
    update: {
      expression,
      expressionValues,
      expressionNames,
    },
  };
}

/**
 * Returns the resolver result
 * @param {import('@aws-appsync/utils').Context} ctx the context
 * @returns {*} the result
 */
export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }
  const streamId = \`\${ctx.args.input.associatedUserMessageId}#stream\`;
  const { owner } = ctx.args;
  const event = ctx.args.input;

  const streamEvent = {
    ...event,
    __typename: 'ConversationMessageStreamPart',
    id: streamId,
    owner,
  };

  // TODO: The lambda event should provide the toolUse directly.
  if (event.contentBlockToolUse && event.contentBlockToolUse.toolUse) {
    streamEvent.contentBlockToolUse = event.contentBlockToolUse.toolUse;
  }

  return streamEvent;
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: AssistantResponseStreamMutation init slot function code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export function request(ctx) {
  ctx.stash.graphqlApiEndpoint = '",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "GraphQLUrl",
        ],
      },
      "';
  ctx.stash.defaultValues = ctx.stash.defaultValues ?? {};
  ctx.stash.defaultValues.id = util.autoId();
  const createdAt = util.time.nowISO8601();
  ctx.stash.defaultValues.createdAt = createdAt;
  ctx.stash.defaultValues.updatedAt = createdAt;
  return {
    version: '2018-05-09',
    payload: {},
  };
}

export function response(ctx) {
  return {};
}
",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: AssistantResponseStreamMutation resolver code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Mutation";
  ctx.stash.fieldName = "createAssistantResponseStreamPirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "AMAZON_DYNAMODB";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  ctx.stash.tableName = "",
      {
        "Fn::Select": [
          1,
          {
            "Fn::Split": [
              "/",
              {
                "Fn::Select": [
                  5,
                  {
                    "Fn::Split": [
                      ":",
                      {
                        "Fn::GetAtt": [
                          "ConversationMessagePirateChat",
                          "Outputs.transformerrootstackConversationMessagePirateChatConversationMessagePirateChatTableFC80206BTableArn",
                        ],
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      },
      "";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: AssistantResponseStreamMutation verify session owner slot function code 1`] = `
"export function request(ctx) {
  const { authFilter } = ctx.stash;
  const { conversationId } = ctx.args.input;

  const query = {
    expression: 'id = :id',
    expressionValues: util.dynamodb.toMapValues({
      ':id': conversationId,
    }),
  };

  const filter = JSON.parse(util.transform.toDynamoDBFilterExpression(authFilter));

  return {
    operation: 'Query',
    query,
    filter,
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }

  if (ctx.result.items.length !== 0) {
    return ctx.result.items[0];
  }

  util.error('Conversation not found', 'ResourceNotFound');
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: AssistantResponseSubscription data slot function code 1`] = `
"import { util, extensions } from '@aws-appsync/utils';

export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  ctx.args.filter = { ...ctx.stash.authFilter, and: [{ conversationId: { eq: ctx.args.conversationId } }] };
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  const subscriptionFilter = util.transform.toSubscriptionFilter(ctx.args.filter);
  extensions.setSubscriptionFilter(subscriptionFilter);
  return null;
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: AssistantResponseSubscription resolver code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Subscription";
  ctx.stash.fieldName = "onCreateAssistantResponsePirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "NONE";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: ListConversationsInit resolver function code 1`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  ctx.stash.metadata.index = 'gsi-Conversation.typename.updatedAt';
  ctx.stash.modelQueryExpression = {
      expression: '#typename = :typename',
      expressionNames: {
        '#typename': '__typename',
      },
      expressionValues: util.dynamodb.toMapValues({
        ':typename': 'ConversationPirateChat',
      }),
    };
  ctx.args.sortDirection = 'DESC';
  return {};
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: ListMessagesInit resolver function code 1`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  ctx.stash.metadata.index = 'gsi-ConversationMessage.conversationId.createdAt';
  const conversationId = ctx.args?.filter?.conversationId?.eq;
  if (conversationId) {
    // If a conversationId was provided, we're going to execute a query
    // rather than a scan. The index (gsi) we're performing this query on has
    // a partitionKey of conversationId.
    // We need to remove conversationId from the filter to prevent a
    // DynamoDB exception:
    // \`Filter Expression can only contain non-primary key attributes\`
    delete ctx.args.filter.conversationId;
    // If conversationId was the only filter, remove the filter object
    // to prevent errors when the \`{}\` filter is combined with
    // the \`authFilter\` further downstream.
    if (Object.keys(ctx.args.filter).length === 0) {
        delete ctx.args.filter;
    }
    ctx.stash.modelQueryExpression = {
      expression: '#conversationId = :conversationId',
      expressionNames: {
        '#conversationId': 'conversationId',
      },
      expressionValues: util.dynamodb.toMapValues({
        ':conversationId': conversationId,
      }),
    };
  }
  ctx.args.sortDirection = 'DESC';
  return {};
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: ListMessagesPostDataLoad resolver function code 1`] = `
"export function request(ctx) {
  return {};
}

export function response(ctx) {
  // Conversation messages are retrieved from DynamoDB in descending order by createdAt.
  // We reverse them here because the most recent messages should be last in the list for clients:
  // We can't use ascending order because we can miss the most recent messages due to limits / pagination.
  const { items, ...rest } = ctx.prev.result;
  const reversed = items.reverse();
  return { items: reversed, ...rest };
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: SendMessageMutation auth slot function code 1`] = `
"export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: SendMessageMutation init slot function code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export function request(ctx) {
  ctx.stash.graphqlApiEndpoint = '",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "GraphQLUrl",
        ],
      },
      "';
  ctx.stash.defaultValues = ctx.stash.defaultValues ?? {};
  ctx.stash.defaultValues.id = util.autoId();
  const createdAt = util.time.nowISO8601();
  ctx.stash.defaultValues.createdAt = createdAt;
  ctx.stash.defaultValues.updatedAt = createdAt;
  return {
    version: '2018-05-09',
    payload: {},
  };
}

export function response(ctx) {
  return {};
}
",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: SendMessageMutation invoke lambda slot function code 1`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { args, request } = ctx;
  const { graphqlApiEndpoint } = ctx.stash;

  const selectionSet = 'associatedUserMessageId contentBlockDeltaIndex contentBlockDoneAtIndex contentBlockIndex contentBlockText contentBlockToolUse { toolUseId name input } conversationId id stopReason owner errors { errorType message }';

  const streamingResponseMutation = {
    name: 'createAssistantResponseStreamPirateChat',
    inputTypeName: 'CreateConversationMessagePirateChatAssistantStreamingInput',
    selectionSet,
  };

  const currentMessageId = ctx.stash.defaultValues.id;

  const modelConfiguration = {
    modelId: "anthropic.claude-3-haiku-20240307-v1:0",
    systemPrompt: "You are a helpful chatbot. Answer questions to the best of your ability.",
    inferenceConfiguration: undefined,
  };

  const clientTools = args.toolConfiguration?.tools?.map((tool) => {
    return { ...tool.toolSpec };
  });
  const dataTools = [{"name":"getTemperature","description":"does a thing","inputSchema":{"json":{"type":"object","properties":{"city":{"type":"string","description":"A UTF-8 character sequence."}},"required":["city"]}},"graphqlRequestInputDescriptor":{"selectionSet":"value unit","propertyTypes":{"city":"String!"},"queryName":"getTemperature"}},{"name":"plus","description":"does a different thing","inputSchema":{"json":{"type":"object","properties":{"a":{"type":"number","description":"A signed 32-bit integer value."},"b":{"type":"number","description":"A signed 32-bit integer value."}},"required":[]}},"graphqlRequestInputDescriptor":{"selectionSet":"","propertyTypes":{"a":"Int","b":"Int"},"queryName":"plus"}}];
  const toolsConfiguration = { dataTools, clientTools };

  const messageHistoryQuery = {
    getQueryName: 'getConversationMessagePirateChat',
    getQueryInputTypeName: 'ID',
    listQueryName: 'listConversationMessagePirateChats',
    listQueryInputTypeName: 'ModelConversationMessagePirateChatFilterInput',
    listQueryLimit: undefined,
  };

  const authHeader = request.headers['authorization'];
  const payload = {
    conversationId: args.conversationId,
    currentMessageId,
    responseMutation: streamingResponseMutation,
    graphqlApiEndpoint,
    modelConfiguration,
    request: { headers: { authorization: authHeader } },
    messageHistoryQuery,
    toolsConfiguration,
    streamResponse: true,
  };

  return {
    operation: 'Invoke',
    payload,
    invocationType: 'Event',
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.appendError(ctx.error.message, ctx.error.type);
  }
  const response = {
    __typename: 'ConversationMessagePirateChat',
    id: ctx.stash.defaultValues.id,
    conversationId: ctx.args.conversationId,
    role: 'user',
    content: ctx.args.content,
    aiContext: ctx.args.aiContext,
    toolConfiguration: ctx.args.toolConfiguration,
    createdAt: ctx.stash.defaultValues.createdAt,
    updatedAt: ctx.stash.defaultValues.updatedAt,
  };
  return response;
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: SendMessageMutation resolver code 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Mutation";
  ctx.stash.fieldName = "pirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "AWS_LAMBDA";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  ctx.stash.lambdaFunctionArn = "",
      {
        "Fn::GetAtt": [
          "PirateChatConversationDirectiveLambdaStack",
          "Outputs.transformerrootstackPirateChatConversationDirectiveLambdaStackPirateChatDefaultConversationHandlerconversationHandlerFunction2B526F1AArn",
        ],
      },
      "";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: SendMessageMutation verify session owner slot function code 1`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { authFilter } = ctx.stash;
  const { conversationId } = ctx.args;

  const filter = JSON.parse(util.transform.toDynamoDBFilterExpression(authFilter));

  return {
    operation: 'UpdateItem',
    key: util.dynamodb.toMapValues({ id: conversationId }),
    update: {
      expression: 'SET #updatedAt = :updatedAt',
      expressionValues: util.dynamodb.toMapValues({
        ':updatedAt': ctx.stash.defaultValues.createdAt,
      }),
      expressionNames: {
        '#updatedAt': 'updatedAt',
      },
    },
    condition: filter
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.error('Conversation not found', 'ResourceNotFound');
  }

  return ctx.result;
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools: SendMessageMutation write message to table slot function code 1`] = `
"import { util } from '@aws-appsync/utils';
import * as ddb from '@aws-appsync/utils/dynamodb';

export function request(ctx) {
  const args = ctx.stash.transformedArgs ?? ctx.args;
  const defaultValues = ctx.stash.defaultValues ?? {};
  const message = {
    __typename: 'ConversationMessagePirateChat',
    role: 'user',
    ...args,
    ...defaultValues,
  };
  const id = ctx.stash.defaultValues.id;

  return ddb.put({ key: { id }, item: message });
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  } else {
    return ctx.result;
  }
}
"
`;

exports[`testme: output schema 1`] = `
"type Mutation {
  pirateChat(conversationId: ID!, content: [ContentBlockInput], aiContext: AWSJSON, toolConfiguration: ToolConfigurationInput): ConversationMessage
  createAssistantResponsePirateChat(input: CreateConversationMessagePirateChatAssistantInput!): ConversationMessagePirateChat @aws_cognito_user_pools
  createAssistantResponseStreamPirateChat(input: CreateConversationMessagePirateChatAssistantStreamingInput!): ConversationMessageStreamPart @aws_cognito_user_pools
  createConversationPirateChat(input: CreateConversationPirateChatInput!, condition: ModelConversationPirateChatConditionInput): ConversationPirateChat
  updateConversationPirateChat(input: UpdateConversationPirateChatInput!, condition: ModelConversationPirateChatConditionInput): ConversationPirateChat
  deleteConversationPirateChat(input: DeleteConversationPirateChatInput!, condition: ModelConversationPirateChatConditionInput): ConversationPirateChat
  createConversationMessagePirateChat(input: CreateConversationMessagePirateChatInput!, condition: ModelConversationMessagePirateChatConditionInput): ConversationMessagePirateChat
  deleteConversationMessagePirateChat(input: DeleteConversationMessagePirateChatInput!, condition: ModelConversationMessagePirateChatConditionInput): ConversationMessagePirateChat
}

enum ConversationParticipantRole {
  user
  assistant
}

interface ConversationMessage {
  id: ID!
  conversationId: ID!
  role: ConversationParticipantRole
  content: [ContentBlock]
  context: AWSJSON
  toolConfiguration: ToolConfiguration
  associatedUserMessageId: ID
}

input DocumentBlockSourceInput {
  bytes: String
}

input DocumentBlockInput {
  format: String!
  name: String!
  source: DocumentBlockSourceInput!
}

input ImageBlockSourceInput {
  bytes: String
}

input ImageBlockInput {
  format: String!
  source: ImageBlockSourceInput!
}

input ToolResultContentBlockInput {
  document: DocumentBlockInput
  image: ImageBlockInput
  json: AWSJSON
  text: String
}

input ToolResultBlockInput {
  content: [ToolResultContentBlockInput!]!
  toolUseId: String!
  status: String
}

type DocumentBlockSource {
  bytes: String
}

type DocumentBlock {
  format: String!
  name: String!
  source: DocumentBlockSource!
}

type ImageBlock {
  format: String!
  source: ImageBlockSource!
}

type ImageBlockSource {
  bytes: String
}

type ToolUseBlock {
  toolUseId: String!
  name: String!
  input: AWSJSON!
}

type ToolResultContentBlock {
  document: DocumentBlock
  image: ImageBlock
  json: AWSJSON
  text: String
}

type ToolResultBlock {
  content: [ToolResultContentBlock!]!
  toolUseId: String!
  status: String
}

type ContentBlockText {
  text: String
}

type ContentBlockImage {
  image: ImageBlock
}

type ContentBlockDocument {
  document: DocumentBlock
}

type ContentBlockToolUse {
  toolUse: ToolUseBlock
}

type ContentBlockToolResult {
  toolResult: ToolResultBlock
}

input ContentBlockInput {
  text: String
  document: DocumentBlockInput
  image: ImageBlockInput
  toolResult: ToolResultBlockInput
}

type ContentBlock {
  text: String
  document: DocumentBlock
  image: ImageBlock
  toolResult: ToolResultBlock
  toolUse: ToolUseBlock
}

input ToolConfigurationInput {
  tools: [ToolInput]
}

input ToolInput {
  toolSpec: ToolSpecificationInput
}

input ToolSpecificationInput {
  name: String!
  description: String
  inputSchema: ToolInputSchemaInput!
}

input ToolInputSchemaInput {
  json: AWSJSON
}

type ToolConfiguration {
  tools: [Tool]
}

type Tool {
  toolSpec: ToolSpecification
}

type ToolSpecification {
  name: String!
  description: String
  inputSchema: ToolInputSchema!
}

type ToolInputSchema {
  json: AWSJSON
}

type ConversationMessageStreamPart {
  id: ID!
  owner: String
  conversationId: ID!
  associatedUserMessageId: ID!
  contentBlockIndex: Int
  contentBlockText: String
  contentBlockDeltaIndex: Int
  contentBlockToolUse: ToolUseBlock
  contentBlockDoneAtIndex: Int
  stopReason: String
  errors: [ConversationTurnError]
}

type ConversationTurnError {
  message: String!
  errorType: String!
}

input ConversationTurnErrorInput {
  errorType: String!
  message: String!
}

input CreateConversationMessagePirateChatAssistantInput {
  conversationId: ID
  content: [ContentBlockInput]
  associatedUserMessageId: ID
}

input CreateConversationMessagePirateChatAssistantStreamingInput {
  conversationId: ID!
  associatedUserMessageId: ID!
  contentBlockIndex: Int
  contentBlockText: String
  contentBlockDeltaIndex: Int
  contentBlockToolUse: AWSJSON
  contentBlockDoneAtIndex: Int
  stopReason: String
  accumulatedTurnContent: [ContentBlockInput]
  errors: [ConversationTurnErrorInput]
}

type Subscription {
  onCreateAssistantResponsePirateChat(conversationId: ID): ConversationMessageStreamPart @aws_subscribe(mutations: ["createAssistantResponseStreamPirateChat"]) @aws_cognito_user_pools
  onCreateConversationMessagePirateChat(filter: ModelSubscriptionConversationMessagePirateChatFilterInput, owner: String): ConversationMessagePirateChat @aws_subscribe(mutations: ["createConversationMessagePirateChat"])
}

type ConversationPirateChat {
  id: ID!
  name: String
  metadata: AWSJSON
  messages(filter: ModelConversationMessagePirateChatFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelConversationMessagePirateChatConnection
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  owner: String
}

type ConversationMessagePirateChat implements ConversationMessage {
  id: ID!
  conversationId: ID!
  conversation: ConversationPirateChat
  role: ConversationParticipantRole
  content: [ContentBlock]
  aiContext: AWSJSON
  toolConfiguration: ToolConfiguration
  associatedUserMessageId: ID
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  owner: String
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelSubscriptionStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  in: [String]
  notIn: [String]
}

input ModelSubscriptionIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  in: [Int]
  notIn: [Int]
}

input ModelSubscriptionFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  in: [Float]
  notIn: [Float]
}

input ModelSubscriptionBooleanInput {
  ne: Boolean
  eq: Boolean
}

input ModelSubscriptionIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  in: [ID]
  notIn: [ID]
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelConversationPirateChatConnection {
  items: [ConversationPirateChat]!
  nextToken: String
}

input ModelConversationPirateChatFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  metadata: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelConversationPirateChatFilterInput]
  or: [ModelConversationPirateChatFilterInput]
  not: ModelConversationPirateChatFilterInput
  owner: ModelStringInput
}

type Query {
  getConversationPirateChat(id: ID!): ConversationPirateChat
  listConversationPirateChats(filter: ModelConversationPirateChatFilterInput, limit: Int, nextToken: String): ModelConversationPirateChatConnection
  getConversationMessagePirateChat(id: ID!): ConversationMessagePirateChat
  listConversationMessagePirateChats(filter: ModelConversationMessagePirateChatFilterInput, limit: Int, nextToken: String): ModelConversationMessagePirateChatConnection
}

input ModelConversationPirateChatConditionInput {
  name: ModelStringInput
  metadata: ModelStringInput
  and: [ModelConversationPirateChatConditionInput]
  or: [ModelConversationPirateChatConditionInput]
  not: ModelConversationPirateChatConditionInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  owner: ModelStringInput
}

input CreateConversationPirateChatInput {
  id: ID
  name: String
  metadata: AWSJSON
}

input UpdateConversationPirateChatInput {
  id: ID!
  name: String
  metadata: AWSJSON
}

input DeleteConversationPirateChatInput {
  id: ID!
}

type ModelConversationMessagePirateChatConnection {
  items: [ConversationMessagePirateChat]!
  nextToken: String
}

input ModelConversationParticipantRoleInput {
  eq: ConversationParticipantRole
  ne: ConversationParticipantRole
}

input ModelConversationMessagePirateChatFilterInput {
  id: ModelIDInput
  conversationId: ModelIDInput
  role: ModelConversationParticipantRoleInput
  aiContext: ModelStringInput
  associatedUserMessageId: ModelIDInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelConversationMessagePirateChatFilterInput]
  or: [ModelConversationMessagePirateChatFilterInput]
  not: ModelConversationMessagePirateChatFilterInput
  owner: ModelStringInput
}

input ModelConversationMessagePirateChatConditionInput {
  conversationId: ModelIDInput
  role: ModelConversationParticipantRoleInput
  aiContext: ModelStringInput
  associatedUserMessageId: ModelIDInput
  and: [ModelConversationMessagePirateChatConditionInput]
  or: [ModelConversationMessagePirateChatConditionInput]
  not: ModelConversationMessagePirateChatConditionInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  owner: ModelStringInput
}

input CreateConversationMessagePirateChatInput {
  id: ID
  conversationId: ID!
  role: ConversationParticipantRole
  content: [ContentBlockInput]
  aiContext: AWSJSON
  toolConfiguration: ToolConfigurationInput
  associatedUserMessageId: ID
}

input DeleteConversationMessagePirateChatInput {
  id: ID!
}

input ModelSubscriptionConversationMessagePirateChatFilterInput {
  id: ModelSubscriptionIDInput
  conversationId: ModelSubscriptionIDInput
  role: ModelSubscriptionStringInput
  aiContext: ModelSubscriptionStringInput
  associatedUserMessageId: ModelSubscriptionIDInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionConversationMessagePirateChatFilterInput]
  or: [ModelSubscriptionConversationMessagePirateChatFilterInput]
  owner: ModelStringInput
}
"
`;

exports[`testme: preprocessed schema 1`] = `
"type Mutation {
  pirateChat(conversationId: ID!, content: [ContentBlockInput], aiContext: AWSJSON, toolConfiguration: ToolConfigurationInput): ConversationMessage @conversation(aiModel: "anthropic.claude-3-haiku-20240307-v1:0", handler: {functionName: "FnpirateChat", eventVersion: "1.0"}, systemPrompt: "You are a helpful chatbot. Answer questions to the best of your ability.")
}

enum ConversationParticipantRole {
  user
  assistant
}

interface ConversationMessage {
  id: ID!
  conversationId: ID!
  role: ConversationParticipantRole
  content: [ContentBlock]
  context: AWSJSON
  toolConfiguration: ToolConfiguration
  associatedUserMessageId: ID
}

input DocumentBlockSourceInput {
  bytes: String
}

input DocumentBlockInput {
  format: String!
  name: String!
  source: DocumentBlockSourceInput!
}

input ImageBlockSourceInput {
  bytes: String
}

input ImageBlockInput {
  format: String!
  source: ImageBlockSourceInput!
}

input ToolResultContentBlockInput {
  document: DocumentBlockInput
  image: ImageBlockInput
  json: AWSJSON
  text: String
}

input ToolResultBlockInput {
  content: [ToolResultContentBlockInput!]!
  toolUseId: String!
  status: String
}

type DocumentBlockSource {
  bytes: String
}

type DocumentBlock {
  format: String!
  name: String!
  source: DocumentBlockSource!
}

type ImageBlock {
  format: String!
  source: ImageBlockSource!
}

type ImageBlockSource {
  bytes: String
}

type ToolUseBlock {
  toolUseId: String!
  name: String!
  input: AWSJSON!
}

type ToolResultContentBlock {
  document: DocumentBlock
  image: ImageBlock
  json: AWSJSON
  text: String
}

type ToolResultBlock {
  content: [ToolResultContentBlock!]!
  toolUseId: String!
  status: String
}

type ContentBlockText {
  text: String
}

type ContentBlockImage {
  image: ImageBlock
}

type ContentBlockDocument {
  document: DocumentBlock
}

type ContentBlockToolUse {
  toolUse: ToolUseBlock
}

type ContentBlockToolResult {
  toolResult: ToolResultBlock
}

input ContentBlockInput {
  text: String
  document: DocumentBlockInput
  image: ImageBlockInput
  toolResult: ToolResultBlockInput
}

type ContentBlock {
  text: String
  document: DocumentBlock
  image: ImageBlock
  toolResult: ToolResultBlock
  toolUse: ToolUseBlock
}

input ToolConfigurationInput {
  tools: [ToolInput]
}

input ToolInput {
  toolSpec: ToolSpecificationInput
}

input ToolSpecificationInput {
  name: String!
  description: String
  inputSchema: ToolInputSchemaInput!
}

input ToolInputSchemaInput {
  json: AWSJSON
}

type ToolConfiguration {
  tools: [Tool]
}

type Tool {
  toolSpec: ToolSpecification
}

type ToolSpecification {
  name: String!
  description: String
  inputSchema: ToolInputSchema!
}

type ToolInputSchema {
  json: AWSJSON
}

type ConversationMessageStreamPart {
  id: ID!
  owner: String
  conversationId: ID!
  associatedUserMessageId: ID!
  contentBlockIndex: Int
  contentBlockText: String
  contentBlockDeltaIndex: Int
  contentBlockToolUse: ToolUseBlock
  contentBlockDoneAtIndex: Int
  stopReason: String
  errors: [ConversationTurnError]
}

type ConversationTurnError {
  message: String!
  errorType: String!
}
"
`;
