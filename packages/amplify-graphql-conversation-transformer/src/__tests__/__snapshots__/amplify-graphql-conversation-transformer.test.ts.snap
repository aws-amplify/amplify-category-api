// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Mutation";
  ctx.stash.fieldName = "pirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "AWS_LAMBDA";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  ctx.stash.lambdaFunctionArn = "",
      {
        "Fn::GetAtt": [
          "PirateChatConversationDirectiveLambdaStack",
          "Outputs.transformerrootstackPirateChatConversationDirectiveLambdaStackPirateChatDefaultConversationHandlerconversationHandlerFunction2B526F1AArn",
        ],
      },
      "";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration 2`] = `
"export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration 3`] = `
"export function request(ctx) {
  const { authFilter } = ctx.stash;
  const { conversationId } = ctx.args;

  const query = {
    expression: 'id = :id',
    expressionValues: util.dynamodb.toMapValues({
      ':id': conversationId,
    }),
  };

  const filter = JSON.parse(util.transform.toDynamoDBFilterExpression(authFilter));

  return {
    operation: 'Query',
    query,
    filter,
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }

  if (ctx.result.items.length !== 0) {
    return ctx.result.items[0];
  }

  util.error('Conversation not found', 'ResourceNotFound');
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration 4`] = `
"import { util } from '@aws-appsync/utils';
import * as ddb from '@aws-appsync/utils/dynamodb';

export function request(ctx) {
  const args = ctx.stash.transformedArgs ?? ctx.args;
  const defaultValues = ctx.stash.defaultValues ?? {};
  const message = {
    __typename: 'ConversationMessagePirateChat',
    role: 'user',
    ...args,
    ...defaultValues,
  };
  const id = ctx.stash.defaultValues.id;

  return ddb.put({ key: { id }, item: message });
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  } else {
    return ctx.result;
  }
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with inference configuration 5`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { args, request } = ctx;
  const { graphqlApiEndpoint } = ctx.stash;

  
  const selectionSet = 'id conversationId content { image { format source { bytes }} text toolUse { toolUseId name input } toolResult { status toolUseId content { json text image { format source { bytes }} document { format name source { bytes }} }}} role owner createdAt updatedAt';

  const responseMutation = {
    name: 'createAssistantResponsePirateChat',
    inputTypeName: 'CreateConversationMessagePirateChatAssistantInput',
    selectionSet,
  };
  const currentMessageId = ctx.stash.defaultValues.id;
  const modelConfiguration = {
  modelId: 'anthropic.claude-3-haiku-20240307-v1:0',
  systemPrompt: "You are a helpful chatbot. Answer questions to the best of your ability.",
  inferenceConfiguration: {"temperature":0.5,"topP":0.9,"maxTokens":100},
};

  const clientTools = args.toolConfiguration?.tools?.map((tool) => {
    return { ...tool.toolSpec };
  });
  const toolsConfiguration = {
  clientTools
};

  const messageHistoryQuery = {
    getQueryName: 'getConversationMessagePirateChat',
    getQueryInputTypeName: 'ID',
    listQueryName: 'listConversationMessagePirateChats',
    listQueryInputTypeName: 'ModelConversationMessagePirateChatFilterInput',
    listQueryLimit: undefined,
  };

  const authHeader = request.headers['authorization'];
  const payload = {
    conversationId: args.conversationId,
    currentMessageId,
    responseMutation,
    graphqlApiEndpoint,
    modelConfiguration,
    request: { headers: { authorization: authHeader } },
    messageHistoryQuery,
    toolsConfiguration,
  };

  return {
    operation: 'Invoke',
    payload,
    invocationType: 'Event',
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.appendError(ctx.error.message, ctx.error.type);
  }
  const response = {
    __typename: 'ConversationMessagePirateChat',
    id: ctx.stash.defaultValues.id,
    conversationId: ctx.args.conversationId,
    role: 'user',
    content: ctx.args.content,
    aiContext: ctx.args.aiContext,
    toolConfiguration: ctx.args.toolConfiguration,
    createdAt: ctx.stash.defaultValues.createdAt,
    updatedAt: ctx.stash.defaultValues.updatedAt,
  };
  return response;
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Mutation";
  ctx.stash.fieldName = "pirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "AWS_LAMBDA";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  ctx.stash.lambdaFunctionArn = "",
      {
        "Fn::GetAtt": [
          "PirateChatConversationDirectiveLambdaStack",
          "Outputs.transformerrootstackPirateChatConversationDirectiveLambdaStackPirateChatDefaultConversationHandlerconversationHandlerFunction2B526F1AArn",
        ],
      },
      "";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool 2`] = `
"export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool 3`] = `
"export function request(ctx) {
  const { authFilter } = ctx.stash;
  const { conversationId } = ctx.args;

  const query = {
    expression: 'id = :id',
    expressionValues: util.dynamodb.toMapValues({
      ':id': conversationId,
    }),
  };

  const filter = JSON.parse(util.transform.toDynamoDBFilterExpression(authFilter));

  return {
    operation: 'Query',
    query,
    filter,
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }

  if (ctx.result.items.length !== 0) {
    return ctx.result.items[0];
  }

  util.error('Conversation not found', 'ResourceNotFound');
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool 4`] = `
"import { util } from '@aws-appsync/utils';
import * as ddb from '@aws-appsync/utils/dynamodb';

export function request(ctx) {
  const args = ctx.stash.transformedArgs ?? ctx.args;
  const defaultValues = ctx.stash.defaultValues ?? {};
  const message = {
    __typename: 'ConversationMessagePirateChat',
    role: 'user',
    ...args,
    ...defaultValues,
  };
  const id = ctx.stash.defaultValues.id;

  return ddb.put({ key: { id }, item: message });
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  } else {
    return ctx.result;
  }
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool 5`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { args, request } = ctx;
  const { graphqlApiEndpoint } = ctx.stash;

  const toolDefinitions = {"tools":[{"name":"listTodos","description":"lists todos","inputSchema":{"json":{"type":"object","properties":{},"required":[]}},"graphqlRequestInputDescriptor":{"selectionSet":"items { content isDone id createdAt updatedAt owner } nextToken","propertyTypes":{},"queryName":"listTodos"}}]};
  const selectionSet = 'id conversationId content { image { format source { bytes }} text toolUse { toolUseId name input } toolResult { status toolUseId content { json text image { format source { bytes }} document { format name source { bytes }} }}} role owner createdAt updatedAt';

  const responseMutation = {
    name: 'createAssistantResponsePirateChat',
    inputTypeName: 'CreateConversationMessagePirateChatAssistantInput',
    selectionSet,
  };
  const currentMessageId = ctx.stash.defaultValues.id;
  const modelConfiguration = {
  modelId: 'anthropic.claude-3-haiku-20240307-v1:0',
  systemPrompt: "You are a helpful chatbot. Answer questions to the best of your ability.",
  
};

  const clientTools = args.toolConfiguration?.tools?.map((tool) => {
    return { ...tool.toolSpec };
  });
  const dataTools = toolDefinitions.tools;
 const toolsConfiguration = {
  dataTools,
  clientTools,
};

  const messageHistoryQuery = {
    getQueryName: 'getConversationMessagePirateChat',
    getQueryInputTypeName: 'ID',
    listQueryName: 'listConversationMessagePirateChats',
    listQueryInputTypeName: 'ModelConversationMessagePirateChatFilterInput',
    listQueryLimit: undefined,
  };

  const authHeader = request.headers['authorization'];
  const payload = {
    conversationId: args.conversationId,
    currentMessageId,
    responseMutation,
    graphqlApiEndpoint,
    modelConfiguration,
    request: { headers: { authorization: authHeader } },
    messageHistoryQuery,
    toolsConfiguration,
  };

  return {
    operation: 'Invoke',
    payload,
    invocationType: 'Event',
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.appendError(ctx.error.message, ctx.error.type);
  }
  const response = {
    __typename: 'ConversationMessagePirateChat',
    id: ctx.stash.defaultValues.id,
    conversationId: ctx.args.conversationId,
    role: 'user',
    content: ctx.args.content,
    aiContext: ctx.args.aiContext,
    toolConfiguration: ctx.args.toolConfiguration,
    createdAt: ctx.stash.defaultValues.createdAt,
    updatedAt: ctx.stash.defaultValues.updatedAt,
  };
  return response;
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Mutation";
  ctx.stash.fieldName = "pirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "AWS_LAMBDA";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  ctx.stash.lambdaFunctionArn = "",
      {
        "Fn::GetAtt": [
          "PirateChatConversationDirectiveLambdaStack",
          "Outputs.transformerrootstackPirateChatConversationDirectiveLambdaStackPirateChatDefaultConversationHandlerconversationHandlerFunction2B526F1AArn",
        ],
      },
      "";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships 2`] = `
"export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships 3`] = `
"export function request(ctx) {
  const { authFilter } = ctx.stash;
  const { conversationId } = ctx.args;

  const query = {
    expression: 'id = :id',
    expressionValues: util.dynamodb.toMapValues({
      ':id': conversationId,
    }),
  };

  const filter = JSON.parse(util.transform.toDynamoDBFilterExpression(authFilter));

  return {
    operation: 'Query',
    query,
    filter,
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }

  if (ctx.result.items.length !== 0) {
    return ctx.result.items[0];
  }

  util.error('Conversation not found', 'ResourceNotFound');
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships 4`] = `
"import { util } from '@aws-appsync/utils';
import * as ddb from '@aws-appsync/utils/dynamodb';

export function request(ctx) {
  const args = ctx.stash.transformedArgs ?? ctx.args;
  const defaultValues = ctx.stash.defaultValues ?? {};
  const message = {
    __typename: 'ConversationMessagePirateChat',
    role: 'user',
    ...args,
    ...defaultValues,
  };
  const id = ctx.stash.defaultValues.id;

  return ddb.put({ key: { id }, item: message });
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  } else {
    return ctx.result;
  }
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with model query tool including relationships 5`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { args, request } = ctx;
  const { graphqlApiEndpoint } = ctx.stash;

  const toolDefinitions = {"tools":[{"name":"listCustomers","description":"Provides data about the customer sending a message","inputSchema":{"json":{"type":"object","properties":{},"required":[]}},"graphqlRequestInputDescriptor":{"selectionSet":"items { name email activeCart { products { name price } customerId id createdAt updatedAt owner } orderHistory { items { products { name price } customerId id createdAt updatedAt owner } nextToken } id createdAt updatedAt owner } nextToken","propertyTypes":{},"queryName":"listCustomers"}}]};
  const selectionSet = 'id conversationId content { image { format source { bytes }} text toolUse { toolUseId name input } toolResult { status toolUseId content { json text image { format source { bytes }} document { format name source { bytes }} }}} role owner createdAt updatedAt';

  const responseMutation = {
    name: 'createAssistantResponsePirateChat',
    inputTypeName: 'CreateConversationMessagePirateChatAssistantInput',
    selectionSet,
  };
  const currentMessageId = ctx.stash.defaultValues.id;
  const modelConfiguration = {
  modelId: 'anthropic.claude-3-haiku-20240307-v1:0',
  systemPrompt: "You are a helpful chatbot. Answer questions to the best of your ability.",
  
};

  const clientTools = args.toolConfiguration?.tools?.map((tool) => {
    return { ...tool.toolSpec };
  });
  const dataTools = toolDefinitions.tools;
 const toolsConfiguration = {
  dataTools,
  clientTools,
};

  const messageHistoryQuery = {
    getQueryName: 'getConversationMessagePirateChat',
    getQueryInputTypeName: 'ID',
    listQueryName: 'listConversationMessagePirateChats',
    listQueryInputTypeName: 'ModelConversationMessagePirateChatFilterInput',
    listQueryLimit: undefined,
  };

  const authHeader = request.headers['authorization'];
  const payload = {
    conversationId: args.conversationId,
    currentMessageId,
    responseMutation,
    graphqlApiEndpoint,
    modelConfiguration,
    request: { headers: { authorization: authHeader } },
    messageHistoryQuery,
    toolsConfiguration,
  };

  return {
    operation: 'Invoke',
    payload,
    invocationType: 'Event',
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.appendError(ctx.error.message, ctx.error.type);
  }
  const response = {
    __typename: 'ConversationMessagePirateChat',
    id: ctx.stash.defaultValues.id,
    conversationId: ctx.args.conversationId,
    role: 'user',
    content: ctx.args.content,
    aiContext: ctx.args.aiContext,
    toolConfiguration: ctx.args.toolConfiguration,
    createdAt: ctx.stash.defaultValues.createdAt,
    updatedAt: ctx.stash.defaultValues.updatedAt,
  };
  return response;
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools 1`] = `
{
  "Fn::Join": [
    "",
    [
      "export const request = (ctx) => {
  ctx.stash.typeName = "Mutation";
  ctx.stash.fieldName = "pirateChat";
  ctx.stash.conditions = [];
  ctx.stash.metadata = {};
  ctx.stash.metadata.dataSourceType = "AWS_LAMBDA";
  ctx.stash.metadata.apiId = "",
      {
        "Fn::GetAtt": [
          "GraphQLAPI",
          "ApiId",
        ],
      },
      "";
  ctx.stash.connectionAttributes = {};
  ctx.stash.lambdaFunctionArn = "",
      {
        "Fn::GetAtt": [
          "PirateChatConversationDirectiveLambdaStack",
          "Outputs.transformerrootstackPirateChatConversationDirectiveLambdaStackPirateChatDefaultConversationHandlerconversationHandlerFunction2B526F1AArn",
        ],
      },
      "";
  ctx.stash.adminRoles = [];
  return {};
}

export const response = (ctx) => {
  return ctx.prev.result;
};",
    ],
  ],
}
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools 2`] = `
"export function request(ctx) {
  ctx.stash.hasAuth = true;
  const isAuthorized = false;

  if (util.authType() === 'User Pool Authorization') {
    if (!isAuthorized) {
      const authFilter = [];
      let ownerClaim0 = ctx.identity['claims']['sub'];
      ctx.args.owner = ownerClaim0;
      const currentClaim1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (ownerClaim0 && currentClaim1) {
        ownerClaim0 = ownerClaim0 + '::' + currentClaim1;
        authFilter.push({ owner: { eq: ownerClaim0 } });
      }
      const role0_0 = ctx.identity['claims']['sub'];
      if (role0_0) {
        authFilter.push({ owner: { eq: role0_0 } });
      }
      // we can just reuse currentClaim1 here, but doing this (for now) to mirror the existing
      // vtl auth resolver.
      const role0_1 = ctx.identity['claims']['username'] ?? ctx.identity['claims']['cognito:username'];
      if (role0_1) {
        authFilter.push({ owner: { eq: role0_1 } });
      }
      if (authFilter.length !== 0) {
        ctx.stash.authFilter = { or: authFilter };
      }
    }
  }
  if (!isAuthorized && ctx.stash.authFilter.length === 0) {
    util.unauthorized();
  }
  return { version: '2018-05-29', payload: {} };
}

export function response(ctx) {
  return {};
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools 3`] = `
"export function request(ctx) {
  const { authFilter } = ctx.stash;
  const { conversationId } = ctx.args;

  const query = {
    expression: 'id = :id',
    expressionValues: util.dynamodb.toMapValues({
      ':id': conversationId,
    }),
  };

  const filter = JSON.parse(util.transform.toDynamoDBFilterExpression(authFilter));

  return {
    operation: 'Query',
    query,
    filter,
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }

  if (ctx.result.items.length !== 0) {
    return ctx.result.items[0];
  }

  util.error('Conversation not found', 'ResourceNotFound');
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools 4`] = `
"import { util } from '@aws-appsync/utils';
import * as ddb from '@aws-appsync/utils/dynamodb';

export function request(ctx) {
  const args = ctx.stash.transformedArgs ?? ctx.args;
  const defaultValues = ctx.stash.defaultValues ?? {};
  const message = {
    __typename: 'ConversationMessagePirateChat',
    role: 'user',
    ...args,
    ...defaultValues,
  };
  const id = ctx.stash.defaultValues.id;

  return ddb.put({ key: { id }, item: message });
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  } else {
    return ctx.result;
  }
}
"
`;

exports[`ConversationTransformer valid schemas should transform conversation route with query tools 5`] = `
"import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { args, request } = ctx;
  const { graphqlApiEndpoint } = ctx.stash;

  const toolDefinitions = {"tools":[{"name":"getTemperature","description":"does a thing","inputSchema":{"json":{"type":"object","properties":{"city":{"type":"string","description":"A UTF-8 character sequence."}},"required":["city"]}},"graphqlRequestInputDescriptor":{"selectionSet":"value unit","propertyTypes":{"city":"String!"},"queryName":"getTemperature"}},{"name":"plus","description":"does a different thing","inputSchema":{"json":{"type":"object","properties":{"a":{"type":"number","description":"A signed 32-bit integer value."},"b":{"type":"number","description":"A signed 32-bit integer value."}},"required":[]}},"graphqlRequestInputDescriptor":{"selectionSet":"","propertyTypes":{"a":"Int","b":"Int"},"queryName":"plus"}}]};
  const selectionSet = 'id conversationId content { image { format source { bytes }} text toolUse { toolUseId name input } toolResult { status toolUseId content { json text image { format source { bytes }} document { format name source { bytes }} }}} role owner createdAt updatedAt';

  const responseMutation = {
    name: 'createAssistantResponsePirateChat',
    inputTypeName: 'CreateConversationMessagePirateChatAssistantInput',
    selectionSet,
  };
  const currentMessageId = ctx.stash.defaultValues.id;
  const modelConfiguration = {
  modelId: 'anthropic.claude-3-haiku-20240307-v1:0',
  systemPrompt: "You are a helpful chatbot. Answer questions to the best of your ability.",
  
};

  const clientTools = args.toolConfiguration?.tools?.map((tool) => {
    return { ...tool.toolSpec };
  });
  const dataTools = toolDefinitions.tools;
 const toolsConfiguration = {
  dataTools,
  clientTools,
};

  const messageHistoryQuery = {
    getQueryName: 'getConversationMessagePirateChat',
    getQueryInputTypeName: 'ID',
    listQueryName: 'listConversationMessagePirateChats',
    listQueryInputTypeName: 'ModelConversationMessagePirateChatFilterInput',
    listQueryLimit: undefined,
  };

  const authHeader = request.headers['authorization'];
  const payload = {
    conversationId: args.conversationId,
    currentMessageId,
    responseMutation,
    graphqlApiEndpoint,
    modelConfiguration,
    request: { headers: { authorization: authHeader } },
    messageHistoryQuery,
    toolsConfiguration,
  };

  return {
    operation: 'Invoke',
    payload,
    invocationType: 'Event',
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.appendError(ctx.error.message, ctx.error.type);
  }
  const response = {
    __typename: 'ConversationMessagePirateChat',
    id: ctx.stash.defaultValues.id,
    conversationId: ctx.args.conversationId,
    role: 'user',
    content: ctx.args.content,
    aiContext: ctx.args.aiContext,
    toolConfiguration: ctx.args.toolConfiguration,
    createdAt: ctx.stash.defaultValues.createdAt,
    updatedAt: ctx.stash.defaultValues.updatedAt,
  };
  return response;
}
"
`;
